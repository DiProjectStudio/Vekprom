var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};

function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}

var inputmask = {
    exports: {}
};

/*!
 * dist/inputmask
 * https://github.com/RobinHerbots/Inputmask
 * Copyright (c) 2010 - 2024 Robin Herbots
 * Licensed under the MIT license
 * Version: 5.0.9
 */ (function(module, exports) {
    !function(e2, t2) {
        module.exports = t2();
    }("undefined" != typeof self ? self : commonjsGlobal, (function() {
        return function() {
            var e2 = {
                3976: function(e3, t3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.default = void 0;
                    t3.default = {
                        _maxTestPos: 500,
                        placeholder: "_",
                        optionalmarker: [ "[", "]" ],
                        quantifiermarker: [ "{", "}" ],
                        groupmarker: [ "(", ")" ],
                        alternatormarker: "|",
                        escapeChar: "\\",
                        mask: null,
                        regex: null,
                        oncomplete: function() {},
                        onincomplete: function() {},
                        oncleared: function() {},
                        repeat: 0,
                        greedy: false,
                        autoUnmask: false,
                        removeMaskOnSubmit: false,
                        clearMaskOnLostFocus: true,
                        insertMode: true,
                        insertModeVisual: true,
                        clearIncomplete: false,
                        alias: null,
                        onKeyDown: function() {},
                        onBeforeMask: null,
                        onBeforePaste: function(e4, t4) {
                            return "function" == typeof t4.onBeforeMask ? t4.onBeforeMask.call(this, e4, t4) : e4;
                        },
                        onBeforeWrite: null,
                        onUnMask: null,
                        showMaskOnFocus: true,
                        showMaskOnHover: true,
                        onKeyValidation: function() {},
                        skipOptionalPartCharacter: " ",
                        numericInput: false,
                        rightAlign: false,
                        undoOnEscape: true,
                        radixPoint: "",
                        _radixDance: false,
                        groupSeparator: "",
                        keepStatic: null,
                        positionCaretOnTab: true,
                        tabThrough: false,
                        supportsInputType: [ "text", "tel", "url", "password", "search" ],
                        isComplete: null,
                        preValidation: null,
                        postValidation: null,
                        staticDefinitionSymbol: void 0,
                        jitMasking: false,
                        nullable: true,
                        inputEventOnly: false,
                        noValuePatching: false,
                        positionCaretOnClick: "lvp",
                        casing: null,
                        inputmode: "text",
                        importDataAttributes: true,
                        shiftPositions: true,
                        usePrototypeDefinitions: true,
                        validationEventTimeOut: 3e3,
                        substitutes: {}
                    };
                },
                7392: function(e3, t3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.default = void 0;
                    t3.default = {
                        9: {
                            validator: "[0-9０-９]",
                            definitionSymbol: "*"
                        },
                        a: {
                            validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                            definitionSymbol: "*"
                        },
                        "*": {
                            validator: "[0-9０-９A-Za-zА-яЁёÀ-ÿµ]"
                        }
                    };
                },
                253: function(e3, t3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.default = function(e4, t4, n3) {
                        if (void 0 === n3) return e4.__data ? e4.__data[t4] : null;
                        e4.__data = e4.__data || {}, e4.__data[t4] = n3;
                    };
                },
                3776: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.Event = void 0, t3.off = function(e4, t4) {
                        var n4, i4;
                        u2(this[0]) && e4 && (n4 = this[0].eventRegistry, i4 = this[0], e4.split(" ").forEach((function(e5) {
                            var a3 = o2(e5.split("."), 2);
                            (function(e6, i5) {
                                var a4, r3, o3 = [];
                                if (e6.length > 0) if (void 0 === t4) for (a4 = 0, r3 = n4[e6][i5].length; a4 < r3; a4++) o3.push({
                                    ev: e6,
                                    namespace: i5 && i5.length > 0 ? i5 : "global",
                                    handler: n4[e6][i5][a4]
                                }); else o3.push({
                                    ev: e6,
                                    namespace: i5 && i5.length > 0 ? i5 : "global",
                                    handler: t4
                                }); else if (i5.length > 0) for (var l3 in n4) for (var s3 in n4[l3]) if (s3 === i5) if (void 0 === t4) for (a4 = 0, 
                                r3 = n4[l3][s3].length; a4 < r3; a4++) o3.push({
                                    ev: l3,
                                    namespace: s3,
                                    handler: n4[l3][s3][a4]
                                }); else o3.push({
                                    ev: l3,
                                    namespace: s3,
                                    handler: t4
                                });
                                return o3;
                            })(a3[0], a3[1]).forEach((function(e6) {
                                var t5 = e6.ev, a4 = e6.handler;
                                !function(e7, t6, a5) {
                                    if (e7 in n4 == 1) if (i4.removeEventListener ? i4.removeEventListener(e7, a5, false) : i4.detachEvent && i4.detachEvent("on".concat(e7), a5), 
                                    "global" === t6) for (var r3 in n4[e7]) n4[e7][r3].splice(n4[e7][r3].indexOf(a5), 1); else n4[e7][t6].splice(n4[e7][t6].indexOf(a5), 1);
                                }(t5, e6.namespace, a4);
                            }));
                        })));
                        return this;
                    }, t3.on = function(e4, t4) {
                        if (u2(this[0])) {
                            var n4 = this[0].eventRegistry, i4 = this[0];
                            e4.split(" ").forEach((function(e5) {
                                var a3 = o2(e5.split("."), 2), r3 = a3[0], l3 = a3[1];
                                !function(e6, a4) {
                                    i4.addEventListener ? i4.addEventListener(e6, t4, false) : i4.attachEvent && i4.attachEvent("on".concat(e6), t4), 
                                    n4[e6] = n4[e6] || {}, n4[e6][a4] = n4[e6][a4] || [], n4[e6][a4].push(t4);
                                }(r3, void 0 === l3 ? "global" : l3);
                            }));
                        }
                        return this;
                    }, t3.trigger = function(e4) {
                        var t4 = arguments;
                        if (u2(this[0])) for (var n4 = this[0].eventRegistry, i4 = this[0], o3 = "string" == typeof e4 ? e4.split(" ") : [ e4.type ], l3 = 0; l3 < o3.length; l3++) {
                            var s3 = o3[l3].split("."), f3 = s3[0], p2 = s3[1] || "global";
                            if (void 0 !== c2 && "global" === p2) {
                                var d2, h2 = {
                                    bubbles: true,
                                    cancelable: true,
                                    composed: true,
                                    detail: arguments[1]
                                };
                                if (c2.createEvent) {
                                    try {
                                        if ("input" === f3) h2.inputType = "insertText", d2 = new InputEvent(f3, h2); else d2 = new CustomEvent(f3, h2);
                                    } catch (e5) {
                                        (d2 = c2.createEvent("CustomEvent")).initCustomEvent(f3, h2.bubbles, h2.cancelable, h2.detail);
                                    }
                                    e4.type && (0, a2.default)(d2, e4), i4.dispatchEvent(d2);
                                } else (d2 = c2.createEventObject()).eventType = f3, d2.detail = arguments[1], e4.type && (0, 
                                a2.default)(d2, e4), i4.fireEvent("on" + d2.eventType, d2);
                            } else if (void 0 !== n4[f3]) {
                                arguments[0] = arguments[0].type ? arguments[0] : r2.default.Event(arguments[0]), 
                                arguments[0].detail = arguments.slice(1);
                                var v2 = n4[f3];
                                ("global" === p2 ? Object.values(v2).flat() : v2[p2]).forEach((function(e5) {
                                    return e5.apply(i4, t4);
                                }));
                            }
                        }
                        return this;
                    };
                    var i3 = s2(n3(9380)), a2 = s2(n3(600)), r2 = s2(n3(4963));
                    function o2(e4, t4) {
                        return function(e5) {
                            if (Array.isArray(e5)) return e5;
                        }(e4) || function(e5, t5) {
                            var n4 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
                            if (null != n4) {
                                var i4, a3, r3, o3, l3 = [], s3 = true, c3 = false;
                                try {
                                    if (r3 = (n4 = n4.call(e5)).next, 0 === t5) ; else for (;!(s3 = (i4 = r3.call(n4)).done) && (l3.push(i4.value), 
                                    l3.length !== t5); s3 = true) ;
                                } catch (e6) {
                                    c3 = true, a3 = e6;
                                } finally {
                                    try {
                                        if (!s3 && null != n4.return && (o3 = n4.return(), Object(o3) !== o3)) return;
                                    } finally {
                                        if (c3) throw a3;
                                    }
                                }
                                return l3;
                            }
                        }(e4, t4) || function(e5, t5) {
                            if (!e5) return;
                            if ("string" == typeof e5) return l2(e5, t5);
                            var n4 = Object.prototype.toString.call(e5).slice(8, -1);
                            "Object" === n4 && e5.constructor && (n4 = e5.constructor.name);
                            if ("Map" === n4 || "Set" === n4) return Array.from(e5);
                            if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4)) return l2(e5, t5);
                        }(e4, t4) || function() {
                            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }();
                    }
                    function l2(e4, t4) {
                        (null == t4 || t4 > e4.length) && (t4 = e4.length);
                        for (var n4 = 0, i4 = new Array(t4); n4 < t4; n4++) i4[n4] = e4[n4];
                        return i4;
                    }
                    function s2(e4) {
                        return e4 && e4.__esModule ? e4 : {
                            default: e4
                        };
                    }
                    var c2 = i3.default.document;
                    function u2(e4) {
                        return e4 instanceof Element;
                    }
                    var f2 = t3.Event = void 0;
                    "function" == typeof i3.default.CustomEvent ? t3.Event = f2 = i3.default.CustomEvent : i3.default.Event && c2 && c2.createEvent ? (t3.Event = f2 = function(e4, t4) {
                        t4 = t4 || {
                            bubbles: false,
                            cancelable: false,
                            composed: true,
                            detail: void 0
                        };
                        var n4 = c2.createEvent("CustomEvent");
                        return n4.initCustomEvent(e4, t4.bubbles, t4.cancelable, t4.detail), n4;
                    }, f2.prototype = i3.default.Event.prototype) : "undefined" != typeof Event && (t3.Event = f2 = Event);
                },
                600: function(e3, t3) {
                    function n3(e4) {
                        return n3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
                            return typeof e5;
                        } : function(e5) {
                            return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                        }, n3(e4);
                    }
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.default = function e4() {
                        var t4, i3, a2, r2, o2, l2, s2 = arguments[0] || {}, c2 = 1, u2 = arguments.length, f2 = false;
                        "boolean" == typeof s2 && (f2 = s2, s2 = arguments[c2] || {}, c2++);
                        "object" !== n3(s2) && "function" != typeof s2 && (s2 = {});
                        for (;c2 < u2; c2++) if (null != (t4 = arguments[c2])) for (i3 in t4) a2 = s2[i3], 
                        s2 !== (r2 = t4[i3]) && (f2 && r2 && ("[object Object]" === Object.prototype.toString.call(r2) || (o2 = Array.isArray(r2))) ? (o2 ? (o2 = false, 
                        l2 = a2 && Array.isArray(a2) ? a2 : []) : l2 = a2 && "[object Object]" === Object.prototype.toString.call(a2) ? a2 : {}, 
                        s2[i3] = e4(f2, l2, r2)) : void 0 !== r2 && (s2[i3] = r2));
                        return s2;
                    };
                },
                4963: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.default = void 0;
                    var i3 = l2(n3(9380)), a2 = l2(n3(253)), r2 = n3(3776), o2 = l2(n3(600));
                    function l2(e4) {
                        return e4 && e4.__esModule ? e4 : {
                            default: e4
                        };
                    }
                    var s2 = i3.default.document;
                    function c2(e4) {
                        return e4 instanceof c2 ? e4 : this instanceof c2 ? void (null != e4 && e4 !== i3.default && (this[0] = e4.nodeName ? e4 : void 0 !== e4[0] && e4[0].nodeName ? e4[0] : s2.querySelector(e4), 
                        void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new c2(e4);
                    }
                    c2.prototype = {
                        on: r2.on,
                        off: r2.off,
                        trigger: r2.trigger
                    }, c2.extend = o2.default, c2.data = a2.default, c2.Event = r2.Event;
                    t3.default = c2;
                },
                9845: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.mobile = t3.iphone = t3.ie = void 0;
                    var i3, a2 = (i3 = n3(9380)) && i3.__esModule ? i3 : {
                        default: i3
                    };
                    var r2 = a2.default.navigator && a2.default.navigator.userAgent || "";
                    t3.ie = r2.indexOf("MSIE ") > 0 || r2.indexOf("Trident/") > 0, t3.mobile = a2.default.navigator && a2.default.navigator.userAgentData && a2.default.navigator.userAgentData.mobile || a2.default.navigator && a2.default.navigator.maxTouchPoints || "ontouchstart" in a2.default, 
                    t3.iphone = /iphone/i.test(r2);
                },
                7184: function(e3, t3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.default = function(e4) {
                        return e4.replace(n3, "\\$1");
                    };
                    var n3 = new RegExp("(\\" + [ "/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^" ].join("|\\") + ")", "gim");
                },
                6030: function(e3, t3, n3) {
                    function i3(e4) {
                        return i3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
                            return typeof e5;
                        } : function(e5) {
                            return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                        }, i3(e4);
                    }
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.EventHandlers = void 0;
                    var a2, r2 = n3(9845), o2 = (a2 = n3(9380)) && a2.__esModule ? a2 : {
                        default: a2
                    }, l2 = n3(7760), s2 = n3(2839), c2 = n3(8711), u2 = n3(7215), f2 = n3(4713);
                    function p2() {
                        /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
                        p2 = function() {
                            return t4;
                        };
                        var e4, t4 = {}, n4 = Object.prototype, a3 = n4.hasOwnProperty, r3 = Object.defineProperty || function(e5, t5, n5) {
                            e5[t5] = n5.value;
                        }, o3 = "function" == typeof Symbol ? Symbol : {}, l3 = o3.iterator || "@@iterator", s3 = o3.asyncIterator || "@@asyncIterator", c3 = o3.toStringTag || "@@toStringTag";
                        function u3(e5, t5, n5) {
                            return Object.defineProperty(e5, t5, {
                                value: n5,
                                enumerable: true,
                                configurable: true,
                                writable: true
                            }), e5[t5];
                        }
                        try {
                            u3({}, "");
                        } catch (e5) {
                            u3 = function(e6, t5, n5) {
                                return e6[t5] = n5;
                            };
                        }
                        function f3(e5, t5, n5, i4) {
                            var a4 = t5 && t5.prototype instanceof k2 ? t5 : k2, o4 = Object.create(a4.prototype), l4 = new D2(i4 || []);
                            return r3(o4, "_invoke", {
                                value: E2(e5, n5, l4)
                            }), o4;
                        }
                        function d3(e5, t5, n5) {
                            try {
                                return {
                                    type: "normal",
                                    arg: e5.call(t5, n5)
                                };
                            } catch (e6) {
                                return {
                                    type: "throw",
                                    arg: e6
                                };
                            }
                        }
                        t4.wrap = f3;
                        var h3 = "suspendedStart", v3 = "suspendedYield", m3 = "executing", g3 = "completed", y3 = {};
                        function k2() {}
                        function b2() {}
                        function x2() {}
                        var w2 = {};
                        u3(w2, l3, (function() {
                            return this;
                        }));
                        var P2 = Object.getPrototypeOf, S2 = P2 && P2(P2(L2([])));
                        S2 && S2 !== n4 && a3.call(S2, l3) && (w2 = S2);
                        var O2 = x2.prototype = k2.prototype = Object.create(w2);
                        function _2(e5) {
                            [ "next", "throw", "return" ].forEach((function(t5) {
                                u3(e5, t5, (function(e6) {
                                    return this._invoke(t5, e6);
                                }));
                            }));
                        }
                        function M2(e5, t5) {
                            function n5(r4, o5, l4, s4) {
                                var c4 = d3(e5[r4], e5, o5);
                                if ("throw" !== c4.type) {
                                    var u4 = c4.arg, f4 = u4.value;
                                    return f4 && "object" == i3(f4) && a3.call(f4, "__await") ? t5.resolve(f4.__await).then((function(e6) {
                                        n5("next", e6, l4, s4);
                                    }), (function(e6) {
                                        n5("throw", e6, l4, s4);
                                    })) : t5.resolve(f4).then((function(e6) {
                                        u4.value = e6, l4(u4);
                                    }), (function(e6) {
                                        return n5("throw", e6, l4, s4);
                                    }));
                                }
                                s4(c4.arg);
                            }
                            var o4;
                            r3(this, "_invoke", {
                                value: function(e6, i4) {
                                    function a4() {
                                        return new t5((function(t6, a5) {
                                            n5(e6, i4, t6, a5);
                                        }));
                                    }
                                    return o4 = o4 ? o4.then(a4, a4) : a4();
                                }
                            });
                        }
                        function E2(t5, n5, i4) {
                            var a4 = h3;
                            return function(r4, o4) {
                                if (a4 === m3) throw new Error("Generator is already running");
                                if (a4 === g3) {
                                    if ("throw" === r4) throw o4;
                                    return {
                                        value: e4,
                                        done: true
                                    };
                                }
                                for (i4.method = r4, i4.arg = o4; ;) {
                                    var l4 = i4.delegate;
                                    if (l4) {
                                        var s4 = j2(l4, i4);
                                        if (s4) {
                                            if (s4 === y3) continue;
                                            return s4;
                                        }
                                    }
                                    if ("next" === i4.method) i4.sent = i4._sent = i4.arg; else if ("throw" === i4.method) {
                                        if (a4 === h3) throw a4 = g3, i4.arg;
                                        i4.dispatchException(i4.arg);
                                    } else "return" === i4.method && i4.abrupt("return", i4.arg);
                                    a4 = m3;
                                    var c4 = d3(t5, n5, i4);
                                    if ("normal" === c4.type) {
                                        if (a4 = i4.done ? g3 : v3, c4.arg === y3) continue;
                                        return {
                                            value: c4.arg,
                                            done: i4.done
                                        };
                                    }
                                    "throw" === c4.type && (a4 = g3, i4.method = "throw", i4.arg = c4.arg);
                                }
                            };
                        }
                        function j2(t5, n5) {
                            var i4 = n5.method, a4 = t5.iterator[i4];
                            if (a4 === e4) return n5.delegate = null, "throw" === i4 && t5.iterator.return && (n5.method = "return", 
                            n5.arg = e4, j2(t5, n5), "throw" === n5.method) || "return" !== i4 && (n5.method = "throw", 
                            n5.arg = new TypeError("The iterator does not provide a '" + i4 + "' method")), 
                            y3;
                            var r4 = d3(a4, t5.iterator, n5.arg);
                            if ("throw" === r4.type) return n5.method = "throw", n5.arg = r4.arg, n5.delegate = null, 
                            y3;
                            var o4 = r4.arg;
                            return o4 ? o4.done ? (n5[t5.resultName] = o4.value, n5.next = t5.nextLoc, "return" !== n5.method && (n5.method = "next", 
                            n5.arg = e4), n5.delegate = null, y3) : o4 : (n5.method = "throw", n5.arg = new TypeError("iterator result is not an object"), 
                            n5.delegate = null, y3);
                        }
                        function T2(e5) {
                            var t5 = {
                                tryLoc: e5[0]
                            };
                            1 in e5 && (t5.catchLoc = e5[1]), 2 in e5 && (t5.finallyLoc = e5[2], t5.afterLoc = e5[3]), 
                            this.tryEntries.push(t5);
                        }
                        function A2(e5) {
                            var t5 = e5.completion || {};
                            t5.type = "normal", delete t5.arg, e5.completion = t5;
                        }
                        function D2(e5) {
                            this.tryEntries = [ {
                                tryLoc: "root"
                            } ], e5.forEach(T2, this), this.reset(true);
                        }
                        function L2(t5) {
                            if (t5 || "" === t5) {
                                var n5 = t5[l3];
                                if (n5) return n5.call(t5);
                                if ("function" == typeof t5.next) return t5;
                                if (!isNaN(t5.length)) {
                                    var r4 = -1, o4 = function n6() {
                                        for (;++r4 < t5.length; ) if (a3.call(t5, r4)) return n6.value = t5[r4], n6.done = false, 
                                        n6;
                                        return n6.value = e4, n6.done = true, n6;
                                    };
                                    return o4.next = o4;
                                }
                            }
                            throw new TypeError(i3(t5) + " is not iterable");
                        }
                        return b2.prototype = x2, r3(O2, "constructor", {
                            value: x2,
                            configurable: true
                        }), r3(x2, "constructor", {
                            value: b2,
                            configurable: true
                        }), b2.displayName = u3(x2, c3, "GeneratorFunction"), t4.isGeneratorFunction = function(e5) {
                            var t5 = "function" == typeof e5 && e5.constructor;
                            return !!t5 && (t5 === b2 || "GeneratorFunction" === (t5.displayName || t5.name));
                        }, t4.mark = function(e5) {
                            return Object.setPrototypeOf ? Object.setPrototypeOf(e5, x2) : (e5.__proto__ = x2, 
                            u3(e5, c3, "GeneratorFunction")), e5.prototype = Object.create(O2), e5;
                        }, t4.awrap = function(e5) {
                            return {
                                __await: e5
                            };
                        }, _2(M2.prototype), u3(M2.prototype, s3, (function() {
                            return this;
                        })), t4.AsyncIterator = M2, t4.async = function(e5, n5, i4, a4, r4) {
                            void 0 === r4 && (r4 = Promise);
                            var o4 = new M2(f3(e5, n5, i4, a4), r4);
                            return t4.isGeneratorFunction(n5) ? o4 : o4.next().then((function(e6) {
                                return e6.done ? e6.value : o4.next();
                            }));
                        }, _2(O2), u3(O2, c3, "Generator"), u3(O2, l3, (function() {
                            return this;
                        })), u3(O2, "toString", (function() {
                            return "[object Generator]";
                        })), t4.keys = function(e5) {
                            var t5 = Object(e5), n5 = [];
                            for (var i4 in t5) n5.push(i4);
                            return n5.reverse(), function e6() {
                                for (;n5.length; ) {
                                    var i5 = n5.pop();
                                    if (i5 in t5) return e6.value = i5, e6.done = false, e6;
                                }
                                return e6.done = true, e6;
                            };
                        }, t4.values = L2, D2.prototype = {
                            constructor: D2,
                            reset: function(t5) {
                                if (this.prev = 0, this.next = 0, this.sent = this._sent = e4, this.done = false, 
                                this.delegate = null, this.method = "next", this.arg = e4, this.tryEntries.forEach(A2), 
                                !t5) for (var n5 in this) "t" === n5.charAt(0) && a3.call(this, n5) && !isNaN(+n5.slice(1)) && (this[n5] = e4);
                            },
                            stop: function() {
                                this.done = true;
                                var e5 = this.tryEntries[0].completion;
                                if ("throw" === e5.type) throw e5.arg;
                                return this.rval;
                            },
                            dispatchException: function(t5) {
                                if (this.done) throw t5;
                                var n5 = this;
                                function i4(i5, a4) {
                                    return l4.type = "throw", l4.arg = t5, n5.next = i5, a4 && (n5.method = "next", 
                                    n5.arg = e4), !!a4;
                                }
                                for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                                    var o4 = this.tryEntries[r4], l4 = o4.completion;
                                    if ("root" === o4.tryLoc) return i4("end");
                                    if (o4.tryLoc <= this.prev) {
                                        var s4 = a3.call(o4, "catchLoc"), c4 = a3.call(o4, "finallyLoc");
                                        if (s4 && c4) {
                                            if (this.prev < o4.catchLoc) return i4(o4.catchLoc, true);
                                            if (this.prev < o4.finallyLoc) return i4(o4.finallyLoc);
                                        } else if (s4) {
                                            if (this.prev < o4.catchLoc) return i4(o4.catchLoc, true);
                                        } else {
                                            if (!c4) throw new Error("try statement without catch or finally");
                                            if (this.prev < o4.finallyLoc) return i4(o4.finallyLoc);
                                        }
                                    }
                                }
                            },
                            abrupt: function(e5, t5) {
                                for (var n5 = this.tryEntries.length - 1; n5 >= 0; --n5) {
                                    var i4 = this.tryEntries[n5];
                                    if (i4.tryLoc <= this.prev && a3.call(i4, "finallyLoc") && this.prev < i4.finallyLoc) {
                                        var r4 = i4;
                                        break;
                                    }
                                }
                                r4 && ("break" === e5 || "continue" === e5) && r4.tryLoc <= t5 && t5 <= r4.finallyLoc && (r4 = null);
                                var o4 = r4 ? r4.completion : {};
                                return o4.type = e5, o4.arg = t5, r4 ? (this.method = "next", this.next = r4.finallyLoc, 
                                y3) : this.complete(o4);
                            },
                            complete: function(e5, t5) {
                                if ("throw" === e5.type) throw e5.arg;
                                return "break" === e5.type || "continue" === e5.type ? this.next = e5.arg : "return" === e5.type ? (this.rval = this.arg = e5.arg, 
                                this.method = "return", this.next = "end") : "normal" === e5.type && t5 && (this.next = t5), 
                                y3;
                            },
                            finish: function(e5) {
                                for (var t5 = this.tryEntries.length - 1; t5 >= 0; --t5) {
                                    var n5 = this.tryEntries[t5];
                                    if (n5.finallyLoc === e5) return this.complete(n5.completion, n5.afterLoc), A2(n5), 
                                    y3;
                                }
                            },
                            catch: function(e5) {
                                for (var t5 = this.tryEntries.length - 1; t5 >= 0; --t5) {
                                    var n5 = this.tryEntries[t5];
                                    if (n5.tryLoc === e5) {
                                        var i4 = n5.completion;
                                        if ("throw" === i4.type) {
                                            var a4 = i4.arg;
                                            A2(n5);
                                        }
                                        return a4;
                                    }
                                }
                                throw new Error("illegal catch attempt");
                            },
                            delegateYield: function(t5, n5, i4) {
                                return this.delegate = {
                                    iterator: L2(t5),
                                    resultName: n5,
                                    nextLoc: i4
                                }, "next" === this.method && (this.arg = e4), y3;
                            }
                        }, t4;
                    }
                    function d2(e4, t4) {
                        var n4 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
                        if (!n4) {
                            if (Array.isArray(e4) || (n4 = function(e5, t5) {
                                if (!e5) return;
                                if ("string" == typeof e5) return h2(e5, t5);
                                var n5 = Object.prototype.toString.call(e5).slice(8, -1);
                                "Object" === n5 && e5.constructor && (n5 = e5.constructor.name);
                                if ("Map" === n5 || "Set" === n5) return Array.from(e5);
                                if ("Arguments" === n5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n5)) return h2(e5, t5);
                            }(e4)) || t4) {
                                n4 && (e4 = n4);
                                var i4 = 0, a3 = function() {};
                                return {
                                    s: a3,
                                    n: function() {
                                        return i4 >= e4.length ? {
                                            done: true
                                        } : {
                                            done: false,
                                            value: e4[i4++]
                                        };
                                    },
                                    e: function(e5) {
                                        throw e5;
                                    },
                                    f: a3
                                };
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }
                        var r3, o3 = true, l3 = false;
                        return {
                            s: function() {
                                n4 = n4.call(e4);
                            },
                            n: function() {
                                var e5 = n4.next();
                                return o3 = e5.done, e5;
                            },
                            e: function(e5) {
                                l3 = true, r3 = e5;
                            },
                            f: function() {
                                try {
                                    o3 || null == n4.return || n4.return();
                                } finally {
                                    if (l3) throw r3;
                                }
                            }
                        };
                    }
                    function h2(e4, t4) {
                        (null == t4 || t4 > e4.length) && (t4 = e4.length);
                        for (var n4 = 0, i4 = new Array(t4); n4 < t4; n4++) i4[n4] = e4[n4];
                        return i4;
                    }
                    function v2(e4, t4, n4, i4, a3, r3, o3) {
                        try {
                            var l3 = e4[r3](o3), s3 = l3.value;
                        } catch (e5) {
                            return void n4(e5);
                        }
                        l3.done ? t4(s3) : Promise.resolve(s3).then(i4, a3);
                    }
                    var m2, g2, y2 = t3.EventHandlers = {
                        keyEvent: function(e4, t4, n4, i4, a3) {
                            var o3 = this.inputmask, p3 = o3.opts, d3 = o3.dependencyLib, h3 = o3.maskset, v3 = this, m3 = d3(v3), g3 = e4.key, k2 = c2.caret.call(o3, v3), b2 = p3.onKeyDown.call(this, e4, c2.getBuffer.call(o3), k2, p3);
                            if (void 0 !== b2) return b2;
                            if (g3 === s2.keys.Backspace || g3 === s2.keys.Delete || r2.iphone && g3 === s2.keys.BACKSPACE_SAFARI || e4.ctrlKey && g3 === s2.keys.x && !("oncut" in v3)) e4.preventDefault(), 
                            u2.handleRemove.call(o3, v3, g3, k2), (0, l2.writeBuffer)(v3, c2.getBuffer.call(o3, true), h3.p, e4, v3.inputmask._valueGet() !== c2.getBuffer.call(o3).join("")); else if (g3 === s2.keys.End || g3 === s2.keys.PageDown) {
                                e4.preventDefault();
                                var x2 = c2.seekNext.call(o3, c2.getLastValidPosition.call(o3));
                                c2.caret.call(o3, v3, e4.shiftKey ? k2.begin : x2, x2, true);
                            } else g3 === s2.keys.Home && !e4.shiftKey || g3 === s2.keys.PageUp ? (e4.preventDefault(), 
                            c2.caret.call(o3, v3, 0, e4.shiftKey ? k2.begin : 0, true)) : p3.undoOnEscape && g3 === s2.keys.Escape && true !== e4.altKey ? ((0, 
                            l2.checkVal)(v3, true, false, o3.undoValue.split("")), m3.trigger("click")) : g3 !== s2.keys.Insert || e4.shiftKey || e4.ctrlKey || void 0 !== o3.userOptions.insertMode ? true === p3.tabThrough && g3 === s2.keys.Tab ? true === e4.shiftKey ? (k2.end = c2.seekPrevious.call(o3, k2.end, true), 
                            true === f2.getTest.call(o3, k2.end - 1).match.static && k2.end--, k2.begin = c2.seekPrevious.call(o3, k2.end, true), 
                            k2.begin >= 0 && k2.end > 0 && (e4.preventDefault(), c2.caret.call(o3, v3, k2.begin, k2.end))) : (k2.begin = c2.seekNext.call(o3, k2.begin, true), 
                            k2.end = c2.seekNext.call(o3, k2.begin, true), k2.end < h3.maskLength && k2.end--, 
                            k2.begin <= h3.maskLength && (e4.preventDefault(), c2.caret.call(o3, v3, k2.begin, k2.end))) : e4.shiftKey || (p3.insertModeVisual && false === p3.insertMode ? g3 === s2.keys.ArrowRight ? setTimeout((function() {
                                var e5 = c2.caret.call(o3, v3);
                                c2.caret.call(o3, v3, e5.begin);
                            }), 0) : g3 === s2.keys.ArrowLeft && setTimeout((function() {
                                var e5 = c2.translatePosition.call(o3, v3.inputmask.caretPos.begin);
                                c2.translatePosition.call(o3, v3.inputmask.caretPos.end);
                                o3.isRTL ? c2.caret.call(o3, v3, e5 + (e5 === h3.maskLength ? 0 : 1)) : c2.caret.call(o3, v3, e5 - (0 === e5 ? 0 : 1));
                            }), 0) : void 0 === o3.keyEventHook || o3.keyEventHook(e4)) : u2.isSelection.call(o3, k2) ? p3.insertMode = !p3.insertMode : (p3.insertMode = !p3.insertMode, 
                            c2.caret.call(o3, v3, k2.begin, k2.begin));
                            return o3.isComposing = g3 == s2.keys.Process || g3 == s2.keys.Unidentified, o3.ignorable = g3.length > 1 && !("textarea" === v3.tagName.toLowerCase() && g3 == s2.keys.Enter), 
                            y2.keypressEvent.call(this, e4, t4, n4, i4, a3);
                        },
                        keypressEvent: function(e4, t4, n4, i4, a3) {
                            var r3 = this.inputmask || this, o3 = r3.opts, f3 = r3.dependencyLib, p3 = r3.maskset, d3 = r3.el, h3 = f3(d3), v3 = e4.key;
                            if (true === t4 || e4.ctrlKey && e4.altKey && !r3.ignorable || !(e4.ctrlKey || e4.metaKey || r3.ignorable)) {
                                if (v3) {
                                    var m3, g3 = t4 ? {
                                        begin: a3,
                                        end: a3
                                    } : c2.caret.call(r3, d3);
                                    t4 || (v3 = o3.substitutes[v3] || v3), p3.writeOutBuffer = true;
                                    var y3 = u2.isValid.call(r3, g3, v3, i4, void 0, void 0, void 0, t4);
                                    if (false !== y3 && (c2.resetMaskSet.call(r3, true), m3 = void 0 !== y3.caret ? y3.caret : c2.seekNext.call(r3, y3.pos.begin ? y3.pos.begin : y3.pos), 
                                    p3.p = m3), m3 = o3.numericInput && void 0 === y3.caret ? c2.seekPrevious.call(r3, m3) : m3, 
                                    false !== n4 && (setTimeout((function() {
                                        o3.onKeyValidation.call(d3, v3, y3);
                                    }), 0), p3.writeOutBuffer && false !== y3)) {
                                        var k2 = c2.getBuffer.call(r3);
                                        (0, l2.writeBuffer)(d3, k2, m3, e4, true !== t4);
                                    }
                                    if (e4.preventDefault(), t4) return false !== y3 && (y3.forwardPosition = m3), y3;
                                }
                            } else v3 === s2.keys.Enter && r3.undoValue !== r3._valueGet(true) && (r3.undoValue = r3._valueGet(true), 
                            setTimeout((function() {
                                h3.trigger("change");
                            }), 0));
                        },
                        pasteEvent: (m2 = p2().mark((function e4(t4) {
                            var n4, i4, a3, r3, s3, u3;
                            return p2().wrap((function(e5) {
                                for (;;) switch (e5.prev = e5.next) {
                                  case 0:
                                    n4 = function(e6, n5, i5, a4, o3) {
                                        var s4 = c2.caret.call(e6, n5, void 0, void 0, true), u4 = i5.substr(0, s4.begin), f3 = i5.substr(s4.end, i5.length);
                                        if (u4 == (e6.isRTL ? c2.getBufferTemplate.call(e6).slice().reverse() : c2.getBufferTemplate.call(e6)).slice(0, s4.begin).join("") && (u4 = ""), 
                                        f3 == (e6.isRTL ? c2.getBufferTemplate.call(e6).slice().reverse() : c2.getBufferTemplate.call(e6)).slice(s4.end).join("") && (f3 = ""), 
                                        a4 = u4 + a4 + f3, e6.isRTL && true !== r3.numericInput) {
                                            a4 = a4.split("");
                                            var p3, h3 = d2(c2.getBufferTemplate.call(e6));
                                            try {
                                                for (h3.s(); !(p3 = h3.n()).done; ) {
                                                    var v3 = p3.value;
                                                    a4[0] === v3 && a4.shift();
                                                }
                                            } catch (e7) {
                                                h3.e(e7);
                                            } finally {
                                                h3.f();
                                            }
                                            a4 = a4.reverse().join("");
                                        }
                                        var m3 = a4;
                                        if ("function" == typeof o3) {
                                            if (false === (m3 = o3.call(e6, m3, r3))) return false;
                                            m3 || (m3 = i5);
                                        }
                                        (0, l2.checkVal)(n5, true, false, m3.toString().split(""), t4);
                                    }, i4 = this, a3 = this.inputmask, r3 = a3.opts, s3 = a3._valueGet(true), a3.skipInputEvent = true, 
                                    t4.clipboardData && t4.clipboardData.getData ? u3 = t4.clipboardData.getData("text/plain") : o2.default.clipboardData && o2.default.clipboardData.getData && (u3 = o2.default.clipboardData.getData("Text")), 
                                    n4(a3, i4, s3, u3, r3.onBeforePaste), t4.preventDefault();

                                  case 7:
                                  case "end":
                                    return e5.stop();
                                }
                            }), e4, this);
                        })), g2 = function() {
                            var e4 = this, t4 = arguments;
                            return new Promise((function(n4, i4) {
                                var a3 = m2.apply(e4, t4);
                                function r3(e5) {
                                    v2(a3, n4, i4, r3, o3, "next", e5);
                                }
                                function o3(e5) {
                                    v2(a3, n4, i4, r3, o3, "throw", e5);
                                }
                                r3(void 0);
                            }));
                        }, function(e4) {
                            return g2.apply(this, arguments);
                        }),
                        inputFallBackEvent: function(e4) {
                            var t4 = this.inputmask, n4 = t4.opts, i4 = t4.dependencyLib;
                            var a3, o3 = this, u3 = o3.inputmask._valueGet(true), p3 = (t4.isRTL ? c2.getBuffer.call(t4).slice().reverse() : c2.getBuffer.call(t4)).join(""), d3 = c2.caret.call(t4, o3, void 0, void 0, true);
                            if (p3 !== u3) {
                                if (a3 = function(e5, i5, a4) {
                                    for (var r3, o4, l3, s3 = e5.substr(0, a4.begin).split(""), u4 = e5.substr(a4.begin).split(""), p4 = i5.substr(0, a4.begin).split(""), d4 = i5.substr(a4.begin).split(""), h4 = s3.length >= p4.length ? s3.length : p4.length, v3 = u4.length >= d4.length ? u4.length : d4.length, m3 = "", g3 = [], y3 = "~"; s3.length < h4; ) s3.push(y3);
                                    for (;p4.length < h4; ) p4.push(y3);
                                    for (;u4.length < v3; ) u4.unshift(y3);
                                    for (;d4.length < v3; ) d4.unshift(y3);
                                    var k2 = s3.concat(u4), b2 = p4.concat(d4);
                                    for (o4 = 0, r3 = k2.length; o4 < r3; o4++) switch (l3 = f2.getPlaceholder.call(t4, c2.translatePosition.call(t4, o4)), 
                                    m3) {
                                      case "insertText":
                                        b2[o4 - 1] === k2[o4] && a4.begin == k2.length - 1 && g3.push(k2[o4]), o4 = r3;
                                        break;

                                      case "insertReplacementText":
                                      case "deleteContentBackward":
                                        k2[o4] === y3 ? a4.end++ : o4 = r3;
                                        break;

                                      default:
                                        k2[o4] !== b2[o4] && (k2[o4 + 1] !== y3 && k2[o4 + 1] !== l3 && void 0 !== k2[o4 + 1] || (b2[o4] !== l3 || b2[o4 + 1] !== y3) && b2[o4] !== y3 ? b2[o4 + 1] === y3 && b2[o4] === k2[o4 + 1] ? (m3 = "insertText", 
                                        g3.push(k2[o4]), a4.begin--, a4.end--) : k2[o4] !== l3 && k2[o4] !== y3 && (k2[o4 + 1] === y3 || b2[o4] !== k2[o4] && b2[o4 + 1] === k2[o4 + 1]) ? (m3 = "insertReplacementText", 
                                        g3.push(k2[o4]), a4.begin--) : k2[o4] === y3 ? (m3 = "deleteContentBackward", (c2.isMask.call(t4, c2.translatePosition.call(t4, o4), true) || b2[o4] === n4.radixPoint) && a4.end++) : o4 = r3 : (m3 = "insertText", 
                                        g3.push(k2[o4]), a4.begin--, a4.end--));
                                    }
                                    return {
                                        action: m3,
                                        data: g3,
                                        caret: a4
                                    };
                                }(u3, p3, d3), (o3.inputmask.shadowRoot || o3.ownerDocument).activeElement !== o3 && o3.focus(), 
                                (0, l2.writeBuffer)(o3, c2.getBuffer.call(t4)), c2.caret.call(t4, o3, d3.begin, d3.end, true), 
                                !r2.mobile && t4.skipNextInsert && "insertText" === e4.inputType && "insertText" === a3.action && t4.isComposing) return false;
                                switch ("insertCompositionText" === e4.inputType && "insertText" === a3.action && t4.isComposing ? t4.skipNextInsert = true : t4.skipNextInsert = false, 
                                a3.action) {
                                  case "insertText":
                                  case "insertReplacementText":
                                    a3.data.forEach((function(e5, n5) {
                                        var a4 = new i4.Event("keypress");
                                        a4.key = e5, t4.ignorable = false, y2.keypressEvent.call(o3, a4);
                                    })), setTimeout((function() {
                                        t4.$el.trigger("keyup");
                                    }), 0);
                                    break;

                                  case "deleteContentBackward":
                                    var h3 = new i4.Event("keydown");
                                    h3.key = s2.keys.Backspace, y2.keyEvent.call(o3, h3);
                                    break;

                                  default:
                                    (0, l2.applyInputValue)(o3, u3), c2.caret.call(t4, o3, d3.begin, d3.end, true);
                                }
                                e4.preventDefault();
                            }
                        },
                        setValueEvent: function(e4) {
                            var t4 = this.inputmask, n4 = t4.dependencyLib, i4 = this, a3 = e4 && e4.detail ? e4.detail[0] : arguments[1];
                            void 0 === a3 && (a3 = i4.inputmask._valueGet(true)), (0, l2.applyInputValue)(i4, a3, new n4.Event("input")), 
                            (e4.detail && void 0 !== e4.detail[1] || void 0 !== arguments[2]) && c2.caret.call(t4, i4, e4.detail ? e4.detail[1] : arguments[2]);
                        },
                        focusEvent: function(e4) {
                            var t4 = this.inputmask, n4 = t4.opts, i4 = t4 && t4._valueGet();
                            n4.showMaskOnFocus && i4 !== c2.getBuffer.call(t4).join("") && (0, l2.writeBuffer)(this, c2.getBuffer.call(t4), c2.seekNext.call(t4, c2.getLastValidPosition.call(t4))), 
                            true !== n4.positionCaretOnTab || false !== t4.mouseEnter || u2.isComplete.call(t4, c2.getBuffer.call(t4)) && -1 !== c2.getLastValidPosition.call(t4) || y2.clickEvent.apply(this, [ e4, true ]), 
                            t4.undoValue = t4 && t4._valueGet(true);
                        },
                        invalidEvent: function(e4) {
                            this.inputmask.validationEvent = true;
                        },
                        mouseleaveEvent: function() {
                            var e4 = this.inputmask, t4 = e4.opts, n4 = this;
                            e4.mouseEnter = false, t4.clearMaskOnLostFocus && (n4.inputmask.shadowRoot || n4.ownerDocument).activeElement !== n4 && (0, 
                            l2.HandleNativePlaceholder)(n4, e4.originalPlaceholder);
                        },
                        clickEvent: function(e4, t4) {
                            var n4 = this.inputmask;
                            n4.clicked++;
                            var i4 = this;
                            if ((i4.inputmask.shadowRoot || i4.ownerDocument).activeElement === i4) {
                                var a3 = c2.determineNewCaretPosition.call(n4, c2.caret.call(n4, i4), t4);
                                void 0 !== a3 && c2.caret.call(n4, i4, a3);
                            }
                        },
                        cutEvent: function(e4) {
                            var t4 = this.inputmask, n4 = t4.maskset, i4 = this, a3 = c2.caret.call(t4, i4), r3 = t4.isRTL ? c2.getBuffer.call(t4).slice(a3.end, a3.begin) : c2.getBuffer.call(t4).slice(a3.begin, a3.end), f3 = t4.isRTL ? r3.reverse().join("") : r3.join("");
                            o2.default.navigator && o2.default.navigator.clipboard ? o2.default.navigator.clipboard.writeText(f3) : o2.default.clipboardData && o2.default.clipboardData.getData && o2.default.clipboardData.setData("Text", f3), 
                            u2.handleRemove.call(t4, i4, s2.keys.Delete, a3), (0, l2.writeBuffer)(i4, c2.getBuffer.call(t4), n4.p, e4, t4.undoValue !== t4._valueGet(true));
                        },
                        blurEvent: function(e4) {
                            var t4 = this.inputmask, n4 = t4.opts, i4 = t4.dependencyLib;
                            t4.clicked = 0;
                            var a3 = i4(this), r3 = this;
                            if (r3.inputmask) {
                                (0, l2.HandleNativePlaceholder)(r3, t4.originalPlaceholder);
                                var o3 = r3.inputmask._valueGet(), s3 = c2.getBuffer.call(t4).slice();
                                "" !== o3 && (n4.clearMaskOnLostFocus && (-1 === c2.getLastValidPosition.call(t4) && o3 === c2.getBufferTemplate.call(t4).join("") ? s3 = [] : l2.clearOptionalTail.call(t4, s3)), 
                                false === u2.isComplete.call(t4, s3) && (setTimeout((function() {
                                    a3.trigger("incomplete");
                                }), 0), n4.clearIncomplete && (c2.resetMaskSet.call(t4, false), s3 = n4.clearMaskOnLostFocus ? [] : c2.getBufferTemplate.call(t4).slice())), 
                                (0, l2.writeBuffer)(r3, s3, void 0, e4)), o3 = t4._valueGet(true), t4.undoValue !== o3 && ("" != o3 || t4.undoValue != c2.getBufferTemplate.call(t4).join("") || t4.undoValue == c2.getBufferTemplate.call(t4).join("") && t4.maskset.validPositions.length > 0) && (t4.undoValue = o3, 
                                a3.trigger("change"));
                            }
                        },
                        mouseenterEvent: function() {
                            var e4 = this.inputmask, t4 = e4.opts.showMaskOnHover, n4 = this;
                            if (e4.mouseEnter = true, (n4.inputmask.shadowRoot || n4.ownerDocument).activeElement !== n4) {
                                var i4 = (e4.isRTL ? c2.getBufferTemplate.call(e4).slice().reverse() : c2.getBufferTemplate.call(e4)).join("");
                                t4 && (0, l2.HandleNativePlaceholder)(n4, i4);
                            }
                        },
                        submitEvent: function() {
                            var e4 = this.inputmask, t4 = e4.opts;
                            e4.undoValue !== e4._valueGet(true) && e4.$el.trigger("change"), -1 === c2.getLastValidPosition.call(e4) && e4._valueGet && e4._valueGet() === c2.getBufferTemplate.call(e4).join("") && e4._valueSet(""), 
                            t4.clearIncomplete && false === u2.isComplete.call(e4, c2.getBuffer.call(e4)) && e4._valueSet(""), 
                            t4.removeMaskOnSubmit && (e4._valueSet(e4.unmaskedvalue(), true), setTimeout((function() {
                                (0, l2.writeBuffer)(e4.el, c2.getBuffer.call(e4));
                            }), 0));
                        },
                        resetEvent: function() {
                            var e4 = this.inputmask;
                            e4.refreshValue = true, setTimeout((function() {
                                (0, l2.applyInputValue)(e4.el, e4._valueGet(true));
                            }), 0);
                        }
                    };
                },
                9716: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.EventRuler = void 0;
                    var i3, a2 = n3(7760), r2 = (i3 = n3(2394)) && i3.__esModule ? i3 : {
                        default: i3
                    }, o2 = n3(2839), l2 = n3(8711);
                    t3.EventRuler = {
                        on: function(e4, t4, n4) {
                            var i4 = e4.inputmask.dependencyLib, s2 = function(t5) {
                                t5.originalEvent && (t5 = t5.originalEvent || t5, arguments[0] = t5);
                                var s3, c2 = this, u2 = c2.inputmask, f2 = u2 ? u2.opts : void 0;
                                if (void 0 === u2 && "FORM" !== this.nodeName) {
                                    var p2 = i4.data(c2, "_inputmask_opts");
                                    i4(c2).off(), p2 && new r2.default(p2).mask(c2);
                                } else {
                                    if ([ "submit", "reset", "setvalue" ].includes(t5.type) || "FORM" === this.nodeName || !(c2.disabled || c2.readOnly && !("keydown" === t5.type && t5.ctrlKey && t5.key === o2.keys.c || false === f2.tabThrough && t5.key === o2.keys.Tab))) {
                                        switch (t5.type) {
                                          case "input":
                                            if (true === u2.skipInputEvent) return u2.skipInputEvent = false, t5.preventDefault();
                                            break;

                                          case "click":
                                          case "focus":
                                            return u2.validationEvent ? (u2.validationEvent = false, e4.blur(), (0, a2.HandleNativePlaceholder)(e4, (u2.isRTL ? l2.getBufferTemplate.call(u2).slice().reverse() : l2.getBufferTemplate.call(u2)).join("")), 
                                            setTimeout((function() {
                                                e4.focus();
                                            }), f2.validationEventTimeOut), false) : (s3 = arguments, void setTimeout((function() {
                                                e4.inputmask && n4.apply(c2, s3);
                                            }), 0));
                                        }
                                        var d2 = n4.apply(c2, arguments);
                                        return false === d2 && (t5.preventDefault(), t5.stopPropagation()), d2;
                                    }
                                    t5.preventDefault();
                                }
                            };
                            [ "submit", "reset" ].includes(t4) ? (s2 = s2.bind(e4), null !== e4.form && i4(e4.form).on(t4, s2)) : i4(e4).on(t4, s2), 
                            e4.inputmask.events[t4] = e4.inputmask.events[t4] || [], e4.inputmask.events[t4].push(s2);
                        },
                        off: function(e4, t4) {
                            if (e4.inputmask && e4.inputmask.events) {
                                var n4 = e4.inputmask.dependencyLib, i4 = e4.inputmask.events;
                                for (var a3 in t4 && ((i4 = [])[t4] = e4.inputmask.events[t4]), i4) {
                                    for (var r3 = i4[a3]; r3.length > 0; ) {
                                        var o3 = r3.pop();
                                        [ "submit", "reset" ].includes(a3) ? null !== e4.form && n4(e4.form).off(a3, o3) : n4(e4).off(a3, o3);
                                    }
                                    delete e4.inputmask.events[a3];
                                }
                            }
                        }
                    };
                },
                219: function(e3, t3, n3) {
                    var i3 = p2(n3(7184)), a2 = p2(n3(2394)), r2 = n3(2839), o2 = n3(8711), l2 = n3(4713);
                    function s2(e4, t4) {
                        return function(e5) {
                            if (Array.isArray(e5)) return e5;
                        }(e4) || function(e5, t5) {
                            var n4 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
                            if (null != n4) {
                                var i4, a3, r3, o3, l3 = [], s3 = true, c3 = false;
                                try {
                                    if (r3 = (n4 = n4.call(e5)).next, 0 === t5) ; else for (;!(s3 = (i4 = r3.call(n4)).done) && (l3.push(i4.value), 
                                    l3.length !== t5); s3 = true) ;
                                } catch (e6) {
                                    c3 = true, a3 = e6;
                                } finally {
                                    try {
                                        if (!s3 && null != n4.return && (o3 = n4.return(), Object(o3) !== o3)) return;
                                    } finally {
                                        if (c3) throw a3;
                                    }
                                }
                                return l3;
                            }
                        }(e4, t4) || function(e5, t5) {
                            if (!e5) return;
                            if ("string" == typeof e5) return c2(e5, t5);
                            var n4 = Object.prototype.toString.call(e5).slice(8, -1);
                            "Object" === n4 && e5.constructor && (n4 = e5.constructor.name);
                            if ("Map" === n4 || "Set" === n4) return Array.from(e5);
                            if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4)) return c2(e5, t5);
                        }(e4, t4) || function() {
                            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }();
                    }
                    function c2(e4, t4) {
                        (null == t4 || t4 > e4.length) && (t4 = e4.length);
                        for (var n4 = 0, i4 = new Array(t4); n4 < t4; n4++) i4[n4] = e4[n4];
                        return i4;
                    }
                    function u2(e4) {
                        return u2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
                            return typeof e5;
                        } : function(e5) {
                            return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                        }, u2(e4);
                    }
                    function f2(e4, t4) {
                        for (var n4 = 0; n4 < t4.length; n4++) {
                            var i4 = t4[n4];
                            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), 
                            Object.defineProperty(e4, (a3 = i4.key, r3 = void 0, r3 = function(e5, t5) {
                                if ("object" !== u2(e5) || null === e5) return e5;
                                var n5 = e5[Symbol.toPrimitive];
                                if (void 0 !== n5) {
                                    var i5 = n5.call(e5, t5 || "default");
                                    if ("object" !== u2(i5)) return i5;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return ("string" === t5 ? String : Number)(e5);
                            }(a3, "string"), "symbol" === u2(r3) ? r3 : String(r3)), i4);
                        }
                        var a3, r3;
                    }
                    function p2(e4) {
                        return e4 && e4.__esModule ? e4 : {
                            default: e4
                        };
                    }
                    n3(1313);
                    var d2 = a2.default.dependencyLib, h2 = function() {
                        function e4(t5, n5, i4, a3) {
                            !function(e5, t6) {
                                if (!(e5 instanceof t6)) throw new TypeError("Cannot call a class as a function");
                            }(this, e4), this.mask = t5, this.format = n5, this.opts = i4, this.inputmask = a3, 
                            this._date = new Date(1, 0, 1), this.initDateObject(t5, this.opts, this.inputmask);
                        }
                        var t4, n4;
                        return t4 = e4, (n4 = [ {
                            key: "date",
                            get: function() {
                                return void 0 === this._date && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts, this.inputmask)), 
                                this._date;
                            }
                        }, {
                            key: "initDateObject",
                            value: function(e5, t5, n5) {
                                var i4;
                                for (P2(t5).lastIndex = 0; i4 = P2(t5).exec(this.format); ) {
                                    var a3 = /\d+$/.exec(i4[0]), r3 = a3 ? i4[0][0] + "x" : i4[0], o3 = void 0;
                                    if (void 0 !== e5) {
                                        if (a3) {
                                            var s3 = P2(t5).lastIndex, c3 = j2.call(n5, i4.index, t5, n5 && n5.maskset);
                                            P2(t5).lastIndex = s3, o3 = e5.slice(0, e5.indexOf(c3.nextMatch[0]));
                                        } else {
                                            for (var u3 = i4[0][0], f3 = i4.index; n5 && (t5.placeholder[l2.getTest.call(n5, f3).match.placeholder] || l2.getTest.call(n5, f3).match.placeholder) === u3; ) f3++;
                                            var p3 = f3 - i4.index;
                                            o3 = e5.slice(0, p3 || y2[r3] && y2[r3][4] || r3.length);
                                        }
                                        e5 = e5.slice(o3.length);
                                    }
                                    Object.prototype.hasOwnProperty.call(y2, r3) && this.setValue(this, o3, r3, y2[r3][2], y2[r3][1]);
                                }
                            }
                        }, {
                            key: "setValue",
                            value: function(e5, t5, n5, i4, a3) {
                                if (void 0 !== t5) switch (i4) {
                                  case "ampm":
                                    e5[i4] = t5, e5["raw" + i4] = t5.replace(/\s/g, "_");
                                    break;

                                  case "month":
                                    if ("mmm" === n5 || "mmmm" === n5) {
                                        e5[i4] = _2("mmm" === n5 ? m2.monthNames.slice(0, 12).findIndex((function(e6) {
                                            return t5.toLowerCase() === e6.toLowerCase();
                                        })) + 1 : m2.monthNames.slice(12, 24).findIndex((function(e6) {
                                            return t5.toLowerCase() === e6.toLowerCase();
                                        })) + 1, 2), e5[i4] = "00" === e5[i4] ? "" : e5[i4].toString(), e5["raw" + i4] = e5[i4];
                                        break;
                                    }

                                  default:
                                    e5[i4] = t5.replace(/[^0-9]/g, "0"), e5["raw" + i4] = t5.replace(/\s/g, "_");
                                }
                                if (void 0 !== a3) {
                                    var r3 = e5[i4];
                                    ("day" === i4 && 29 === parseInt(r3) || "month" === i4 && 2 === parseInt(r3)) && (29 !== parseInt(e5.day) || 2 !== parseInt(e5.month) || "" !== e5.year && void 0 !== e5.year || e5._date.setFullYear(2012, 1, 29)), 
                                    "day" === i4 && (g2 = true, 0 === parseInt(r3) && (r3 = 1)), "month" === i4 && (g2 = true), 
                                    "year" === i4 && (g2 = true, r3.length < y2[n5][4] && (r3 = _2(r3, y2[n5][4], true))), 
                                    ("" !== r3 && !isNaN(r3) || "ampm" === i4) && a3.call(e5._date, r3);
                                }
                            }
                        }, {
                            key: "reset",
                            value: function() {
                                this._date = new Date(1, 0, 1);
                            }
                        }, {
                            key: "reInit",
                            value: function() {
                                this._date = void 0, this.date;
                            }
                        } ]) && f2(t4.prototype, n4), Object.defineProperty(t4, "prototype", {
                            writable: false
                        }), e4;
                    }(), v2 =  (new Date).getFullYear(), m2 = a2.default.prototype.i18n, g2 = false, y2 = {
                        d: [ "[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate ],
                        dd: [ "0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
                            return _2(Date.prototype.getDate.call(this), 2);
                        } ],
                        ddd: [ "" ],
                        dddd: [ "" ],
                        m: [ "[1-9]|1[012]", function(e4) {
                            var t4 = e4 ? parseInt(e4) : 0;
                            return t4 > 0 && t4--, Date.prototype.setMonth.call(this, t4);
                        }, "month", function() {
                            return Date.prototype.getMonth.call(this) + 1;
                        } ],
                        mm: [ "0[1-9]|1[012]", function(e4) {
                            var t4 = e4 ? parseInt(e4) : 0;
                            return t4 > 0 && t4--, Date.prototype.setMonth.call(this, t4);
                        }, "month", function() {
                            return _2(Date.prototype.getMonth.call(this) + 1, 2);
                        } ],
                        mmm: [ m2.monthNames.slice(0, 12).join("|"), function(e4) {
                            var t4 = m2.monthNames.slice(0, 12).findIndex((function(t5) {
                                return e4.toLowerCase() === t5.toLowerCase();
                            }));
                            return -1 !== t4 && Date.prototype.setMonth.call(this, t4);
                        }, "month", function() {
                            return m2.monthNames.slice(0, 12)[Date.prototype.getMonth.call(this)];
                        } ],
                        mmmm: [ m2.monthNames.slice(12, 24).join("|"), function(e4) {
                            var t4 = m2.monthNames.slice(12, 24).findIndex((function(t5) {
                                return e4.toLowerCase() === t5.toLowerCase();
                            }));
                            return -1 !== t4 && Date.prototype.setMonth.call(this, t4);
                        }, "month", function() {
                            return m2.monthNames.slice(12, 24)[Date.prototype.getMonth.call(this)];
                        } ],
                        yy: [ "[0-9]{2}", function(e4) {
                            var t4 =  (new Date).getFullYear().toString().slice(0, 2);
                            Date.prototype.setFullYear.call(this, "".concat(t4).concat(e4));
                        }, "year", function() {
                            return _2(Date.prototype.getFullYear.call(this), 2);
                        }, 2 ],
                        yyyy: [ "[0-9]{4}", Date.prototype.setFullYear, "year", function() {
                            return _2(Date.prototype.getFullYear.call(this), 4);
                        }, 4 ],
                        h: [ "[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                        hh: [ "0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
                            return _2(Date.prototype.getHours.call(this), 2);
                        } ],
                        hx: [ function(e4) {
                            return "[0-9]{".concat(e4, "}");
                        }, Date.prototype.setHours, "hours", function(e4) {
                            return Date.prototype.getHours;
                        } ],
                        H: [ "1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                        HH: [ "0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
                            return _2(Date.prototype.getHours.call(this), 2);
                        } ],
                        Hx: [ function(e4) {
                            return "[0-9]{".concat(e4, "}");
                        }, Date.prototype.setHours, "hours", function(e4) {
                            return function() {
                                return _2(Date.prototype.getHours.call(this), e4);
                            };
                        } ],
                        M: [ "[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes ],
                        MM: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
                            return _2(Date.prototype.getMinutes.call(this), 2);
                        } ],
                        s: [ "[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds ],
                        ss: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function() {
                            return _2(Date.prototype.getSeconds.call(this), 2);
                        } ],
                        l: [ "[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
                            return _2(Date.prototype.getMilliseconds.call(this), 3);
                        }, 3 ],
                        L: [ "[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
                            return _2(Date.prototype.getMilliseconds.call(this), 2);
                        }, 2 ],
                        t: [ "[ap]", b2, "ampm", x2, 1 ],
                        tt: [ "[ap]m", b2, "ampm", x2, 2 ],
                        T: [ "[AP]", b2, "ampm", x2, 1 ],
                        TT: [ "[AP]M", b2, "ampm", x2, 2 ],
                        Z: [ ".*", void 0, "Z", function() {
                            var e4 = this.toString().match(/\((.+)\)/)[1];
                            e4.includes(" ") && (e4 = (e4 = e4.replace("-", " ").toUpperCase()).split(" ").map((function(e5) {
                                return s2(e5, 1)[0];
                            })).join(""));
                            return e4;
                        } ],
                        o: [ "" ],
                        S: [ "" ]
                    }, k2 = {
                        isoDate: "yyyy-mm-dd",
                        isoTime: "HH:MM:ss",
                        isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
                        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
                    };
                    function b2(e4) {
                        var t4 = this.getHours();
                        e4.toLowerCase().includes("p") ? this.setHours(t4 + 12) : e4.toLowerCase().includes("a") && t4 >= 12 && this.setHours(t4 - 12);
                    }
                    function x2() {
                        var e4 = this.getHours();
                        return (e4 = e4 || 12) >= 12 ? "PM" : "AM";
                    }
                    function w2(e4) {
                        var t4 = /\d+$/.exec(e4[0]);
                        if (t4 && void 0 !== t4[0]) {
                            var n4 = y2[e4[0][0] + "x"].slice("");
                            return n4[0] = n4[0](t4[0]), n4[3] = n4[3](t4[0]), n4;
                        }
                        if (y2[e4[0]]) return y2[e4[0]];
                    }
                    function P2(e4) {
                        if (!e4.tokenizer) {
                            var t4 = [], n4 = [];
                            for (var i4 in y2) if (/\.*x$/.test(i4)) {
                                var a3 = i4[0] + "\\d+";
                                -1 === n4.indexOf(a3) && n4.push(a3);
                            } else -1 === t4.indexOf(i4[0]) && t4.push(i4[0]);
                            e4.tokenizer = "(" + (n4.length > 0 ? n4.join("|") + "|" : "") + t4.join("+|") + ")+?|.", 
                            e4.tokenizer = new RegExp(e4.tokenizer, "g");
                        }
                        return e4.tokenizer;
                    }
                    function S2(e4, t4, n4) {
                        if (!g2) return true;
                        if (void 0 === e4.rawday || !isFinite(e4.rawday) && new Date(e4.date.getFullYear(), isFinite(e4.rawmonth) ? e4.month : e4.date.getMonth() + 1, 0).getDate() >= e4.day || "29" == e4.day && (!isFinite(e4.rawyear) || void 0 === e4.rawyear || "" === e4.rawyear) || new Date(e4.date.getFullYear(), isFinite(e4.rawmonth) ? e4.month : e4.date.getMonth() + 1, 0).getDate() >= e4.day) return t4;
                        if ("29" == e4.day) {
                            var i4 = j2.call(this, t4.pos, n4, this.maskset);
                            if (i4.targetMatch && "yyyy" === i4.targetMatch[0] && t4.pos - i4.targetMatchIndex == 2) return t4.remove = t4.pos + 1, 
                            t4;
                        } else if (2 == e4.date.getMonth() && "30" == e4.day && void 0 !== t4.c) return e4.day = "03", 
                        e4.date.setDate(3), e4.date.setMonth(1), t4.insert = [ {
                            pos: t4.pos,
                            c: "0"
                        }, {
                            pos: t4.pos + 1,
                            c: t4.c
                        } ], t4.caret = o2.seekNext.call(this, t4.pos + 1), t4;
                        return false;
                    }
                    function O2(e4, t4, n4, a3) {
                        var r3, o3, l3 = "", s3 = 0, c3 = {};
                        for (P2(n4).lastIndex = 0; r3 = P2(n4).exec(e4); ) {
                            if (void 0 === t4) if (o3 = w2(r3)) l3 += "(" + o3[0] + ")", n4.placeholder && "" !== n4.placeholder ? (c3[s3] = n4.placeholder[r3.index % n4.placeholder.length], 
                            c3[n4.placeholder[r3.index % n4.placeholder.length]] = r3[0].charAt(0)) : c3[s3] = r3[0].charAt(0); else switch (r3[0]) {
                              case "[":
                                l3 += "(";
                                break;

                              case "]":
                                l3 += ")?";
                                break;

                              default:
                                l3 += (0, i3.default)(r3[0]), c3[s3] = r3[0].charAt(0);
                            } else if (o3 = w2(r3)) if (true !== a3 && o3[3]) l3 += o3[3].call(t4.date); else o3[2] ? l3 += t4["raw" + o3[2]] : l3 += r3[0]; else l3 += r3[0];
                            s3++;
                        }
                        return void 0 === t4 && (n4.placeholder = c3), l3;
                    }
                    function _2(e4, t4, n4) {
                        for (e4 = String(e4), t4 = t4 || 2; e4.length < t4; ) e4 = n4 ? e4 + "0" : "0" + e4;
                        return e4;
                    }
                    function M2(e4, t4, n4) {
                        return "string" == typeof e4 ? new h2(e4, t4, n4, this) : e4 && "object" === u2(e4) && Object.prototype.hasOwnProperty.call(e4, "date") ? e4 : void 0;
                    }
                    function E2(e4, t4) {
                        return O2(t4.inputFormat, {
                            date: e4
                        }, t4);
                    }
                    function j2(e4, t4, n4) {
                        var i4, a3, r3 = this, o3 = n4 && n4.tests[e4] ? t4.placeholder[n4.tests[e4][0].match.placeholder] || n4.tests[e4][0].match.placeholder : "", s3 = 0, c3 = 0;
                        for (P2(t4).lastIndex = 0; a3 = P2(t4).exec(t4.inputFormat); ) {
                            var u3 = /\d+$/.exec(a3[0]);
                            if (u3) c3 = parseInt(u3[0]); else {
                                for (var f3 = a3[0][0], p3 = s3; r3 && (t4.placeholder[l2.getTest.call(r3, p3).match.placeholder] || l2.getTest.call(r3, p3).match.placeholder) === f3; ) p3++;
                                0 === (c3 = p3 - s3) && (c3 = a3[0].length);
                            }
                            if (s3 += c3, -1 != a3[0].indexOf(o3) || s3 >= e4 + 1) {
                                i4 = a3, a3 = P2(t4).exec(t4.inputFormat);
                                break;
                            }
                        }
                        return {
                            targetMatchIndex: s3 - c3,
                            nextMatch: a3,
                            targetMatch: i4
                        };
                    }
                    a2.default.extendAliases({
                        datetime: {
                            mask: function(e4) {
                                return e4.numericInput = false, y2.S = m2.ordinalSuffix.join("|"), e4.inputFormat = k2[e4.inputFormat] || e4.inputFormat, 
                                e4.displayFormat = k2[e4.displayFormat] || e4.displayFormat || e4.inputFormat, e4.outputFormat = k2[e4.outputFormat] || e4.outputFormat || e4.inputFormat, 
                                e4.regex = O2(e4.inputFormat, void 0, e4), e4.min = M2(e4.min, e4.inputFormat, e4), 
                                e4.max = M2(e4.max, e4.inputFormat, e4), null;
                            },
                            placeholder: "",
                            inputFormat: "isoDateTime",
                            displayFormat: null,
                            outputFormat: null,
                            min: null,
                            max: null,
                            skipOptionalPartCharacter: "",
                            preValidation: function(e4, t4, n4, i4, a3, r3, o3, l3) {
                                if (l3) return true;
                                if (isNaN(n4) && e4[t4] !== n4) {
                                    var s3 = j2.call(this, t4, a3, r3);
                                    if (s3.nextMatch && s3.nextMatch[0] === n4 && s3.targetMatch[0].length > 1) {
                                        var c3 = w2(s3.targetMatch)[0];
                                        if (new RegExp(c3).test("0" + e4[t4 - 1])) return e4[t4] = e4[t4 - 1], e4[t4 - 1] = "0", 
                                        {
                                            fuzzy: true,
                                            buffer: e4,
                                            refreshFromBuffer: {
                                                start: t4 - 1,
                                                end: t4 + 1
                                            },
                                            pos: t4 + 1
                                        };
                                    }
                                }
                                return true;
                            },
                            postValidation: function(e4, t4, n4, i4, a3, r3, o3, s3) {
                                var c3, u3, f3 = this;
                                if (o3) return true;
                                if (false === i4 && (((c3 = j2.call(f3, t4 + 1, a3, r3)).targetMatch && c3.targetMatchIndex === t4 && c3.targetMatch[0].length > 1 && void 0 !== y2[c3.targetMatch[0]] || (c3 = j2.call(f3, t4 + 2, a3, r3)).targetMatch && c3.targetMatchIndex === t4 + 1 && c3.targetMatch[0].length > 1 && void 0 !== y2[c3.targetMatch[0]]) && (u3 = w2(c3.targetMatch)[0]), 
                                void 0 !== u3 && (void 0 !== r3.validPositions[t4 + 1] && new RegExp(u3).test(n4 + "0") ? (e4[t4] = n4, 
                                e4[t4 + 1] = "0", i4 = {
                                    pos: t4 + 2,
                                    caret: t4
                                }) : new RegExp(u3).test("0" + n4) && (e4[t4] = "0", e4[t4 + 1] = n4, i4 = {
                                    pos: t4 + 2
                                })), false === i4)) return i4;
                                if (i4.fuzzy && (e4 = i4.buffer, t4 = i4.pos), (c3 = j2.call(f3, t4, a3, r3)).targetMatch && c3.targetMatch[0] && void 0 !== y2[c3.targetMatch[0]]) {
                                    var p3 = w2(c3.targetMatch);
                                    u3 = p3[0];
                                    var d3 = e4.slice(c3.targetMatchIndex, c3.targetMatchIndex + c3.targetMatch[0].length);
                                    if (false === new RegExp(u3).test(d3.join("")) && 2 === c3.targetMatch[0].length && r3.validPositions[c3.targetMatchIndex] && r3.validPositions[c3.targetMatchIndex + 1] && (r3.validPositions[c3.targetMatchIndex + 1].input = "0"), 
                                    "year" == p3[2]) for (var h3 = l2.getMaskTemplate.call(f3, false, 1, void 0, true), m3 = t4 + 1; m3 < e4.length; m3++) e4[m3] = h3[m3], 
                                    r3.validPositions.splice(t4 + 1, 1);
                                }
                                var g3 = i4, k3 = M2.call(f3, e4.join(""), a3.inputFormat, a3);
                                return g3 && !isNaN(k3.date.getTime()) && (a3.prefillYear && (g3 = function(e5, t5, n5) {
                                    if (e5.year !== e5.rawyear) {
                                        var i5 = v2.toString(), a4 = e5.rawyear.replace(/[^0-9]/g, ""), r4 = i5.slice(0, a4.length), o4 = i5.slice(a4.length);
                                        if (2 === a4.length && a4 === r4) {
                                            var l3 = new Date(v2, e5.month - 1, e5.day);
                                            e5.day == l3.getDate() && (!n5.max || n5.max.date.getTime() >= l3.getTime()) && (e5.date.setFullYear(v2), 
                                            e5.year = i5, t5.insert = [ {
                                                pos: t5.pos + 1,
                                                c: o4[0]
                                            }, {
                                                pos: t5.pos + 2,
                                                c: o4[1]
                                            } ]);
                                        }
                                    }
                                    return t5;
                                }(k3, g3, a3)), g3 = function(e5, t5, n5, i5, a4) {
                                    if (!t5) return t5;
                                    if (t5 && n5.min && !isNaN(n5.min.date.getTime())) {
                                        var r4;
                                        for (e5.reset(), P2(n5).lastIndex = 0; r4 = P2(n5).exec(n5.inputFormat); ) {
                                            var o4;
                                            if ((o4 = w2(r4)) && o4[3]) {
                                                for (var l3 = o4[1], s4 = e5[o4[2]], c4 = n5.min[o4[2]], u4 = n5.max ? n5.max[o4[2]] : c4 + 1, f4 = [], p4 = false, d4 = 0; d4 < c4.length; d4++) void 0 !== i5.validPositions[d4 + r4.index] || p4 ? (f4[d4] = s4[d4], 
                                                p4 = p4 || s4[d4] > c4[d4]) : (d4 + r4.index == 0 && s4[d4] < c4[d4] ? (f4[d4] = s4[d4], 
                                                p4 = true) : f4[d4] = c4[d4], "year" === o4[2] && s4.length - 1 == d4 && c4 != u4 && (f4 = (parseInt(f4.join("")) + 1).toString().split("")), 
                                                "ampm" === o4[2] && c4 != u4 && n5.min.date.getTime() > e5.date.getTime() && (f4[d4] = u4[d4]));
                                                l3.call(e5._date, f4.join(""));
                                            }
                                        }
                                        t5 = n5.min.date.getTime() <= e5.date.getTime(), e5.reInit();
                                    }
                                    return t5 && n5.max && (isNaN(n5.max.date.getTime()) || (t5 = n5.max.date.getTime() >= e5.date.getTime())), 
                                    t5;
                                }(k3, g3 = S2.call(f3, k3, g3, a3), a3, r3)), void 0 !== t4 && g3 && i4.pos !== t4 ? {
                                    buffer: O2(a3.inputFormat, k3, a3).split(""),
                                    refreshFromBuffer: {
                                        start: t4,
                                        end: i4.pos
                                    },
                                    pos: i4.caret || i4.pos
                                } : g3;
                            },
                            onKeyDown: function(e4, t4, n4, i4) {
                                e4.ctrlKey && e4.key === r2.keys.ArrowRight && (this.inputmask._valueSet(E2( new Date, i4)), 
                                d2(this).trigger("setvalue"));
                            },
                            onUnMask: function(e4, t4, n4) {
                                return t4 ? O2(n4.outputFormat, M2.call(this, e4, n4.inputFormat, n4), n4, true) : t4;
                            },
                            casing: function(e4, t4, n4, i4) {
                                if (0 == t4.nativeDef.indexOf("[ap]")) return e4.toLowerCase();
                                if (0 == t4.nativeDef.indexOf("[AP]")) return e4.toUpperCase();
                                var a3 = l2.getTest.call(this, [ n4 - 1 ]);
                                return 0 == a3.match.def.indexOf("[AP]") || 0 === n4 || a3 && a3.input === String.fromCharCode(r2.keyCode.Space) || a3 && a3.match.def === String.fromCharCode(r2.keyCode.Space) ? e4.toUpperCase() : e4.toLowerCase();
                            },
                            onBeforeMask: function(e4, t4) {
                                return "[object Date]" === Object.prototype.toString.call(e4) && (e4 = E2(e4, t4)), 
                                e4;
                            },
                            insertMode: false,
                            insertModeVisual: false,
                            shiftPositions: false,
                            keepStatic: false,
                            inputmode: "numeric",
                            prefillYear: true
                        }
                    });
                },
                1313: function(e3, t3, n3) {
                    var i3, a2 = (i3 = n3(2394)) && i3.__esModule ? i3 : {
                        default: i3
                    };
                    a2.default.dependencyLib.extend(true, a2.default.prototype.i18n, {
                        dayNames: [ "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" ],
                        monthNames: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                        ordinalSuffix: [ "st", "nd", "rd", "th" ]
                    });
                },
                3851: function(e3, t3, n3) {
                    var i3, a2 = (i3 = n3(2394)) && i3.__esModule ? i3 : {
                        default: i3
                    }, r2 = n3(8711), o2 = n3(4713);
                    function l2(e4) {
                        return function(e5) {
                            if (Array.isArray(e5)) return s2(e5);
                        }(e4) || function(e5) {
                            if ("undefined" != typeof Symbol && null != e5[Symbol.iterator] || null != e5["@@iterator"]) return Array.from(e5);
                        }(e4) || function(e5, t4) {
                            if (!e5) return;
                            if ("string" == typeof e5) return s2(e5, t4);
                            var n4 = Object.prototype.toString.call(e5).slice(8, -1);
                            "Object" === n4 && e5.constructor && (n4 = e5.constructor.name);
                            if ("Map" === n4 || "Set" === n4) return Array.from(e5);
                            if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4)) return s2(e5, t4);
                        }(e4) || function() {
                            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }();
                    }
                    function s2(e4, t4) {
                        (null == t4 || t4 > e4.length) && (t4 = e4.length);
                        for (var n4 = 0, i4 = new Array(t4); n4 < t4; n4++) i4[n4] = e4[n4];
                        return i4;
                    }
                    a2.default.extendDefinitions({
                        A: {
                            validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                            casing: "upper"
                        },
                        "&": {
                            validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]",
                            casing: "upper"
                        },
                        "#": {
                            validator: "[0-9A-Fa-f]",
                            casing: "upper"
                        }
                    });
                    var c2 = /25[0-5]|2[0-4][0-9]|[01][0-9][0-9]/;
                    function u2(e4, t4, n4, i4, a3) {
                        if (n4 - 1 > -1 && "." !== t4.buffer[n4 - 1] ? (e4 = t4.buffer[n4 - 1] + e4, e4 = n4 - 2 > -1 && "." !== t4.buffer[n4 - 2] ? t4.buffer[n4 - 2] + e4 : "0" + e4) : e4 = "00" + e4, 
                        a3.greedy && parseInt(e4) > 255 && c2.test("00" + e4.charAt(2))) {
                            var r3 = [].concat(l2(t4.buffer.slice(0, n4)), [ ".", e4.charAt(2) ]);
                            if (r3.join("").match(/\./g).length < 4) return {
                                refreshFromBuffer: true,
                                buffer: r3,
                                caret: n4 + 2
                            };
                        }
                        return c2.test(e4);
                    }
                    a2.default.extendAliases({
                        cssunit: {
                            regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
                        },
                        url: {
                            regex: "(https?|ftp)://.*",
                            autoUnmask: false,
                            keepStatic: false,
                            tabThrough: true
                        },
                        ip: {
                            mask: "i{1,3}.j{1,3}.k{1,3}.l{1,3}",
                            definitions: {
                                i: {
                                    validator: u2
                                },
                                j: {
                                    validator: u2
                                },
                                k: {
                                    validator: u2
                                },
                                l: {
                                    validator: u2
                                }
                            },
                            onUnMask: function(e4, t4, n4) {
                                return e4;
                            },
                            inputmode: "decimal",
                            substitutes: {
                                ",": "."
                            }
                        },
                        email: {
                            mask: function(e4) {
                                var t4 = e4.separator, n4 = e4.quantifier, i4 = "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", a3 = i4;
                                if (t4) for (var r3 = 0; r3 < n4; r3++) a3 += "[".concat(t4).concat(i4, "]");
                                return a3;
                            },
                            greedy: false,
                            casing: "lower",
                            separator: null,
                            quantifier: 5,
                            skipOptionalPartCharacter: "",
                            onBeforePaste: function(e4, t4) {
                                return (e4 = e4.toLowerCase()).replace("mailto:", "");
                            },
                            definitions: {
                                "*": {
                                    validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ!#$%&'*+/=?^_`{|}~-]"
                                },
                                "-": {
                                    validator: "[0-9A-Za-z-]"
                                }
                            },
                            onUnMask: function(e4, t4, n4) {
                                return e4;
                            },
                            inputmode: "email"
                        },
                        mac: {
                            mask: "##:##:##:##:##:##"
                        },
                        vin: {
                            mask: "V{13}9{4}",
                            definitions: {
                                V: {
                                    validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                                    casing: "upper"
                                }
                            },
                            clearIncomplete: true,
                            autoUnmask: true
                        },
                        ssn: {
                            mask: "999-99-9999",
                            postValidation: function(e4, t4, n4, i4, a3, l3, s3) {
                                var c3 = o2.getMaskTemplate.call(this, true, r2.getLastValidPosition.call(this), true, true);
                                return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(c3.join(""));
                            }
                        }
                    });
                },
                207: function(e3, t3, n3) {
                    var i3 = l2(n3(7184)), a2 = l2(n3(2394)), r2 = n3(2839), o2 = n3(8711);
                    function l2(e4) {
                        return e4 && e4.__esModule ? e4 : {
                            default: e4
                        };
                    }
                    var s2 = a2.default.dependencyLib;
                    function c2(e4, t4) {
                        for (var n4 = "", i4 = 0; i4 < e4.length; i4++) a2.default.prototype.definitions[e4.charAt(i4)] || t4.definitions[e4.charAt(i4)] || t4.optionalmarker[0] === e4.charAt(i4) || t4.optionalmarker[1] === e4.charAt(i4) || t4.quantifiermarker[0] === e4.charAt(i4) || t4.quantifiermarker[1] === e4.charAt(i4) || t4.groupmarker[0] === e4.charAt(i4) || t4.groupmarker[1] === e4.charAt(i4) || t4.alternatormarker === e4.charAt(i4) ? n4 += "\\" + e4.charAt(i4) : n4 += e4.charAt(i4);
                        return n4;
                    }
                    function u2(e4, t4, n4, i4) {
                        if (e4.length > 0 && t4 > 0 && (!n4.digitsOptional || i4)) {
                            var a3 = e4.indexOf(n4.radixPoint), r3 = false;
                            n4.negationSymbol.back === e4[e4.length - 1] && (r3 = true, e4.length--), -1 === a3 && (e4.push(n4.radixPoint), 
                            a3 = e4.length - 1);
                            for (var o3 = 1; o3 <= t4; o3++) isFinite(e4[a3 + o3]) || (e4[a3 + o3] = "0");
                        }
                        return r3 && e4.push(n4.negationSymbol.back), e4;
                    }
                    function f2(e4, t4) {
                        var n4 = 0;
                        for (var i4 in "+" === e4 && (n4 = o2.seekNext.call(this, t4.validPositions.length - 1)), 
                        t4.tests) if ((i4 = parseInt(i4)) >= n4) for (var a3 = 0, r3 = t4.tests[i4].length; a3 < r3; a3++) if ((void 0 === t4.validPositions[i4] || "-" === e4) && t4.tests[i4][a3].match.def === e4) return i4 + (void 0 !== t4.validPositions[i4] && "-" !== e4 ? 1 : 0);
                        return n4;
                    }
                    function p2(e4, t4) {
                        for (var n4 = -1, i4 = 0, a3 = t4.validPositions.length; i4 < a3; i4++) {
                            var r3 = t4.validPositions[i4];
                            if (r3 && r3.match.def === e4) {
                                n4 = i4;
                                break;
                            }
                        }
                        return n4;
                    }
                    function d2(e4, t4, n4, i4, a3) {
                        var r3 = t4.buffer ? t4.buffer.indexOf(a3.radixPoint) : -1, o3 = (-1 !== r3 || i4 && a3.jitMasking) && new RegExp(a3.definitions[9].validator).test(e4);
                        return !i4 && a3._radixDance && -1 !== r3 && o3 && null == t4.validPositions[r3] ? {
                            insert: {
                                pos: r3 === n4 ? r3 + 1 : r3,
                                c: a3.radixPoint
                            },
                            pos: n4
                        } : o3;
                    }
                    a2.default.extendAliases({
                        numeric: {
                            mask: function(e4) {
                                e4.repeat = 0, e4.groupSeparator === e4.radixPoint && e4.digits && "0" !== e4.digits && ("." === e4.radixPoint ? e4.groupSeparator = "," : "," === e4.radixPoint ? e4.groupSeparator = "." : e4.groupSeparator = ""), 
                                " " === e4.groupSeparator && (e4.skipOptionalPartCharacter = void 0), e4.placeholder.length > 1 && (e4.placeholder = e4.placeholder.charAt(0)), 
                                "radixFocus" === e4.positionCaretOnClick && "" === e4.placeholder && (e4.positionCaretOnClick = "lvp");
                                var t4 = "0", n4 = e4.radixPoint;
                                true === e4.numericInput && void 0 === e4.__financeInput ? (t4 = "1", e4.positionCaretOnClick = "radixFocus" === e4.positionCaretOnClick ? "lvp" : e4.positionCaretOnClick, 
                                e4.digitsOptional = false, isNaN(e4.digits) && (e4.digits = 2), e4._radixDance = false, 
                                n4 = "," === e4.radixPoint ? "?" : "!", "" !== e4.radixPoint && void 0 === e4.definitions[n4] && (e4.definitions[n4] = {}, 
                                e4.definitions[n4].validator = "[" + e4.radixPoint + "]", e4.definitions[n4].placeholder = e4.radixPoint, 
                                e4.definitions[n4].static = true, e4.definitions[n4].generated = true)) : (e4.__financeInput = false, 
                                e4.numericInput = true);
                                var a3, r3 = "[+]";
                                if (r3 += c2(e4.prefix, e4), "" !== e4.groupSeparator ? (void 0 === e4.definitions[e4.groupSeparator] && (e4.definitions[e4.groupSeparator] = {}, 
                                e4.definitions[e4.groupSeparator].validator = "[" + e4.groupSeparator + "]", e4.definitions[e4.groupSeparator].placeholder = e4.groupSeparator, 
                                e4.definitions[e4.groupSeparator].static = true, e4.definitions[e4.groupSeparator].generated = true), 
                                r3 += e4._mask(e4)) : r3 += "9{+}", void 0 !== e4.digits && 0 !== e4.digits) {
                                    var o3 = e4.digits.toString().split(",");
                                    isFinite(o3[0]) && o3[1] && isFinite(o3[1]) ? r3 += n4 + t4 + "{" + e4.digits + "}" : (isNaN(e4.digits) || parseInt(e4.digits) > 0) && (e4.digitsOptional || e4.jitMasking ? (a3 = r3 + n4 + t4 + "{0," + e4.digits + "}", 
                                    e4.keepStatic = true) : r3 += n4 + t4 + "{" + e4.digits + "}");
                                } else e4.inputmode = "numeric";
                                return r3 += c2(e4.suffix, e4), r3 += "[-]", a3 && (r3 = [ a3 + c2(e4.suffix, e4) + "[-]", r3 ]), 
                                e4.greedy = false, function(e5) {
                                    void 0 === e5.parseMinMaxOptions && (null !== e5.min && (e5.min = e5.min.toString().replace(new RegExp((0, 
                                    i3.default)(e5.groupSeparator), "g"), ""), "," === e5.radixPoint && (e5.min = e5.min.replace(e5.radixPoint, ".")), 
                                    e5.min = isFinite(e5.min) ? parseFloat(e5.min) : NaN, isNaN(e5.min) && (e5.min = Number.MIN_VALUE)), 
                                    null !== e5.max && (e5.max = e5.max.toString().replace(new RegExp((0, i3.default)(e5.groupSeparator), "g"), ""), 
                                    "," === e5.radixPoint && (e5.max = e5.max.replace(e5.radixPoint, ".")), e5.max = isFinite(e5.max) ? parseFloat(e5.max) : NaN, 
                                    isNaN(e5.max) && (e5.max = Number.MAX_VALUE)), e5.parseMinMaxOptions = "done");
                                }(e4), "" !== e4.radixPoint && e4.substituteRadixPoint && (e4.substitutes["." == e4.radixPoint ? "," : "."] = e4.radixPoint), 
                                r3;
                            },
                            _mask: function(e4) {
                                return "(" + e4.groupSeparator + "999){+|1}";
                            },
                            digits: "*",
                            digitsOptional: true,
                            enforceDigitsOnBlur: false,
                            radixPoint: ".",
                            positionCaretOnClick: "radixFocus",
                            _radixDance: true,
                            groupSeparator: "",
                            allowMinus: true,
                            negationSymbol: {
                                front: "-",
                                back: ""
                            },
                            prefix: "",
                            suffix: "",
                            min: null,
                            max: null,
                            SetMaxOnOverflow: false,
                            step: 1,
                            inputType: "text",
                            unmaskAsNumber: false,
                            roundingFN: Math.round,
                            inputmode: "decimal",
                            shortcuts: {
                                k: "1000",
                                m: "1000000"
                            },
                            placeholder: "0",
                            greedy: false,
                            rightAlign: true,
                            insertMode: true,
                            autoUnmask: false,
                            skipOptionalPartCharacter: "",
                            usePrototypeDefinitions: false,
                            stripLeadingZeroes: true,
                            substituteRadixPoint: true,
                            definitions: {
                                0: {
                                    validator: d2
                                },
                                1: {
                                    validator: d2,
                                    definitionSymbol: "9"
                                },
                                9: {
                                    validator: "[0-9０-９٠-٩۰-۹]",
                                    definitionSymbol: "*"
                                },
                                "+": {
                                    validator: function(e4, t4, n4, i4, a3) {
                                        return a3.allowMinus && ("-" === e4 || e4 === a3.negationSymbol.front);
                                    }
                                },
                                "-": {
                                    validator: function(e4, t4, n4, i4, a3) {
                                        return a3.allowMinus && e4 === a3.negationSymbol.back;
                                    }
                                }
                            },
                            preValidation: function(e4, t4, n4, i4, a3, r3, o3, l3) {
                                var s3 = this;
                                if (false !== a3.__financeInput && n4 === a3.radixPoint) return false;
                                var c3 = e4.indexOf(a3.radixPoint), u3 = t4;
                                if (t4 = function(e5, t5, n5, i5, a4) {
                                    return a4._radixDance && a4.numericInput && t5 !== a4.negationSymbol.back && e5 <= n5 && (n5 > 0 || t5 == a4.radixPoint) && (void 0 === i5.validPositions[e5 - 1] || i5.validPositions[e5 - 1].input !== a4.negationSymbol.back) && (e5 -= 1), 
                                    e5;
                                }(t4, n4, c3, r3, a3), "-" === n4 || n4 === a3.negationSymbol.front) {
                                    if (true !== a3.allowMinus) return false;
                                    var d3 = false, h2 = p2("+", r3), v2 = p2("-", r3);
                                    return -1 !== h2 && (d3 = [ h2 ], -1 !== v2 && d3.push(v2)), false !== d3 ? {
                                        remove: d3,
                                        caret: u3 - a3.negationSymbol.back.length
                                    } : {
                                        insert: [ {
                                            pos: f2.call(s3, "+", r3),
                                            c: a3.negationSymbol.front,
                                            fromIsValid: true
                                        }, {
                                            pos: f2.call(s3, "-", r3),
                                            c: a3.negationSymbol.back,
                                            fromIsValid: void 0
                                        } ],
                                        caret: u3 + a3.negationSymbol.back.length
                                    };
                                }
                                if (n4 === a3.groupSeparator) return {
                                    caret: u3
                                };
                                if (l3) return true;
                                if (-1 !== c3 && true === a3._radixDance && false === i4 && n4 === a3.radixPoint && void 0 !== a3.digits && (isNaN(a3.digits) || parseInt(a3.digits) > 0) && c3 !== t4) {
                                    var m2 = f2.call(s3, a3.radixPoint, r3);
                                    return r3.validPositions[m2] && (r3.validPositions[m2].generatedInput = r3.validPositions[m2].generated || false), 
                                    {
                                        caret: a3._radixDance && t4 === c3 - 1 ? c3 + 1 : c3
                                    };
                                }
                                if (false === a3.__financeInput) if (i4) {
                                    if (a3.digitsOptional) return {
                                        rewritePosition: o3.end
                                    };
                                    if (!a3.digitsOptional) {
                                        if (o3.begin > c3 && o3.end <= c3) return n4 === a3.radixPoint ? {
                                            insert: {
                                                pos: c3 + 1,
                                                c: "0",
                                                fromIsValid: true
                                            },
                                            rewritePosition: c3
                                        } : {
                                            rewritePosition: c3 + 1
                                        };
                                        if (o3.begin < c3) return {
                                            rewritePosition: o3.begin - 1
                                        };
                                    }
                                } else if (!a3.showMaskOnHover && !a3.showMaskOnFocus && !a3.digitsOptional && a3.digits > 0 && "" === this.__valueGet.call(this.el)) return {
                                    rewritePosition: c3
                                };
                                return {
                                    rewritePosition: t4
                                };
                            },
                            postValidation: function(e4, t4, n4, i4, a3, r3, o3) {
                                if (false === i4) return i4;
                                if (o3) return true;
                                if (null !== a3.min || null !== a3.max) {
                                    var l3 = a3.onUnMask(e4.slice().reverse().join(""), void 0, s2.extend({}, a3, {
                                        unmaskAsNumber: true
                                    }));
                                    if (null !== a3.min && l3 < a3.min && (l3.toString().length > a3.min.toString().length || l3 < 0)) return false;
                                    if (null !== a3.max && l3 > a3.max) return !!a3.SetMaxOnOverflow && {
                                        refreshFromBuffer: true,
                                        buffer: u2(a3.max.toString().replace(".", a3.radixPoint).split(""), a3.digits, a3).reverse()
                                    };
                                }
                                return i4;
                            },
                            onUnMask: function(e4, t4, n4) {
                                if ("" === t4 && true === n4.nullable) return t4;
                                var a3 = e4.replace(n4.prefix, "");
                                return a3 = (a3 = a3.replace(n4.suffix, "")).replace(new RegExp((0, i3.default)(n4.groupSeparator), "g"), ""), 
                                "" !== n4.placeholder.charAt(0) && (a3 = a3.replace(new RegExp(n4.placeholder.charAt(0), "g"), "0")), 
                                n4.unmaskAsNumber ? ("" !== n4.radixPoint && -1 !== a3.indexOf(n4.radixPoint) && (a3 = a3.replace(i3.default.call(this, n4.radixPoint), ".")), 
                                a3 = (a3 = a3.replace(new RegExp("^" + (0, i3.default)(n4.negationSymbol.front)), "-")).replace(new RegExp((0, 
                                i3.default)(n4.negationSymbol.back) + "$"), ""), Number(a3)) : a3;
                            },
                            isComplete: function(e4, t4) {
                                var n4 = (t4.numericInput ? e4.slice().reverse() : e4).join("");
                                return n4 = (n4 = (n4 = (n4 = (n4 = n4.replace(new RegExp("^" + (0, i3.default)(t4.negationSymbol.front)), "-")).replace(new RegExp((0, 
                                i3.default)(t4.negationSymbol.back) + "$"), "")).replace(t4.prefix, "")).replace(t4.suffix, "")).replace(new RegExp((0, 
                                i3.default)(t4.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === t4.radixPoint && (n4 = n4.replace((0, 
                                i3.default)(t4.radixPoint), ".")), isFinite(n4);
                            },
                            onBeforeMask: function(e4, t4) {
                                var n4;
                                e4 = null !== (n4 = e4) && void 0 !== n4 ? n4 : "";
                                var a3 = t4.radixPoint || ",";
                                isFinite(t4.digits) && (t4.digits = parseInt(t4.digits)), "number" != typeof e4 && "number" !== t4.inputType || "" === a3 || (e4 = e4.toString().replace(".", a3));
                                var r3 = "-" === e4.charAt(0) || e4.charAt(0) === t4.negationSymbol.front, o3 = e4.split(a3), l3 = o3[0].replace(/[^\-0-9]/g, ""), s3 = o3.length > 1 ? o3[1].replace(/[^0-9]/g, "") : "", c3 = o3.length > 1;
                                e4 = l3 + ("" !== s3 ? a3 + s3 : s3);
                                var f3 = 0;
                                if ("" !== a3 && (f3 = t4.digitsOptional ? t4.digits < s3.length ? t4.digits : s3.length : t4.digits, 
                                "" !== s3 || !t4.digitsOptional)) {
                                    var p3 = Math.pow(10, f3 || 1);
                                    e4 = e4.replace((0, i3.default)(a3), "."), isNaN(parseFloat(e4)) || (e4 = (t4.roundingFN(parseFloat(e4) * p3) / p3).toFixed(f3)), 
                                    e4 = e4.toString().replace(".", a3);
                                }
                                if (0 === t4.digits && -1 !== e4.indexOf(a3) && (e4 = e4.substring(0, e4.indexOf(a3))), 
                                null !== t4.min || null !== t4.max) {
                                    var d3 = e4.toString().replace(a3, ".");
                                    null !== t4.min && d3 < t4.min ? e4 = t4.min.toString().replace(".", a3) : null !== t4.max && d3 > t4.max && (e4 = t4.max.toString().replace(".", a3));
                                }
                                return r3 && "-" !== e4.charAt(0) && (e4 = "-" + e4), u2(e4.toString().split(""), f3, t4, c3).join("");
                            },
                            onBeforeWrite: function(e4, t4, n4, a3) {
                                function r3(e5, t5) {
                                    if (false !== a3.__financeInput || t5) {
                                        var n5 = e5.indexOf(a3.radixPoint);
                                        -1 !== n5 && e5.splice(n5, 1);
                                    }
                                    if ("" !== a3.groupSeparator) for (;-1 !== (n5 = e5.indexOf(a3.groupSeparator)); ) e5.splice(n5, 1);
                                    return e5;
                                }
                                var o3, l3;
                                if (a3.stripLeadingZeroes && (l3 = function(e5, t5) {
                                    var n5 = new RegExp("(^" + ("" !== t5.negationSymbol.front ? (0, i3.default)(t5.negationSymbol.front) + "?" : "") + (0, 
                                    i3.default)(t5.prefix) + ")(.*)(" + (0, i3.default)(t5.suffix) + ("" != t5.negationSymbol.back ? (0, 
                                    i3.default)(t5.negationSymbol.back) + "?" : "") + "$)").exec(e5.slice().reverse().join("")), a4 = n5 ? n5[2] : "", r4 = false;
                                    return a4 && (a4 = a4.split(t5.radixPoint.charAt(0))[0], r4 = new RegExp("^[0" + t5.groupSeparator + "]*").exec(a4)), 
                                    !(!r4 || !(r4[0].length > 1 || r4[0].length > 0 && r4[0].length < a4.length)) && r4;
                                }(t4, a3))) for (var c3 = t4.join("").lastIndexOf(l3[0].split("").reverse().join("")) - (l3[0] == l3.input ? 0 : 1), f3 = l3[0] == l3.input ? 1 : 0, p3 = l3[0].length - f3; p3 > 0; p3--) this.maskset.validPositions.splice(c3 + p3, 1), 
                                delete t4[c3 + p3];
                                if (e4) switch (e4.type) {
                                  case "blur":
                                  case "checkval":
                                    if (null !== a3.min) {
                                        var d3 = a3.onUnMask(t4.slice().reverse().join(""), void 0, s2.extend({}, a3, {
                                            unmaskAsNumber: true
                                        }));
                                        if (null !== a3.min && d3 < a3.min) return {
                                            refreshFromBuffer: true,
                                            buffer: u2(a3.min.toString().replace(".", a3.radixPoint).split(""), a3.digits, a3).reverse()
                                        };
                                    }
                                    if (t4[t4.length - 1] === a3.negationSymbol.front) {
                                        var h2 = new RegExp("(^" + ("" != a3.negationSymbol.front ? (0, i3.default)(a3.negationSymbol.front) + "?" : "") + (0, 
                                        i3.default)(a3.prefix) + ")(.*)(" + (0, i3.default)(a3.suffix) + ("" != a3.negationSymbol.back ? (0, 
                                        i3.default)(a3.negationSymbol.back) + "?" : "") + "$)").exec(r3(t4.slice(), true).reverse().join(""));
                                        0 == (h2 ? h2[2] : "") && (o3 = {
                                            refreshFromBuffer: true,
                                            buffer: [ 0 ]
                                        });
                                    } else if ("" !== a3.radixPoint) t4.indexOf(a3.radixPoint) === a3.suffix.length && (o3 && o3.buffer ? o3.buffer.splice(0, 1 + a3.suffix.length) : (t4.splice(0, 1 + a3.suffix.length), 
                                    o3 = {
                                        refreshFromBuffer: true,
                                        buffer: r3(t4)
                                    }));
                                    if (a3.enforceDigitsOnBlur) {
                                        var v2 = (o3 = o3 || {}) && o3.buffer || t4.slice().reverse();
                                        o3.refreshFromBuffer = true, o3.buffer = u2(v2, a3.digits, a3, true).reverse();
                                    }
                                }
                                return o3;
                            },
                            onKeyDown: function(e4, t4, n4, i4) {
                                var a3, o3 = s2(this);
                                if (3 != e4.location) {
                                    var l3, c3 = e4.key;
                                    if ((l3 = i4.shortcuts && i4.shortcuts[c3]) && l3.length > 1) return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(l3)), 
                                    o3.trigger("setvalue"), false;
                                }
                                if (e4.ctrlKey) switch (e4.key) {
                                  case r2.keys.ArrowUp:
                                    return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(i4.step)), 
                                    o3.trigger("setvalue"), false;

                                  case r2.keys.ArrowDown:
                                    return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(i4.step)), 
                                    o3.trigger("setvalue"), false;
                                }
                                if (!e4.shiftKey && (e4.key === r2.keys.Delete || e4.key === r2.keys.Backspace || e4.key === r2.keys.BACKSPACE_SAFARI) && n4.begin !== t4.length) {
                                    if (t4[e4.key === r2.keys.Delete ? n4.begin - 1 : n4.end] === i4.negationSymbol.front) return a3 = t4.slice().reverse(), 
                                    "" !== i4.negationSymbol.front && a3.shift(), "" !== i4.negationSymbol.back && a3.pop(), 
                                    o3.trigger("setvalue", [ a3.join(""), n4.begin ]), false;
                                    if (true === i4._radixDance) {
                                        var f3, p3 = t4.indexOf(i4.radixPoint);
                                        if (i4.digitsOptional) {
                                            if (0 === p3) return (a3 = t4.slice().reverse()).pop(), o3.trigger("setvalue", [ a3.join(""), n4.begin >= a3.length ? a3.length : n4.begin ]), 
                                            false;
                                        } else if (-1 !== p3 && (n4.begin < p3 || n4.end < p3 || e4.key === r2.keys.Delete && (n4.begin === p3 || n4.begin - 1 === p3))) return n4.begin === n4.end && (e4.key === r2.keys.Backspace || e4.key === r2.keys.BACKSPACE_SAFARI ? n4.begin++ : e4.key === r2.keys.Delete && n4.begin - 1 === p3 && (f3 = s2.extend({}, n4), 
                                        n4.begin--, n4.end--)), (a3 = t4.slice().reverse()).splice(a3.length - n4.begin, n4.begin - n4.end + 1), 
                                        a3 = u2(a3, i4.digits, i4).join(""), f3 && (n4 = f3), o3.trigger("setvalue", [ a3, n4.begin >= a3.length ? p3 + 1 : n4.begin ]), 
                                        false;
                                    }
                                }
                            }
                        },
                        currency: {
                            prefix: "",
                            groupSeparator: ",",
                            alias: "numeric",
                            digits: 2,
                            digitsOptional: false
                        },
                        decimal: {
                            alias: "numeric"
                        },
                        integer: {
                            alias: "numeric",
                            inputmode: "numeric",
                            digits: 0
                        },
                        percentage: {
                            alias: "numeric",
                            min: 0,
                            max: 100,
                            suffix: " %",
                            digits: 0,
                            allowMinus: false
                        },
                        indianns: {
                            alias: "numeric",
                            _mask: function(e4) {
                                return "(" + e4.groupSeparator + "99){*|1}(" + e4.groupSeparator + "999){1|1}";
                            },
                            groupSeparator: ",",
                            radixPoint: ".",
                            placeholder: "0",
                            digits: 2,
                            digitsOptional: false
                        }
                    });
                },
                9380: function(e3, t3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.default = void 0;
                    var n3 = !("undefined" == typeof window || !window.document || !window.document.createElement);
                    t3.default = n3 ? window : {};
                },
                7760: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.HandleNativePlaceholder = function(e4, t4) {
                        var n4 = e4 ? e4.inputmask : this;
                        if (i3.ie) {
                            if (e4.inputmask._valueGet() !== t4 && (e4.placeholder !== t4 || "" === e4.placeholder)) {
                                var a3 = o2.getBuffer.call(n4).slice(), r3 = e4.inputmask._valueGet();
                                if (r3 !== t4) {
                                    var l3 = o2.getLastValidPosition.call(n4);
                                    -1 === l3 && r3 === o2.getBufferTemplate.call(n4).join("") ? a3 = [] : -1 !== l3 && u2.call(n4, a3), 
                                    p2(e4, a3);
                                }
                            }
                        } else e4.placeholder !== t4 && (e4.placeholder = t4, "" === e4.placeholder && e4.removeAttribute("placeholder"));
                    }, t3.applyInputValue = c2, t3.checkVal = f2, t3.clearOptionalTail = u2, t3.unmaskedvalue = function(e4) {
                        var t4 = e4 ? e4.inputmask : this, n4 = t4.opts, i4 = t4.maskset;
                        if (e4) {
                            if (void 0 === e4.inputmask) return e4.value;
                            e4.inputmask && e4.inputmask.refreshValue && c2(e4, e4.inputmask._valueGet(true));
                        }
                        for (var a3 = [], r3 = i4.validPositions, l3 = 0, s3 = r3.length; l3 < s3; l3++) r3[l3] && r3[l3].match && (1 != r3[l3].match.static || Array.isArray(i4.metadata) && true !== r3[l3].generatedInput) && a3.push(r3[l3].input);
                        var u3 = 0 === a3.length ? "" : (t4.isRTL ? a3.reverse() : a3).join("");
                        if ("function" == typeof n4.onUnMask) {
                            var f3 = (t4.isRTL ? o2.getBuffer.call(t4).slice().reverse() : o2.getBuffer.call(t4)).join("");
                            u3 = n4.onUnMask.call(t4, f3, u3, n4);
                        }
                        return u3;
                    }, t3.writeBuffer = p2;
                    var i3 = n3(9845), a2 = n3(6030), r2 = n3(2839), o2 = n3(8711), l2 = n3(7215), s2 = n3(4713);
                    function c2(e4, t4, n4) {
                        var i4 = e4 ? e4.inputmask : this, a3 = i4.opts;
                        e4.inputmask.refreshValue = false, "function" == typeof a3.onBeforeMask && (t4 = a3.onBeforeMask.call(i4, t4, a3) || t4), 
                        f2(e4, true, false, t4 = (t4 || "").toString().split(""), n4), i4.undoValue = i4._valueGet(true), 
                        (a3.clearMaskOnLostFocus || a3.clearIncomplete) && e4.inputmask._valueGet() === o2.getBufferTemplate.call(i4).join("") && -1 === o2.getLastValidPosition.call(i4) && e4.inputmask._valueSet("");
                    }
                    function u2(e4) {
                        e4.length = 0;
                        for (var t4, n4 = s2.getMaskTemplate.call(this, true, 0, true, void 0, true); void 0 !== (t4 = n4.shift()); ) e4.push(t4);
                        return e4;
                    }
                    function f2(e4, t4, n4, i4, r3) {
                        var c3, u3 = e4 ? e4.inputmask : this, f3 = u3.maskset, d2 = u3.opts, h2 = u3.dependencyLib, v2 = i4.slice(), m2 = "", g2 = -1, y2 = d2.skipOptionalPartCharacter;
                        d2.skipOptionalPartCharacter = "", o2.resetMaskSet.call(u3, false), u3.clicked = 0, 
                        g2 = d2.radixPoint ? o2.determineNewCaretPosition.call(u3, {
                            begin: 0,
                            end: 0
                        }, false, false === d2.__financeInput ? "radixFocus" : void 0).begin : 0, f3.p = g2, 
                        u3.caretPos = {
                            begin: g2
                        };
                        var k2 = [], b2 = u3.caretPos;
                        if (v2.forEach((function(e5, t5) {
                            if (void 0 !== e5) {
                                var i5 = new h2.Event("_checkval");
                                i5.key = e5, m2 += e5;
                                var r4 = o2.getLastValidPosition.call(u3, void 0, true);
                                !function(e6, t6) {
                                    for (var n5 = s2.getMaskTemplate.call(u3, true, 0).slice(e6, o2.seekNext.call(u3, e6, false, false)).join("").replace(/'/g, ""), i6 = n5.indexOf(t6); i6 > 0 && " " === n5[i6 - 1]; ) i6--;
                                    var a3 = 0 === i6 && !o2.isMask.call(u3, e6) && (s2.getTest.call(u3, e6).match.nativeDef === t6.charAt(0) || true === s2.getTest.call(u3, e6).match.static && s2.getTest.call(u3, e6).match.nativeDef === "'" + t6.charAt(0) || " " === s2.getTest.call(u3, e6).match.nativeDef && (s2.getTest.call(u3, e6 + 1).match.nativeDef === t6.charAt(0) || true === s2.getTest.call(u3, e6 + 1).match.static && s2.getTest.call(u3, e6 + 1).match.nativeDef === "'" + t6.charAt(0)));
                                    if (!a3 && i6 > 0 && !o2.isMask.call(u3, e6, false, true)) {
                                        var r5 = o2.seekNext.call(u3, e6);
                                        u3.caretPos.begin < r5 && (u3.caretPos = {
                                            begin: r5
                                        });
                                    }
                                    return a3;
                                }(g2, m2) ? (c3 = a2.EventHandlers.keypressEvent.call(u3, i5, true, false, n4, u3.caretPos.begin)) && (g2 = u3.caretPos.begin + 1, 
                                m2 = "") : c3 = a2.EventHandlers.keypressEvent.call(u3, i5, true, false, n4, r4 + 1), 
                                c3 ? (void 0 !== c3.pos && f3.validPositions[c3.pos] && true === f3.validPositions[c3.pos].match.static && void 0 === f3.validPositions[c3.pos].alternation && (k2.push(c3.pos), 
                                u3.isRTL || (c3.forwardPosition = c3.pos + 1)), p2.call(u3, void 0, o2.getBuffer.call(u3), c3.forwardPosition, i5, false), 
                                u3.caretPos = {
                                    begin: c3.forwardPosition,
                                    end: c3.forwardPosition
                                }, b2 = u3.caretPos) : void 0 === f3.validPositions[t5] && v2[t5] === s2.getPlaceholder.call(u3, t5) && o2.isMask.call(u3, t5, true) ? u3.caretPos.begin++ : u3.caretPos = b2;
                            }
                        })), k2.length > 0) {
                            var x2, w2, P2 = o2.seekNext.call(u3, -1, void 0, false);
                            if (!l2.isComplete.call(u3, o2.getBuffer.call(u3)) && k2.length <= P2 || l2.isComplete.call(u3, o2.getBuffer.call(u3)) && k2.length > 0 && k2.length !== P2 && 0 === k2[0]) for (var S2 = P2; void 0 !== (x2 = k2.shift()); ) if (x2 < S2) {
                                var O2 = new h2.Event("_checkval");
                                if ((w2 = f3.validPositions[x2]).generatedInput = true, O2.key = w2.input, (c3 = a2.EventHandlers.keypressEvent.call(u3, O2, true, false, n4, S2)) && void 0 !== c3.pos && c3.pos !== x2 && f3.validPositions[c3.pos] && true === f3.validPositions[c3.pos].match.static) k2.push(c3.pos); else if (!c3) break;
                                S2++;
                            }
                        }
                        t4 && p2.call(u3, e4, o2.getBuffer.call(u3), c3 ? c3.forwardPosition : u3.caretPos.begin, r3 || new h2.Event("checkval"), r3 && ("input" === r3.type && u3.undoValue !== o2.getBuffer.call(u3).join("") || "paste" === r3.type)), 
                        d2.skipOptionalPartCharacter = y2;
                    }
                    function p2(e4, t4, n4, i4, a3) {
                        var s3 = e4 ? e4.inputmask : this, c3 = s3.opts, u3 = s3.dependencyLib;
                        if (i4 && "function" == typeof c3.onBeforeWrite) {
                            var f3 = c3.onBeforeWrite.call(s3, i4, t4, n4, c3);
                            if (f3) {
                                if (f3.refreshFromBuffer) {
                                    var p3 = f3.refreshFromBuffer;
                                    l2.refreshFromBuffer.call(s3, true === p3 ? p3 : p3.start, p3.end, f3.buffer || t4), 
                                    t4 = o2.getBuffer.call(s3, true);
                                }
                                void 0 !== n4 && (n4 = void 0 !== f3.caret ? f3.caret : n4);
                            }
                        }
                        if (void 0 !== e4 && (e4.inputmask._valueSet(t4.join("")), void 0 === n4 || void 0 !== i4 && "blur" === i4.type || o2.caret.call(s3, e4, n4, void 0, void 0, void 0 !== i4 && "keydown" === i4.type && (i4.key === r2.keys.Delete || i4.key === r2.keys.Backspace)), 
                        void 0 === e4.inputmask.writeBufferHook || e4.inputmask.writeBufferHook(n4), true === a3)) {
                            var d2 = u3(e4), h2 = e4.inputmask._valueGet();
                            e4.inputmask.skipInputEvent = true, d2.trigger("input"), setTimeout((function() {
                                h2 === o2.getBufferTemplate.call(s3).join("") ? d2.trigger("cleared") : true === l2.isComplete.call(s3, t4) && d2.trigger("complete");
                            }), 0);
                        }
                    }
                },
                2394: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.default = void 0;
                    var i3 = v2(n3(3976)), a2 = v2(n3(7392)), r2 = v2(n3(4963)), o2 = n3(9716), l2 = v2(n3(9380)), s2 = n3(7760), c2 = n3(157), u2 = n3(2391), f2 = n3(8711), p2 = n3(7215), d2 = n3(4713);
                    function h2(e4) {
                        return h2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
                            return typeof e5;
                        } : function(e5) {
                            return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                        }, h2(e4);
                    }
                    function v2(e4) {
                        return e4 && e4.__esModule ? e4 : {
                            default: e4
                        };
                    }
                    var m2 = l2.default.document, g2 = "_inputmask_opts";
                    function y2(e4, t4, n4) {
                        if (!(this instanceof y2)) return new y2(e4, t4, n4);
                        this.dependencyLib = r2.default, this.el = void 0, this.events = {}, this.maskset = void 0, 
                        true !== n4 && ("[object Object]" === Object.prototype.toString.call(e4) ? t4 = e4 : (t4 = t4 || {}, 
                        e4 && (t4.alias = e4)), this.opts = r2.default.extend(true, {}, this.defaults, t4), 
                        this.noMasksCache = t4 && void 0 !== t4.definitions, this.userOptions = t4 || {}, 
                        k2(this.opts.alias, t4, this.opts)), this.refreshValue = false, this.undoValue = void 0, 
                        this.$el = void 0, this.skipInputEvent = false, this.validationEvent = false, this.ignorable = false, 
                        this.maxLength, this.mouseEnter = false, this.clicked = 0, this.originalPlaceholder = void 0, 
                        this.isComposing = false, this.hasAlternator = false;
                    }
                    function k2(e4, t4, n4) {
                        var i4 = y2.prototype.aliases[e4];
                        return i4 ? (i4.alias && k2(i4.alias, void 0, n4), r2.default.extend(true, n4, i4), 
                        r2.default.extend(true, n4, t4), true) : (null === n4.mask && (n4.mask = e4), false);
                    }
                    y2.prototype = {
                        dataAttribute: "data-inputmask",
                        defaults: i3.default,
                        definitions: a2.default,
                        aliases: {},
                        masksCache: {},
                        i18n: {},
                        get isRTL() {
                            return this.opts.isRTL || this.opts.numericInput;
                        },
                        mask: function(e4) {
                            var t4 = this;
                            return "string" == typeof e4 && (e4 = m2.getElementById(e4) || m2.querySelectorAll(e4)), 
                            (e4 = e4.nodeName ? [ e4 ] : Array.isArray(e4) ? e4 : [].slice.call(e4)).forEach((function(e5, n4) {
                                var i4 = r2.default.extend(true, {}, t4.opts);
                                if (function(e6, t5, n5, i5) {
                                    function a4(t6, a5) {
                                        var r3 = "" === i5 ? t6 : i5 + "-" + t6;
                                        null !== (a5 = void 0 !== a5 ? a5 : e6.getAttribute(r3)) && ("string" == typeof a5 && (0 === t6.indexOf("on") ? a5 = l2.default[a5] : "false" === a5 ? a5 = false : "true" === a5 && (a5 = true)), 
                                        n5[t6] = a5);
                                    }
                                    if (true === t5.importDataAttributes) {
                                        var o3, s3, c3, u3, f3 = e6.getAttribute(i5);
                                        if (f3 && "" !== f3 && (f3 = f3.replace(/'/g, '"'), s3 = JSON.parse("{" + f3 + "}")), 
                                        s3) for (u3 in c3 = void 0, s3) if ("alias" === u3.toLowerCase()) {
                                            c3 = s3[u3];
                                            break;
                                        }
                                        for (o3 in a4("alias", c3), n5.alias && k2(n5.alias, n5, t5), t5) {
                                            if (s3) for (u3 in c3 = void 0, s3) if (u3.toLowerCase() === o3.toLowerCase()) {
                                                c3 = s3[u3];
                                                break;
                                            }
                                            a4(o3, c3);
                                        }
                                    }
                                    r2.default.extend(true, t5, n5), ("rtl" === e6.dir || t5.rightAlign) && (e6.style.textAlign = "right");
                                    ("rtl" === e6.dir || t5.numericInput) && (e6.dir = "ltr", e6.removeAttribute("dir"), 
                                    t5.isRTL = true);
                                    return Object.keys(n5).length;
                                }(e5, i4, r2.default.extend(true, {}, t4.userOptions), t4.dataAttribute)) {
                                    var a3 = (0, u2.generateMaskSet)(i4, t4.noMasksCache);
                                    void 0 !== a3 && (void 0 !== e5.inputmask && (e5.inputmask.opts.autoUnmask = true, 
                                    e5.inputmask.remove()), e5.inputmask = new y2(void 0, void 0, true), e5.inputmask.opts = i4, 
                                    e5.inputmask.noMasksCache = t4.noMasksCache, e5.inputmask.userOptions = r2.default.extend(true, {}, t4.userOptions), 
                                    e5.inputmask.el = e5, e5.inputmask.$el = (0, r2.default)(e5), e5.inputmask.maskset = a3, 
                                    r2.default.data(e5, g2, t4.userOptions), c2.mask.call(e5.inputmask));
                                }
                            })), e4 && e4[0] && e4[0].inputmask || this;
                        },
                        option: function(e4, t4) {
                            return "string" == typeof e4 ? this.opts[e4] : "object" === h2(e4) ? (r2.default.extend(this.userOptions, e4), 
                            this.el && true !== t4 && this.mask(this.el), this) : void 0;
                        },
                        unmaskedvalue: function(e4) {
                            if (this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), 
                            void 0 === this.el || void 0 !== e4) {
                                var t4 = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e4, this.opts) || e4).split("");
                                s2.checkVal.call(this, void 0, false, false, t4), "function" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, f2.getBuffer.call(this), 0, this.opts);
                            }
                            return s2.unmaskedvalue.call(this, this.el);
                        },
                        remove: function() {
                            if (this.el) {
                                r2.default.data(this.el, g2, null);
                                var e4 = this.opts.autoUnmask ? (0, s2.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
                                e4 !== f2.getBufferTemplate.call(this).join("") ? this._valueSet(e4, this.opts.autoUnmask) : this._valueSet(""), 
                                o2.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value") && this.__valueGet && Object.defineProperty(this.el, "value", {
                                    get: this.__valueGet,
                                    set: this.__valueSet,
                                    configurable: true
                                }) : m2.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet), 
                                this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0;
                            }
                            return this.el;
                        },
                        getemptymask: function() {
                            return this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), 
                            (this.isRTL ? f2.getBufferTemplate.call(this).reverse() : f2.getBufferTemplate.call(this)).join("");
                        },
                        hasMaskedValue: function() {
                            return !this.opts.autoUnmask;
                        },
                        isComplete: function() {
                            return this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), 
                            p2.isComplete.call(this, f2.getBuffer.call(this));
                        },
                        getmetadata: function() {
                            if (this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), 
                            Array.isArray(this.maskset.metadata)) {
                                var e4 = d2.getMaskTemplate.call(this, true, 0, false).join("");
                                return this.maskset.metadata.forEach((function(t4) {
                                    return t4.mask !== e4 || (e4 = t4, false);
                                })), e4;
                            }
                            return this.maskset.metadata;
                        },
                        isValid: function(e4) {
                            if (this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), 
                            e4) {
                                var t4 = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e4, this.opts) || e4).split("");
                                s2.checkVal.call(this, void 0, true, false, t4);
                            } else e4 = this.isRTL ? f2.getBuffer.call(this).slice().reverse().join("") : f2.getBuffer.call(this).join("");
                            for (var n4 = f2.getBuffer.call(this), i4 = f2.determineLastRequiredPosition.call(this), a3 = n4.length - 1; a3 > i4 && !f2.isMask.call(this, a3); a3--) ;
                            return n4.splice(i4, a3 + 1 - i4), p2.isComplete.call(this, n4) && e4 === (this.isRTL ? f2.getBuffer.call(this).slice().reverse().join("") : f2.getBuffer.call(this).join(""));
                        },
                        format: function(e4, t4) {
                            this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache);
                            var n4 = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e4, this.opts) || e4).split("");
                            s2.checkVal.call(this, void 0, true, false, n4);
                            var i4 = this.isRTL ? f2.getBuffer.call(this).slice().reverse().join("") : f2.getBuffer.call(this).join("");
                            return t4 ? {
                                value: i4,
                                metadata: this.getmetadata()
                            } : i4;
                        },
                        setValue: function(e4) {
                            this.el && (0, r2.default)(this.el).trigger("setvalue", [ e4 ]);
                        },
                        analyseMask: u2.analyseMask
                    }, y2.extendDefaults = function(e4) {
                        r2.default.extend(true, y2.prototype.defaults, e4);
                    }, y2.extendDefinitions = function(e4) {
                        r2.default.extend(true, y2.prototype.definitions, e4);
                    }, y2.extendAliases = function(e4) {
                        r2.default.extend(true, y2.prototype.aliases, e4);
                    }, y2.format = function(e4, t4, n4) {
                        return y2(t4).format(e4, n4);
                    }, y2.unmask = function(e4, t4) {
                        return y2(t4).unmaskedvalue(e4);
                    }, y2.isValid = function(e4, t4) {
                        return y2(t4).isValid(e4);
                    }, y2.remove = function(e4) {
                        "string" == typeof e4 && (e4 = m2.getElementById(e4) || m2.querySelectorAll(e4)), 
                        (e4 = e4.nodeName ? [ e4 ] : e4).forEach((function(e5) {
                            e5.inputmask && e5.inputmask.remove();
                        }));
                    }, y2.setValue = function(e4, t4) {
                        "string" == typeof e4 && (e4 = m2.getElementById(e4) || m2.querySelectorAll(e4)), 
                        (e4 = e4.nodeName ? [ e4 ] : e4).forEach((function(e5) {
                            e5.inputmask ? e5.inputmask.setValue(t4) : (0, r2.default)(e5).trigger("setvalue", [ t4 ]);
                        }));
                    }, y2.dependencyLib = r2.default, l2.default.Inputmask = y2;
                    t3.default = y2;
                },
                5296: function(e3, t3, n3) {
                    function i3(e4) {
                        return i3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
                            return typeof e5;
                        } : function(e5) {
                            return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                        }, i3(e4);
                    }
                    var a2 = d2(n3(9380)), r2 = d2(n3(2394));
                    function o2(e4, t4) {
                        for (var n4 = 0; n4 < t4.length; n4++) {
                            var a3 = t4[n4];
                            a3.enumerable = a3.enumerable || false, a3.configurable = true, "value" in a3 && (a3.writable = true), 
                            Object.defineProperty(e4, (r3 = a3.key, o3 = void 0, o3 = function(e5, t5) {
                                if ("object" !== i3(e5) || null === e5) return e5;
                                var n5 = e5[Symbol.toPrimitive];
                                if (void 0 !== n5) {
                                    var a4 = n5.call(e5, t5 || "default");
                                    if ("object" !== i3(a4)) return a4;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return ("string" === t5 ? String : Number)(e5);
                            }(r3, "string"), "symbol" === i3(o3) ? o3 : String(o3)), a3);
                        }
                        var r3, o3;
                    }
                    function l2(e4) {
                        var t4 = u2();
                        return function() {
                            var n4, a3 = p2(e4);
                            if (t4) {
                                var r3 = p2(this).constructor;
                                n4 = Reflect.construct(a3, arguments, r3);
                            } else n4 = a3.apply(this, arguments);
                            return function(e5, t5) {
                                if (t5 && ("object" === i3(t5) || "function" == typeof t5)) return t5;
                                if (void 0 !== t5) throw new TypeError("Derived constructors may only return object or undefined");
                                return function(e6) {
                                    if (void 0 === e6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                    return e6;
                                }(e5);
                            }(this, n4);
                        };
                    }
                    function s2(e4) {
                        var t4 = "function" == typeof Map ?  new Map : void 0;
                        return s2 = function(e5) {
                            if (null === e5 || !function(e6) {
                                try {
                                    return -1 !== Function.toString.call(e6).indexOf("[native code]");
                                } catch (t5) {
                                    return "function" == typeof e6;
                                }
                            }(e5)) return e5;
                            if ("function" != typeof e5) throw new TypeError("Super expression must either be null or a function");
                            if (void 0 !== t4) {
                                if (t4.has(e5)) return t4.get(e5);
                                t4.set(e5, n4);
                            }
                            function n4() {
                                return c2(e5, arguments, p2(this).constructor);
                            }
                            return n4.prototype = Object.create(e5.prototype, {
                                constructor: {
                                    value: n4,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            }), f2(n4, e5);
                        }, s2(e4);
                    }
                    function c2(e4, t4, n4) {
                        return c2 = u2() ? Reflect.construct.bind() : function(e5, t5, n5) {
                            var i4 = [ null ];
                            i4.push.apply(i4, t5);
                            var a3 = new (Function.bind.apply(e5, i4));
                            return n5 && f2(a3, n5.prototype), a3;
                        }, c2.apply(null, arguments);
                    }
                    function u2() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                        if (Reflect.construct.sham) return false;
                        if ("function" == typeof Proxy) return true;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), 
                            true;
                        } catch (e4) {
                            return false;
                        }
                    }
                    function f2(e4, t4) {
                        return f2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
                            return e5.__proto__ = t5, e5;
                        }, f2(e4, t4);
                    }
                    function p2(e4) {
                        return p2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e5) {
                            return e5.__proto__ || Object.getPrototypeOf(e5);
                        }, p2(e4);
                    }
                    function d2(e4) {
                        return e4 && e4.__esModule ? e4 : {
                            default: e4
                        };
                    }
                    var h2 = a2.default.document;
                    if (h2 && h2.head && h2.head.attachShadow && a2.default.customElements && void 0 === a2.default.customElements.get("input-mask")) {
                        var v2 = function(e4) {
                            !function(e5, t5) {
                                if ("function" != typeof t5 && null !== t5) throw new TypeError("Super expression must either be null or a function");
                                e5.prototype = Object.create(t5 && t5.prototype, {
                                    constructor: {
                                        value: e5,
                                        writable: true,
                                        configurable: true
                                    }
                                }), Object.defineProperty(e5, "prototype", {
                                    writable: false
                                }), t5 && f2(e5, t5);
                            }(s3, e4);
                            var t4, n4, a3 = l2(s3);
                            function s3() {
                                var e5;
                                !function(e6, t6) {
                                    if (!(e6 instanceof t6)) throw new TypeError("Cannot call a class as a function");
                                }(this, s3);
                                var t5 = (e5 = a3.call(this)).getAttributeNames(), n5 = e5.attachShadow({
                                    mode: "closed"
                                });
                                for (var i4 in e5.input = h2.createElement("input"), e5.input.type = "text", n5.appendChild(e5.input), 
                                t5) Object.prototype.hasOwnProperty.call(t5, i4) && e5.input.setAttribute(t5[i4], e5.getAttribute(t5[i4]));
                                var o3 = new r2.default;
                                return o3.dataAttribute = "", o3.mask(e5.input), e5.input.inputmask.shadowRoot = n5, 
                                e5;
                            }
                            return t4 = s3, (n4 = [ {
                                key: "attributeChangedCallback",
                                value: function(e5, t5, n5) {
                                    this.input.setAttribute(e5, n5);
                                }
                            }, {
                                key: "value",
                                get: function() {
                                    return this.input.value;
                                },
                                set: function(e5) {
                                    this.input.value = e5;
                                }
                            } ]) && o2(t4.prototype, n4), Object.defineProperty(t4, "prototype", {
                                writable: false
                            }), s3;
                        }(s2(HTMLElement));
                        a2.default.customElements.define("input-mask", v2);
                    }
                },
                2839: function(e3, t3) {
                    function n3(e4) {
                        return n3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
                            return typeof e5;
                        } : function(e5) {
                            return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                        }, n3(e4);
                    }
                    function i3(e4, t4) {
                        return function(e5) {
                            if (Array.isArray(e5)) return e5;
                        }(e4) || function(e5, t5) {
                            var n4 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
                            if (null != n4) {
                                var i4, a3, r3, o3, l3 = [], s3 = true, c2 = false;
                                try {
                                    if (r3 = (n4 = n4.call(e5)).next, 0 === t5) ; else for (;!(s3 = (i4 = r3.call(n4)).done) && (l3.push(i4.value), 
                                    l3.length !== t5); s3 = true) ;
                                } catch (e6) {
                                    c2 = true, a3 = e6;
                                } finally {
                                    try {
                                        if (!s3 && null != n4.return && (o3 = n4.return(), Object(o3) !== o3)) return;
                                    } finally {
                                        if (c2) throw a3;
                                    }
                                }
                                return l3;
                            }
                        }(e4, t4) || function(e5, t5) {
                            if (!e5) return;
                            if ("string" == typeof e5) return a2(e5, t5);
                            var n4 = Object.prototype.toString.call(e5).slice(8, -1);
                            "Object" === n4 && e5.constructor && (n4 = e5.constructor.name);
                            if ("Map" === n4 || "Set" === n4) return Array.from(e5);
                            if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4)) return a2(e5, t5);
                        }(e4, t4) || function() {
                            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }();
                    }
                    function a2(e4, t4) {
                        (null == t4 || t4 > e4.length) && (t4 = e4.length);
                        for (var n4 = 0, i4 = new Array(t4); n4 < t4; n4++) i4[n4] = e4[n4];
                        return i4;
                    }
                    function r2(e4, t4) {
                        var n4 = Object.keys(e4);
                        if (Object.getOwnPropertySymbols) {
                            var i4 = Object.getOwnPropertySymbols(e4);
                            t4 && (i4 = i4.filter((function(t5) {
                                return Object.getOwnPropertyDescriptor(e4, t5).enumerable;
                            }))), n4.push.apply(n4, i4);
                        }
                        return n4;
                    }
                    function o2(e4, t4, i4) {
                        return (t4 = function(e5) {
                            var t5 = function(e6, t6) {
                                if ("object" !== n3(e6) || null === e6) return e6;
                                var i5 = e6[Symbol.toPrimitive];
                                if (void 0 !== i5) {
                                    var a3 = i5.call(e6, t6 || "default");
                                    if ("object" !== n3(a3)) return a3;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return ("string" === t6 ? String : Number)(e6);
                            }(e5, "string");
                            return "symbol" === n3(t5) ? t5 : String(t5);
                        }(t4)) in e4 ? Object.defineProperty(e4, t4, {
                            value: i4,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        }) : e4[t4] = i4, e4;
                    }
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.keys = t3.keyCode = void 0, t3.toKey = function(e4, t4) {
                        return s2[e4] || (t4 ? String.fromCharCode(e4) : String.fromCharCode(e4).toLowerCase());
                    }, t3.toKeyCode = function(e4) {
                        return l2[e4];
                    };
                    var l2 = t3.keyCode = function(e4) {
                        for (var t4 = 1; t4 < arguments.length; t4++) {
                            var n4 = null != arguments[t4] ? arguments[t4] : {};
                            t4 % 2 ? r2(Object(n4), true).forEach((function(t5) {
                                o2(e4, t5, n4[t5]);
                            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n4)) : r2(Object(n4)).forEach((function(t5) {
                                Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(n4, t5));
                            }));
                        }
                        return e4;
                    }({
                        c: 67,
                        x: 88,
                        z: 90,
                        BACKSPACE_SAFARI: 127,
                        Enter: 13,
                        Meta_LEFT: 91,
                        Meta_RIGHT: 92,
                        Space: 32
                    }, {
                        Alt: 18,
                        AltGraph: 18,
                        ArrowDown: 40,
                        ArrowLeft: 37,
                        ArrowRight: 39,
                        ArrowUp: 38,
                        Backspace: 8,
                        CapsLock: 20,
                        Control: 17,
                        ContextMenu: 93,
                        Dead: 221,
                        Delete: 46,
                        End: 35,
                        Escape: 27,
                        F1: 112,
                        F2: 113,
                        F3: 114,
                        F4: 115,
                        F5: 116,
                        F6: 117,
                        F7: 118,
                        F8: 119,
                        F9: 120,
                        F10: 121,
                        F11: 122,
                        F12: 123,
                        Home: 36,
                        Insert: 45,
                        NumLock: 144,
                        PageDown: 34,
                        PageUp: 33,
                        Pause: 19,
                        PrintScreen: 44,
                        Process: 229,
                        Shift: 16,
                        ScrollLock: 145,
                        Tab: 9,
                        Unidentified: 229
                    }), s2 = Object.entries(l2).reduce((function(e4, t4) {
                        var n4 = i3(t4, 2), a3 = n4[0], r3 = n4[1];
                        return e4[r3] = void 0 === e4[r3] ? a3 : e4[r3], e4;
                    }), {});
                    t3.keys = Object.entries(l2).reduce((function(e4, t4) {
                        var n4 = i3(t4, 2), a3 = n4[0];
                        n4[1];
                        return e4[a3] = "Space" === a3 ? " " : a3, e4;
                    }), {});
                },
                2391: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.analyseMask = function(e4, t4, n4) {
                        var i4, a3, s3, c3, u2, f2, p2 = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g, d2 = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, h2 = false, v2 = new o2.default, m2 = [], g2 = [], y2 = false;
                        function k2(e5, i5, a4) {
                            a4 = void 0 !== a4 ? a4 : e5.matches.length;
                            var o3 = e5.matches[a4 - 1];
                            if (t4) {
                                if (0 === i5.indexOf("[") || h2 && /\\d|\\s|\\w|\\p/i.test(i5) || "." === i5) {
                                    var s4 = n4.casing ? "i" : "";
                                    /\\p\{.*}/i.test(i5) && (s4 += "u"), e5.matches.splice(a4++, 0, {
                                        fn: new RegExp(i5, s4),
                                        static: false,
                                        optionality: false,
                                        newBlockMarker: void 0 === o3 ? "master" : o3.def !== i5,
                                        casing: null,
                                        def: i5,
                                        placeholder: "object" === l2(n4.placeholder) ? n4.placeholder[v2.matches.length] : void 0,
                                        nativeDef: i5
                                    });
                                } else h2 && (i5 = i5[i5.length - 1]), i5.split("").forEach((function(t5, i6) {
                                    o3 = e5.matches[a4 - 1], e5.matches.splice(a4++, 0, {
                                        fn: /[a-z]/i.test(n4.staticDefinitionSymbol || t5) ? new RegExp("[" + (n4.staticDefinitionSymbol || t5) + "]", n4.casing ? "i" : "") : null,
                                        static: true,
                                        optionality: false,
                                        newBlockMarker: void 0 === o3 ? "master" : o3.def !== t5 && true !== o3.static,
                                        casing: null,
                                        def: n4.staticDefinitionSymbol || t5,
                                        placeholder: void 0 !== n4.staticDefinitionSymbol ? t5 : "object" === l2(n4.placeholder) ? n4.placeholder[v2.matches.length] : void 0,
                                        nativeDef: (h2 ? "'" : "") + t5
                                    });
                                }));
                                h2 = false;
                            } else {
                                var c4 = n4.definitions && n4.definitions[i5] || n4.usePrototypeDefinitions && r2.default.prototype.definitions[i5];
                                c4 && !h2 ? e5.matches.splice(a4++, 0, {
                                    fn: c4.validator ? "string" == typeof c4.validator ? new RegExp(c4.validator, n4.casing ? "i" : "") : new function() {
                                        this.test = c4.validator;
                                    } : /./,
                                    static: c4.static || false,
                                    optionality: c4.optional || false,
                                    defOptionality: c4.optional || false,
                                    newBlockMarker: void 0 === o3 || c4.optional ? "master" : o3.def !== (c4.definitionSymbol || i5),
                                    casing: c4.casing,
                                    def: c4.definitionSymbol || i5,
                                    placeholder: c4.placeholder,
                                    nativeDef: i5,
                                    generated: c4.generated
                                }) : (e5.matches.splice(a4++, 0, {
                                    fn: /[a-z]/i.test(n4.staticDefinitionSymbol || i5) ? new RegExp("[" + (n4.staticDefinitionSymbol || i5) + "]", n4.casing ? "i" : "") : null,
                                    static: true,
                                    optionality: false,
                                    newBlockMarker: void 0 === o3 ? "master" : o3.def !== i5 && true !== o3.static,
                                    casing: null,
                                    def: n4.staticDefinitionSymbol || i5,
                                    placeholder: void 0 !== n4.staticDefinitionSymbol ? i5 : void 0,
                                    nativeDef: (h2 ? "'" : "") + i5
                                }), h2 = false);
                            }
                        }
                        function b2() {
                            if (m2.length > 0) {
                                if (k2(c3 = m2[m2.length - 1], a3), c3.isAlternator) {
                                    u2 = m2.pop();
                                    for (var e5 = 0; e5 < u2.matches.length; e5++) u2.matches[e5].isGroup && (u2.matches[e5].isGroup = false);
                                    m2.length > 0 ? (c3 = m2[m2.length - 1]).matches.push(u2) : v2.matches.push(u2);
                                }
                            } else k2(v2, a3);
                        }
                        function x2(e5) {
                            var t5 = new o2.default(true);
                            return t5.openGroup = false, t5.matches = e5, t5;
                        }
                        function w2() {
                            if ((s3 = m2.pop()).openGroup = false, void 0 !== s3) if (m2.length > 0) {
                                if ((c3 = m2[m2.length - 1]).matches.push(s3), c3.isAlternator) {
                                    u2 = m2.pop();
                                    for (var e5 = 0; e5 < u2.matches.length; e5++) u2.matches[e5].isGroup = false, u2.matches[e5].alternatorGroup = false;
                                    m2.length > 0 ? (c3 = m2[m2.length - 1]).matches.push(u2) : v2.matches.push(u2);
                                }
                            } else v2.matches.push(s3); else b2();
                        }
                        function P2(e5) {
                            var t5 = e5.pop();
                            return t5.isQuantifier && (t5 = x2([ e5.pop(), t5 ])), t5;
                        }
                        t4 && (n4.optionalmarker[0] = void 0, n4.optionalmarker[1] = void 0);
                        for (;i4 = t4 ? d2.exec(e4) : p2.exec(e4); ) {
                            if (a3 = i4[0], t4) {
                                switch (a3.charAt(0)) {
                                  case "?":
                                    a3 = "{0,1}";
                                    break;

                                  case "+":
                                  case "*":
                                    a3 = "{" + a3 + "}";
                                    break;

                                  case "|":
                                    if (0 === m2.length) {
                                        var S2 = x2(v2.matches);
                                        S2.openGroup = true, m2.push(S2), v2.matches = [], y2 = true;
                                    }
                                }
                                switch (a3) {
                                  case "\\d":
                                    a3 = "[0-9]";
                                    break;

                                  case "\\p":
                                    a3 += d2.exec(e4)[0], a3 += d2.exec(e4)[0];
                                }
                            }
                            if (h2) b2(); else switch (a3.charAt(0)) {
                              case "$":
                              case "^":
                                t4 || b2();
                                break;

                              case n4.escapeChar:
                                h2 = true, t4 && b2();
                                break;

                              case n4.optionalmarker[1]:
                              case n4.groupmarker[1]:
                                w2();
                                break;

                              case n4.optionalmarker[0]:
                                m2.push(new o2.default(false, true));
                                break;

                              case n4.groupmarker[0]:
                                m2.push(new o2.default(true));
                                break;

                              case n4.quantifiermarker[0]:
                                var O2 = new o2.default(false, false, true), _2 = (a3 = a3.replace(/[{}?]/g, "")).split("|"), M2 = _2[0].split(","), E2 = isNaN(M2[0]) ? M2[0] : parseInt(M2[0]), j2 = 1 === M2.length ? E2 : isNaN(M2[1]) ? M2[1] : parseInt(M2[1]), T2 = isNaN(_2[1]) ? _2[1] : parseInt(_2[1]);
                                "*" !== E2 && "+" !== E2 || (E2 = "*" === j2 ? 0 : 1), O2.quantifier = {
                                    min: E2,
                                    max: j2,
                                    jit: T2
                                };
                                var A2 = m2.length > 0 ? m2[m2.length - 1].matches : v2.matches;
                                (i4 = A2.pop()).isGroup || (i4 = x2([ i4 ])), A2.push(i4), A2.push(O2);
                                break;

                              case n4.alternatormarker:
                                if (m2.length > 0) {
                                    var D2 = (c3 = m2[m2.length - 1]).matches[c3.matches.length - 1];
                                    f2 = c3.openGroup && (void 0 === D2.matches || false === D2.isGroup && false === D2.isAlternator) ? m2.pop() : P2(c3.matches);
                                } else f2 = P2(v2.matches);
                                if (f2.isAlternator) m2.push(f2); else if (f2.alternatorGroup ? (u2 = m2.pop(), 
                                f2.alternatorGroup = false) : u2 = new o2.default(false, false, false, true), u2.matches.push(f2), 
                                m2.push(u2), f2.openGroup) {
                                    f2.openGroup = false;
                                    var L2 = new o2.default(true);
                                    L2.alternatorGroup = true, m2.push(L2);
                                }
                                break;

                              default:
                                b2();
                            }
                        }
                        y2 && w2();
                        for (;m2.length > 0; ) s3 = m2.pop(), v2.matches.push(s3);
                        v2.matches.length > 0 && (!function e5(i5) {
                            i5 && i5.matches && i5.matches.forEach((function(a4, r3) {
                                var o3 = i5.matches[r3 + 1];
                                (void 0 === o3 || void 0 === o3.matches || false === o3.isQuantifier) && a4 && a4.isGroup && (a4.isGroup = false, 
                                t4 || (k2(a4, n4.groupmarker[0], 0), true !== a4.openGroup && k2(a4, n4.groupmarker[1]))), 
                                e5(a4);
                            }));
                        }(v2), g2.push(v2));
                        (n4.numericInput || n4.isRTL) && function e5(t5) {
                            for (var i5 in t5.matches = t5.matches.reverse(), t5.matches) if (Object.prototype.hasOwnProperty.call(t5.matches, i5)) {
                                var a4 = parseInt(i5);
                                if (t5.matches[i5].isQuantifier && t5.matches[a4 + 1] && t5.matches[a4 + 1].isGroup) {
                                    var r3 = t5.matches[i5];
                                    t5.matches.splice(i5, 1), t5.matches.splice(a4 + 1, 0, r3);
                                }
                                void 0 !== t5.matches[i5].matches ? t5.matches[i5] = e5(t5.matches[i5]) : t5.matches[i5] = ((o3 = t5.matches[i5]) === n4.optionalmarker[0] ? o3 = n4.optionalmarker[1] : o3 === n4.optionalmarker[1] ? o3 = n4.optionalmarker[0] : o3 === n4.groupmarker[0] ? o3 = n4.groupmarker[1] : o3 === n4.groupmarker[1] && (o3 = n4.groupmarker[0]), 
                                o3);
                            }
                            var o3;
                            return t5;
                        }(g2[0]);
                        return g2;
                    }, t3.generateMaskSet = function(e4, t4) {
                        var n4;
                        function o3(e5, t5) {
                            var n5 = t5.repeat, i4 = t5.groupmarker, r3 = t5.quantifiermarker, o4 = t5.keepStatic;
                            if (n5 > 0 || "*" === n5 || "+" === n5) {
                                var l3 = "*" === n5 ? 0 : "+" === n5 ? 1 : n5;
                                if (l3 != n5) e5 = i4[0] + e5 + i4[1] + r3[0] + l3 + "," + n5 + r3[1]; else for (var c4 = e5, u3 = 1; u3 < l3; u3++) e5 += c4;
                            }
                            if (true === o4) {
                                var f2 = e5.match(new RegExp("(.)\\[([^\\]]*)\\]", "g"));
                                f2 && f2.forEach((function(t6, n6) {
                                    var i5 = function(e6, t7) {
                                        return function(e7) {
                                            if (Array.isArray(e7)) return e7;
                                        }(e6) || function(e7, t8) {
                                            var n7 = null == e7 ? null : "undefined" != typeof Symbol && e7[Symbol.iterator] || e7["@@iterator"];
                                            if (null != n7) {
                                                var i6, a3, r5, o6, l4 = [], s3 = true, c5 = false;
                                                try {
                                                    if (r5 = (n7 = n7.call(e7)).next, 0 === t8) ; else for (;!(s3 = (i6 = r5.call(n7)).done) && (l4.push(i6.value), 
                                                    l4.length !== t8); s3 = true) ;
                                                } catch (e8) {
                                                    c5 = true, a3 = e8;
                                                } finally {
                                                    try {
                                                        if (!s3 && null != n7.return && (o6 = n7.return(), Object(o6) !== o6)) return;
                                                    } finally {
                                                        if (c5) throw a3;
                                                    }
                                                }
                                                return l4;
                                            }
                                        }(e6, t7) || function(e7, t8) {
                                            if (!e7) return;
                                            if ("string" == typeof e7) return s2(e7, t8);
                                            var n7 = Object.prototype.toString.call(e7).slice(8, -1);
                                            "Object" === n7 && e7.constructor && (n7 = e7.constructor.name);
                                            if ("Map" === n7 || "Set" === n7) return Array.from(e7);
                                            if ("Arguments" === n7 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n7)) return s2(e7, t8);
                                        }(e6, t7) || function() {
                                            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                        }();
                                    }(t6.split("["), 2), r4 = i5[0], o5 = i5[1];
                                    o5 = o5.replace("]", ""), e5 = e5.replace(new RegExp("".concat((0, a2.default)(r4), "\\[").concat((0, 
                                    a2.default)(o5), "\\]")), r4.charAt(0) === o5.charAt(0) ? "(".concat(r4, "|").concat(r4).concat(o5, ")") : "".concat(r4, "[").concat(o5, "]"));
                                }));
                            }
                            return e5;
                        }
                        function c3(e5, n5, a3) {
                            var s3, c4, u3 = false;
                            return null !== e5 && "" !== e5 || ((u3 = null !== a3.regex) ? e5 = (e5 = a3.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (u3 = true, 
                            e5 = ".*")), 1 === e5.length && false === a3.greedy && 0 !== a3.repeat && (a3.placeholder = ""), 
                            e5 = o3(e5, a3), c4 = u3 ? "regex_" + a3.regex : a3.numericInput ? e5.split("").reverse().join("") : e5, 
                            null !== a3.keepStatic && (c4 = "ks_" + a3.keepStatic + c4), "object" === l2(a3.placeholder) && (c4 = "ph_" + JSON.stringify(a3.placeholder) + c4), 
                            void 0 === r2.default.prototype.masksCache[c4] || true === t4 ? (s3 = {
                                mask: e5,
                                maskToken: r2.default.prototype.analyseMask(e5, u3, a3),
                                validPositions: [],
                                _buffer: void 0,
                                buffer: void 0,
                                tests: {},
                                excludes: {},
                                metadata: n5,
                                maskLength: void 0,
                                jitOffset: {}
                            }, true !== t4 && (r2.default.prototype.masksCache[c4] = s3, s3 = i3.default.extend(true, {}, r2.default.prototype.masksCache[c4]))) : s3 = i3.default.extend(true, {}, r2.default.prototype.masksCache[c4]), 
                            s3;
                        }
                        "function" == typeof e4.mask && (e4.mask = e4.mask(e4));
                        if (Array.isArray(e4.mask)) {
                            if (e4.mask.length > 1) {
                                null === e4.keepStatic && (e4.keepStatic = true);
                                var u2 = e4.groupmarker[0];
                                return (e4.isRTL ? e4.mask.reverse() : e4.mask).forEach((function(t5) {
                                    u2.length > 1 && (u2 += e4.alternatormarker), void 0 !== t5.mask && "function" != typeof t5.mask ? u2 += t5.mask : u2 += t5;
                                })), c3(u2 += e4.groupmarker[1], e4.mask, e4);
                            }
                            e4.mask = e4.mask.pop();
                        }
                        n4 = e4.mask && void 0 !== e4.mask.mask && "function" != typeof e4.mask.mask ? c3(e4.mask.mask, e4.mask, e4) : c3(e4.mask, e4.mask, e4);
                        null === e4.keepStatic && (e4.keepStatic = false);
                        return n4;
                    };
                    var i3 = c2(n3(4963)), a2 = c2(n3(7184)), r2 = c2(n3(2394)), o2 = c2(n3(9695));
                    function l2(e4) {
                        return l2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
                            return typeof e5;
                        } : function(e5) {
                            return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                        }, l2(e4);
                    }
                    function s2(e4, t4) {
                        (null == t4 || t4 > e4.length) && (t4 = e4.length);
                        for (var n4 = 0, i4 = new Array(t4); n4 < t4; n4++) i4[n4] = e4[n4];
                        return i4;
                    }
                    function c2(e4) {
                        return e4 && e4.__esModule ? e4 : {
                            default: e4
                        };
                    }
                },
                157: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.mask = function() {
                        var e4 = this, t4 = this.opts, n4 = this.el, c2 = this.dependencyLib;
                        r2.EventRuler.off(n4);
                        var u2 = function(t5, n5) {
                            var i4 = t5.getAttribute("type"), a3 = "input" === t5.tagName.toLowerCase() && n5.supportsInputType.includes(i4) || t5.isContentEditable || "textarea" === t5.tagName.toLowerCase();
                            if (!a3) if ("input" === t5.tagName.toLowerCase()) {
                                var s3 = document.createElement("input");
                                s3.setAttribute("type", i4), a3 = "text" === s3.type, s3 = null;
                            } else a3 = "partial";
                            return false !== a3 ? function(t6) {
                                var i5, a4;
                                function s4() {
                                    return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== l2.getLastValidPosition.call(e4) || true !== n5.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && n5.clearMaskOnLostFocus ? (e4.isRTL ? o2.clearOptionalTail.call(e4, l2.getBuffer.call(e4).slice()).reverse() : o2.clearOptionalTail.call(e4, l2.getBuffer.call(e4).slice())).join("") : i5.call(this) : "" : i5.call(this);
                                }
                                function u3(e5) {
                                    a4.call(this, e5), this.inputmask && (0, o2.applyInputValue)(this, e5);
                                }
                                if (!t6.inputmask.__valueGet) {
                                    if (true !== n5.noValuePatching) {
                                        if (Object.getOwnPropertyDescriptor) {
                                            var f3 = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t6), "value") : void 0;
                                            f3 && f3.get && f3.set ? (i5 = f3.get, a4 = f3.set, Object.defineProperty(t6, "value", {
                                                get: s4,
                                                set: u3,
                                                configurable: true
                                            })) : "input" !== t6.tagName.toLowerCase() && (i5 = function() {
                                                return this.textContent;
                                            }, a4 = function(e5) {
                                                this.textContent = e5;
                                            }, Object.defineProperty(t6, "value", {
                                                get: s4,
                                                set: u3,
                                                configurable: true
                                            }));
                                        } else document.__lookupGetter__ && t6.__lookupGetter__("value") && (i5 = t6.__lookupGetter__("value"), 
                                        a4 = t6.__lookupSetter__("value"), t6.__defineGetter__("value", s4), t6.__defineSetter__("value", u3));
                                        t6.inputmask.__valueGet = i5, t6.inputmask.__valueSet = a4;
                                    }
                                    t6.inputmask._valueGet = function(t7) {
                                        return e4.isRTL && true !== t7 ? i5.call(this.el).split("").reverse().join("") : i5.call(this.el);
                                    }, t6.inputmask._valueSet = function(t7, n6) {
                                        a4.call(this.el, null == t7 ? "" : true !== n6 && e4.isRTL ? t7.split("").reverse().join("") : t7);
                                    }, void 0 === i5 && (i5 = function() {
                                        return this.value;
                                    }, a4 = function(e5) {
                                        this.value = e5;
                                    }, function(t7) {
                                        if (c2.valHooks && (void 0 === c2.valHooks[t7] || true !== c2.valHooks[t7].inputmaskpatch)) {
                                            var i6 = c2.valHooks[t7] && c2.valHooks[t7].get ? c2.valHooks[t7].get : function(e5) {
                                                return e5.value;
                                            }, a5 = c2.valHooks[t7] && c2.valHooks[t7].set ? c2.valHooks[t7].set : function(e5, t8) {
                                                return e5.value = t8, e5;
                                            };
                                            c2.valHooks[t7] = {
                                                get: function(t8) {
                                                    if (t8.inputmask) {
                                                        if (t8.inputmask.opts.autoUnmask) return t8.inputmask.unmaskedvalue();
                                                        var a6 = i6(t8);
                                                        return -1 !== l2.getLastValidPosition.call(e4, void 0, void 0, t8.inputmask.maskset.validPositions) || true !== n5.nullable ? a6 : "";
                                                    }
                                                    return i6(t8);
                                                },
                                                set: function(e5, t8) {
                                                    var n6 = a5(e5, t8);
                                                    return e5.inputmask && (0, o2.applyInputValue)(e5, t8), n6;
                                                },
                                                inputmaskpatch: true
                                            };
                                        }
                                    }(t6.type), function(e5) {
                                        r2.EventRuler.on(e5, "mouseenter", (function() {
                                            var e6 = this, t7 = e6.inputmask._valueGet(true);
                                            t7 != (e6.inputmask.isRTL ? l2.getBuffer.call(e6.inputmask).slice().reverse() : l2.getBuffer.call(e6.inputmask)).join("") && (0, 
                                            o2.applyInputValue)(e6, t7);
                                        }));
                                    }(t6));
                                }
                            }(t5) : t5.inputmask = void 0, a3;
                        }(n4, t4);
                        if (false !== u2) {
                            e4.originalPlaceholder = n4.placeholder, e4.maxLength = void 0 !== n4 ? n4.maxLength : void 0, 
                            -1 === e4.maxLength && (e4.maxLength = void 0), "inputMode" in n4 && null === n4.getAttribute("inputmode") && (n4.inputMode = t4.inputmode, 
                            n4.setAttribute("inputmode", t4.inputmode)), true === u2 && (t4.showMaskOnFocus = t4.showMaskOnFocus && -1 === [ "cc-number", "cc-exp" ].indexOf(n4.autocomplete), 
                            i3.iphone && (t4.insertModeVisual = false, n4.setAttribute("autocorrect", "off")), 
                            r2.EventRuler.on(n4, "submit", a2.EventHandlers.submitEvent), r2.EventRuler.on(n4, "reset", a2.EventHandlers.resetEvent), 
                            r2.EventRuler.on(n4, "blur", a2.EventHandlers.blurEvent), r2.EventRuler.on(n4, "focus", a2.EventHandlers.focusEvent), 
                            r2.EventRuler.on(n4, "invalid", a2.EventHandlers.invalidEvent), r2.EventRuler.on(n4, "click", a2.EventHandlers.clickEvent), 
                            r2.EventRuler.on(n4, "mouseleave", a2.EventHandlers.mouseleaveEvent), r2.EventRuler.on(n4, "mouseenter", a2.EventHandlers.mouseenterEvent), 
                            r2.EventRuler.on(n4, "paste", a2.EventHandlers.pasteEvent), r2.EventRuler.on(n4, "cut", a2.EventHandlers.cutEvent), 
                            r2.EventRuler.on(n4, "complete", t4.oncomplete), r2.EventRuler.on(n4, "incomplete", t4.onincomplete), 
                            r2.EventRuler.on(n4, "cleared", t4.oncleared), true !== t4.inputEventOnly && r2.EventRuler.on(n4, "keydown", a2.EventHandlers.keyEvent), 
                            (i3.mobile || t4.inputEventOnly) && n4.removeAttribute("maxLength"), r2.EventRuler.on(n4, "input", a2.EventHandlers.inputFallBackEvent)), 
                            r2.EventRuler.on(n4, "setvalue", a2.EventHandlers.setValueEvent), void 0 === e4.applyMaskHook || e4.applyMaskHook(), 
                            l2.getBufferTemplate.call(e4).join(""), e4.undoValue = e4._valueGet(true);
                            var f2 = (n4.inputmask.shadowRoot || n4.ownerDocument).activeElement;
                            if ("" !== n4.inputmask._valueGet(true) || false === t4.clearMaskOnLostFocus || f2 === n4) {
                                (0, o2.applyInputValue)(n4, n4.inputmask._valueGet(true), t4);
                                var p2 = l2.getBuffer.call(e4).slice();
                                false === s2.isComplete.call(e4, p2) && t4.clearIncomplete && l2.resetMaskSet.call(e4, false), 
                                t4.clearMaskOnLostFocus && f2 !== n4 && (-1 === l2.getLastValidPosition.call(e4) ? p2 = [] : o2.clearOptionalTail.call(e4, p2)), 
                                (false === t4.clearMaskOnLostFocus || t4.showMaskOnFocus && f2 === n4 || "" !== n4.inputmask._valueGet(true)) && (0, 
                                o2.writeBuffer)(n4, p2), f2 === n4 && l2.caret.call(e4, n4, l2.seekNext.call(e4, l2.getLastValidPosition.call(e4)));
                            }
                        }
                    };
                    var i3 = n3(9845), a2 = n3(6030), r2 = n3(9716), o2 = n3(7760), l2 = n3(8711), s2 = n3(7215);
                },
                9695: function(e3, t3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.default = function(e4, t4, n3, i3) {
                        this.matches = [], this.openGroup = e4 || false, this.alternatorGroup = false, this.isGroup = e4 || false, 
                        this.isOptional = t4 || false, this.isQuantifier = n3 || false, this.isAlternator = i3 || false, 
                        this.quantifier = {
                            min: 1,
                            max: 1
                        };
                    };
                },
                3194: function() {
                    Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
                        value: function(e3, t3) {
                            if (null == this) throw new TypeError('"this" is null or not defined');
                            var n3 = Object(this), i3 = n3.length >>> 0;
                            if (0 === i3) return false;
                            for (var a2 = 0 | t3, r2 = Math.max(a2 >= 0 ? a2 : i3 - Math.abs(a2), 0); r2 < i3; ) {
                                if (n3[r2] === e3) return true;
                                r2++;
                            }
                            return false;
                        }
                    });
                },
                9302: function() {
                    var e3 = Function.bind.call(Function.call, Array.prototype.reduce), t3 = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable), n3 = Function.bind.call(Function.call, Array.prototype.concat), i3 = Object.keys;
                    Object.entries || (Object.entries = function(a2) {
                        return e3(i3(a2), (function(e4, i4) {
                            return n3(e4, "string" == typeof i4 && t3(a2, i4) ? [ [ i4, a2[i4] ] ] : []);
                        }), []);
                    });
                },
                7149: function() {
                    function e3(t3) {
                        return e3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
                            return typeof e4;
                        } : function(e4) {
                            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                        }, e3(t3);
                    }
                    "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === e3("test".__proto__) ? function(e4) {
                        return e4.__proto__;
                    } : function(e4) {
                        return e4.constructor.prototype;
                    });
                },
                4013: function() {
                    String.prototype.includes || (String.prototype.includes = function(e3, t3) {
                        return "number" != typeof t3 && (t3 = 0), !(t3 + e3.length > this.length) && -1 !== this.indexOf(e3, t3);
                    });
                },
                8711: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.caret = function(e4, t4, n4, i4, r3) {
                        var o3, l3 = this, s3 = this.opts;
                        if (void 0 === t4) return "selectionStart" in e4 && "selectionEnd" in e4 ? (t4 = e4.selectionStart, 
                        n4 = e4.selectionEnd) : a2.default.getSelection ? (o3 = a2.default.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e4 && o3.commonAncestorContainer !== e4 || (t4 = o3.startOffset, 
                        n4 = o3.endOffset) : document.selection && document.selection.createRange && (n4 = (t4 = 0 - (o3 = document.selection.createRange()).duplicate().moveStart("character", -e4.inputmask._valueGet().length)) + o3.text.length), 
                        {
                            begin: i4 ? t4 : f2.call(l3, t4),
                            end: i4 ? n4 : f2.call(l3, n4)
                        };
                        if (Array.isArray(t4) && (n4 = l3.isRTL ? t4[0] : t4[1], t4 = l3.isRTL ? t4[1] : t4[0]), 
                        void 0 !== t4.begin && (n4 = l3.isRTL ? t4.begin : t4.end, t4 = l3.isRTL ? t4.end : t4.begin), 
                        "number" == typeof t4) {
                            t4 = i4 ? t4 : f2.call(l3, t4), n4 = "number" == typeof (n4 = i4 ? n4 : f2.call(l3, n4)) ? n4 : t4;
                            var c3 = parseInt(((e4.ownerDocument.defaultView || a2.default).getComputedStyle ? (e4.ownerDocument.defaultView || a2.default).getComputedStyle(e4, null) : e4.currentStyle).fontSize) * n4;
                            if (e4.scrollLeft = c3 > e4.scrollWidth ? c3 : 0, e4.inputmask.caretPos = {
                                begin: t4,
                                end: n4
                            }, s3.insertModeVisual && false === s3.insertMode && t4 === n4 && (r3 || n4++), 
                            e4 === (e4.inputmask.shadowRoot || e4.ownerDocument).activeElement) {
                                if ("setSelectionRange" in e4) e4.setSelectionRange(t4, n4); else if (a2.default.getSelection) {
                                    if (o3 = document.createRange(), void 0 === e4.firstChild || null === e4.firstChild) {
                                        var u3 = document.createTextNode("");
                                        e4.appendChild(u3);
                                    }
                                    o3.setStart(e4.firstChild, t4 < e4.inputmask._valueGet().length ? t4 : e4.inputmask._valueGet().length), 
                                    o3.setEnd(e4.firstChild, n4 < e4.inputmask._valueGet().length ? n4 : e4.inputmask._valueGet().length), 
                                    o3.collapse(true);
                                    var p2 = a2.default.getSelection();
                                    p2.removeAllRanges(), p2.addRange(o3);
                                } else e4.createTextRange && ((o3 = e4.createTextRange()).collapse(true), o3.moveEnd("character", n4), 
                                o3.moveStart("character", t4), o3.select());
                                void 0 === e4.inputmask.caretHook || e4.inputmask.caretHook.call(l3, {
                                    begin: t4,
                                    end: n4
                                });
                            }
                        }
                    }, t3.determineLastRequiredPosition = function(e4) {
                        var t4, n4, i4 = this, a3 = i4.maskset, l3 = i4.dependencyLib, c3 = s2.call(i4), u3 = {}, f3 = a3.validPositions[c3], p2 = o2.getMaskTemplate.call(i4, true, s2.call(i4), true, true), d2 = p2.length, h2 = void 0 !== f3 ? f3.locator.slice() : void 0;
                        for (t4 = c3 + 1; t4 < p2.length; t4++) h2 = (n4 = o2.getTestTemplate.call(i4, t4, h2, t4 - 1)).locator.slice(), 
                        u3[t4] = l3.extend(true, {}, n4);
                        var v2 = f3 && void 0 !== f3.alternation ? f3.locator[f3.alternation] : void 0;
                        for (t4 = d2 - 1; t4 > c3 && ((n4 = u3[t4]).match.optionality || n4.match.optionalQuantifier && n4.match.newBlockMarker || v2 && (v2 !== u3[t4].locator[f3.alternation] && true !== n4.match.static || true === n4.match.static && n4.locator[f3.alternation] && r2.checkAlternationMatch.call(i4, n4.locator[f3.alternation].toString().split(","), v2.toString().split(",")) && "" !== o2.getTests.call(i4, t4)[0].def)) && p2[t4] === o2.getPlaceholder.call(i4, t4, n4.match); t4--) d2--;
                        return e4 ? {
                            l: d2,
                            def: u3[d2] ? u3[d2].match : void 0
                        } : d2;
                    }, t3.determineNewCaretPosition = function(e4, t4, n4) {
                        var i4, a3, r3, f3 = this, p2 = f3.maskset, d2 = f3.opts;
                        t4 && (f3.isRTL ? e4.end = e4.begin : e4.begin = e4.end);
                        if (e4.begin === e4.end) {
                            switch (n4 = n4 || d2.positionCaretOnClick) {
                              case "none":
                                break;

                              case "select":
                                e4 = {
                                    begin: 0,
                                    end: l2.call(f3).length
                                };
                                break;

                              case "ignore":
                                e4.end = e4.begin = u2.call(f3, s2.call(f3));
                                break;

                              case "radixFocus":
                                if (f3.clicked > 1 && 0 === p2.validPositions.length) break;
                                if (function(e5) {
                                    if ("" !== d2.radixPoint && 0 !== d2.digits) {
                                        var t5 = p2.validPositions;
                                        if (void 0 === t5[e5] || void 0 === t5[e5].input) {
                                            if (e5 < u2.call(f3, -1)) return true;
                                            var n5 = l2.call(f3).indexOf(d2.radixPoint);
                                            if (-1 !== n5) {
                                                for (var i5 = 0, a4 = t5.length; i5 < a4; i5++) if (t5[i5] && n5 < i5 && t5[i5].input !== o2.getPlaceholder.call(f3, i5)) return false;
                                                return true;
                                            }
                                        }
                                    }
                                    return false;
                                }(e4.begin)) {
                                    var h2 = l2.call(f3).join("").indexOf(d2.radixPoint);
                                    e4.end = e4.begin = d2.numericInput ? u2.call(f3, h2) : h2;
                                    break;
                                }

                              default:
                                if (i4 = e4.begin, a3 = s2.call(f3, i4, true), i4 <= (r3 = u2.call(f3, -1 !== a3 || c2.call(f3, 0) ? a3 : -1))) e4.end = e4.begin = c2.call(f3, i4, false, true) ? i4 : u2.call(f3, i4); else {
                                    var v2 = p2.validPositions[a3], m2 = o2.getTestTemplate.call(f3, r3, v2 ? v2.match.locator : void 0, v2), g2 = o2.getPlaceholder.call(f3, r3, m2.match);
                                    if ("" !== g2 && l2.call(f3)[r3] !== g2 && true !== m2.match.optionalQuantifier && true !== m2.match.newBlockMarker || !c2.call(f3, r3, d2.keepStatic, true) && m2.match.def === g2) {
                                        var y2 = u2.call(f3, r3);
                                        (i4 >= y2 || i4 === r3) && (r3 = y2);
                                    }
                                    e4.end = e4.begin = r3;
                                }
                            }
                            return e4;
                        }
                    }, t3.getBuffer = l2, t3.getBufferTemplate = function() {
                        var e4 = this.maskset;
                        void 0 === e4._buffer && (e4._buffer = o2.getMaskTemplate.call(this, false, 1), 
                        void 0 === e4.buffer && (e4.buffer = e4._buffer.slice()));
                        return e4._buffer;
                    }, t3.getLastValidPosition = s2, t3.isMask = c2, t3.resetMaskSet = function(e4) {
                        var t4 = this.maskset;
                        t4.buffer = void 0, true !== e4 && (t4.validPositions = [], t4.p = 0);
                        false === e4 && (t4.tests = {}, t4.jitOffset = {});
                    }, t3.seekNext = u2, t3.seekPrevious = function(e4, t4) {
                        var n4 = this, i4 = e4 - 1;
                        if (e4 <= 0) return 0;
                        for (;i4 > 0 && (true === t4 && (true !== o2.getTest.call(n4, i4).match.newBlockMarker || !c2.call(n4, i4, void 0, true)) || true !== t4 && !c2.call(n4, i4, void 0, true)); ) i4--;
                        return i4;
                    }, t3.translatePosition = f2;
                    var i3, a2 = (i3 = n3(9380)) && i3.__esModule ? i3 : {
                        default: i3
                    }, r2 = n3(7215), o2 = n3(4713);
                    function l2(e4) {
                        var t4 = this, n4 = t4.maskset;
                        return void 0 !== n4.buffer && true !== e4 || (n4.buffer = o2.getMaskTemplate.call(t4, true, s2.call(t4), true), 
                        void 0 === n4._buffer && (n4._buffer = n4.buffer.slice())), n4.buffer;
                    }
                    function s2(e4, t4, n4) {
                        var i4 = this.maskset, a3 = -1, r3 = -1, o3 = n4 || i4.validPositions;
                        void 0 === e4 && (e4 = -1);
                        for (var l3 = 0, s3 = o3.length; l3 < s3; l3++) o3[l3] && (t4 || true !== o3[l3].generatedInput) && (l3 <= e4 && (a3 = l3), 
                        l3 >= e4 && (r3 = l3));
                        return -1 === a3 || a3 === e4 ? r3 : -1 === r3 || e4 - a3 < r3 - e4 ? a3 : r3;
                    }
                    function c2(e4, t4, n4) {
                        var i4 = this, a3 = this.maskset, r3 = o2.getTestTemplate.call(i4, e4).match;
                        if ("" === r3.def && (r3 = o2.getTest.call(i4, e4).match), true !== r3.static) return r3.fn;
                        if (true === n4 && void 0 !== a3.validPositions[e4] && true !== a3.validPositions[e4].generatedInput) return true;
                        if (true !== t4 && e4 > -1) {
                            if (n4) {
                                var l3 = o2.getTests.call(i4, e4);
                                return l3.length > 1 + ("" === l3[l3.length - 1].match.def ? 1 : 0);
                            }
                            var s3 = o2.determineTestTemplate.call(i4, e4, o2.getTests.call(i4, e4)), c3 = o2.getPlaceholder.call(i4, e4, s3.match);
                            return s3.match.def !== c3;
                        }
                        return false;
                    }
                    function u2(e4, t4, n4) {
                        var i4 = this;
                        void 0 === n4 && (n4 = true);
                        for (var a3 = e4 + 1; "" !== o2.getTest.call(i4, a3).match.def && (true === t4 && (true !== o2.getTest.call(i4, a3).match.newBlockMarker || !c2.call(i4, a3, void 0, true)) || true !== t4 && !c2.call(i4, a3, void 0, n4)); ) a3++;
                        return a3;
                    }
                    function f2(e4) {
                        var t4 = this.opts, n4 = this.el;
                        return !this.isRTL || "number" != typeof e4 || t4.greedy && "" === t4.placeholder || !n4 || (e4 = this._valueGet().length - e4) < 0 && (e4 = 0), 
                        e4;
                    }
                },
                4713: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.determineTestTemplate = f2, t3.getDecisionTaker = s2, t3.getMaskTemplate = function(e4, t4, n4, i4, a3) {
                        var r3 = this, o3 = this.opts, l3 = this.maskset, s3 = o3.greedy;
                        a3 && o3.greedy && (o3.greedy = false, r3.maskset.tests = {});
                        t4 = t4 || 0;
                        var p3, d3, v2, m2, g2 = [], y2 = 0;
                        do {
                            if (true === e4 && l3.validPositions[y2]) d3 = (v2 = a3 && l3.validPositions[y2].match.optionality && void 0 === l3.validPositions[y2 + 1] && (true === l3.validPositions[y2].generatedInput || l3.validPositions[y2].input == o3.skipOptionalPartCharacter && y2 > 0) ? f2.call(r3, y2, h2.call(r3, y2, p3, y2 - 1)) : l3.validPositions[y2]).match, 
                            p3 = v2.locator.slice(), g2.push(true === n4 ? v2.input : false === n4 ? d3.nativeDef : c2.call(r3, y2, d3)); else {
                                d3 = (v2 = u2.call(r3, y2, p3, y2 - 1)).match, p3 = v2.locator.slice();
                                var k2 = true !== i4 && (false !== o3.jitMasking ? o3.jitMasking : d3.jit);
                                (m2 = (m2 || l3.validPositions[y2 - 1]) && d3.static && d3.def !== o3.groupSeparator && null === d3.fn) || false === k2 || void 0 === k2 || "number" == typeof k2 && isFinite(k2) && k2 > y2 ? g2.push(false === n4 ? d3.nativeDef : c2.call(r3, g2.length, d3)) : m2 = false;
                            }
                            y2++;
                        } while (true !== d3.static || "" !== d3.def || t4 > y2);
                        "" === g2[g2.length - 1] && g2.pop();
                        false === n4 && void 0 !== l3.maskLength || (l3.maskLength = y2 - 1);
                        return o3.greedy = s3, g2;
                    }, t3.getPlaceholder = c2, t3.getTest = p2, t3.getTestTemplate = u2, t3.getTests = h2, 
                    t3.isSubsetOf = d2;
                    var i3, a2 = (i3 = n3(2394)) && i3.__esModule ? i3 : {
                        default: i3
                    }, r2 = n3(8711);
                    function o2(e4) {
                        return o2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
                            return typeof e5;
                        } : function(e5) {
                            return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                        }, o2(e4);
                    }
                    function l2(e4, t4) {
                        var n4 = (null != e4.alternation ? e4.mloc[s2(e4)] : e4.locator).join("");
                        if ("" !== n4) for (n4 = n4.split(":")[0]; n4.length < t4; ) n4 += "0";
                        return n4;
                    }
                    function s2(e4) {
                        var t4 = e4.locator[e4.alternation];
                        return "string" == typeof t4 && t4.length > 0 && (t4 = t4.split(",")[0]), void 0 !== t4 ? t4.toString() : "";
                    }
                    function c2(e4, t4, n4) {
                        var i4 = this, a3 = this.opts, l3 = this.maskset;
                        if (void 0 !== (t4 = t4 || p2.call(i4, e4).match).placeholder || true === n4) {
                            if ("" !== t4.placeholder && true === t4.static && true !== t4.generated) {
                                var s3 = r2.getLastValidPosition.call(i4, e4), c3 = r2.seekNext.call(i4, s3);
                                return (n4 ? e4 <= c3 : e4 < c3) ? a3.staticDefinitionSymbol && t4.static ? t4.nativeDef : t4.def : "function" == typeof t4.placeholder ? t4.placeholder(a3) : t4.placeholder;
                            }
                            return "function" == typeof t4.placeholder ? t4.placeholder(a3) : t4.placeholder;
                        }
                        if (true === t4.static) {
                            if (e4 > -1 && void 0 === l3.validPositions[e4]) {
                                var u3, f3 = h2.call(i4, e4), d3 = [];
                                if ("string" == typeof a3.placeholder && f3.length > 1 + ("" === f3[f3.length - 1].match.def ? 1 : 0)) for (var v2 = 0; v2 < f3.length; v2++) if ("" !== f3[v2].match.def && true !== f3[v2].match.optionality && true !== f3[v2].match.optionalQuantifier && (true === f3[v2].match.static || void 0 === u3 || false !== f3[v2].match.fn.test(u3.match.def, l3, e4, true, a3)) && (d3.push(f3[v2]), 
                                true === f3[v2].match.static && (u3 = f3[v2]), d3.length > 1 && /[0-9a-bA-Z]/.test(d3[0].match.def))) return a3.placeholder.charAt(e4 % a3.placeholder.length);
                            }
                            return t4.def;
                        }
                        return "object" === o2(a3.placeholder) ? t4.def : a3.placeholder.charAt(e4 % a3.placeholder.length);
                    }
                    function u2(e4, t4, n4) {
                        return this.maskset.validPositions[e4] || f2.call(this, e4, h2.call(this, e4, t4 ? t4.slice() : t4, n4));
                    }
                    function f2(e4, t4) {
                        var n4 = this.opts, i4 = 0, a3 = function(e5, t5) {
                            var n5 = 0, i5 = false;
                            t5.forEach((function(e6) {
                                e6.match.optionality && (0 !== n5 && n5 !== e6.match.optionality && (i5 = true), 
                                (0 === n5 || n5 > e6.match.optionality) && (n5 = e6.match.optionality));
                            })), n5 && (0 == e5 || 1 == t5.length ? n5 = 0 : i5 || (n5 = 0));
                            return n5;
                        }(e4, t4);
                        e4 = e4 > 0 ? e4 - 1 : 0;
                        var r3, o3, s3, c3 = l2(p2.call(this, e4));
                        n4.greedy && t4.length > 1 && "" === t4[t4.length - 1].match.def && (i4 = 1);
                        for (var u3 = 0; u3 < t4.length - i4; u3++) {
                            var f3 = t4[u3];
                            r3 = l2(f3, c3.length);
                            var d3 = Math.abs(r3 - c3);
                            (true !== f3.unMatchedAlternationStopped || t4.filter((function(e5) {
                                return true !== e5.unMatchedAlternationStopped;
                            })).length <= 1) && (void 0 === o3 || "" !== r3 && d3 < o3 || s3 && !n4.greedy && s3.match.optionality && s3.match.optionality - a3 > 0 && "master" === s3.match.newBlockMarker && (!f3.match.optionality || f3.match.optionality - a3 < 1 || !f3.match.newBlockMarker) || s3 && !n4.greedy && s3.match.optionalQuantifier && !f3.match.optionalQuantifier) && (o3 = d3, 
                            s3 = f3);
                        }
                        return s3;
                    }
                    function p2(e4, t4) {
                        var n4 = this.maskset;
                        return n4.validPositions[e4] ? n4.validPositions[e4] : (t4 || h2.call(this, e4))[0];
                    }
                    function d2(e4, t4, n4) {
                        function i4(e5) {
                            for (var t5, n5 = [], i5 = -1, a3 = 0, r3 = e5.length; a3 < r3; a3++) if ("-" === e5.charAt(a3)) for (t5 = e5.charCodeAt(a3 + 1); ++i5 < t5; ) n5.push(String.fromCharCode(i5)); else i5 = e5.charCodeAt(a3), 
                            n5.push(e5.charAt(a3));
                            return n5.join("");
                        }
                        return e4.match.def === t4.match.nativeDef || !(!(n4.regex || e4.match.fn instanceof RegExp && t4.match.fn instanceof RegExp) || true === e4.match.static || true === t4.match.static) && ("." === t4.match.fn.source || -1 !== i4(t4.match.fn.source.replace(/[[\]/]/g, "")).indexOf(i4(e4.match.fn.source.replace(/[[\]/]/g, ""))));
                    }
                    function h2(e4, t4, n4) {
                        var i4, r3, o3 = this, l3 = this.dependencyLib, s3 = this.maskset, c3 = this.opts, u3 = this.el, p3 = s3.maskToken, h3 = t4 ? n4 : 0, v2 = t4 ? t4.slice() : [ 0 ], m2 = [], g2 = false, y2 = t4 ? t4.join("") : "", k2 = false;
                        function b2(t5, n5, r4, l4) {
                            function f3(r5, l5, p5) {
                                function v4(e5, t6) {
                                    var n6 = 0 === t6.matches.indexOf(e5);
                                    return n6 || t6.matches.every((function(i5, a3) {
                                        return true === i5.isQuantifier ? n6 = v4(e5, t6.matches[a3 - 1]) : Object.prototype.hasOwnProperty.call(i5, "matches") && (n6 = v4(e5, i5)), 
                                        !n6;
                                    })), n6;
                                }
                                function w3(e5, t6, n6) {
                                    var i5, a3;
                                    if ((s3.tests[e5] || s3.validPositions[e5]) && (s3.validPositions[e5] ? [ s3.validPositions[e5] ] : s3.tests[e5]).every((function(e6, r7) {
                                        if (e6.mloc[t6]) return i5 = e6, false;
                                        var o5 = void 0 !== n6 ? n6 : e6.alternation, l6 = void 0 !== e6.locator[o5] ? e6.locator[o5].toString().indexOf(t6) : -1;
                                        return (void 0 === a3 || l6 < a3) && -1 !== l6 && (i5 = e6, a3 = l6), true;
                                    })), i5) {
                                        var r6 = i5.locator[i5.alternation], o4 = i5.mloc[t6] || i5.mloc[r6] || i5.locator;
                                        if (-1 !== o4[o4.length - 1].toString().indexOf(":")) o4.pop();
                                        return o4.slice((void 0 !== n6 ? n6 : i5.alternation) + 1);
                                    }
                                    return void 0 !== n6 ? w3(e5, t6) : void 0;
                                }
                                function P3(t6, n6) {
                                    return true === t6.match.static && true !== n6.match.static && n6.match.fn.test(t6.match.def, s3, e4, false, c3, false);
                                }
                                function S3(e5, t6) {
                                    var n6 = e5.alternation, i5 = void 0 === t6 || n6 <= t6.alternation && -1 === e5.locator[n6].toString().indexOf(t6.locator[n6]);
                                    if (!i5 && n6 > t6.alternation) for (var a3 = 0; a3 < n6; a3++) if (e5.locator[a3] !== t6.locator[a3]) {
                                        n6 = a3, i5 = true;
                                        break;
                                    }
                                    return !!i5 && function(n7) {
                                        e5.mloc = e5.mloc || {};
                                        var i6 = e5.locator[n7];
                                        if (void 0 !== i6) {
                                            if ("string" == typeof i6 && (i6 = i6.split(",")[0]), void 0 === e5.mloc[i6] && (e5.mloc[i6] = e5.locator.slice(), 
                                            e5.mloc[i6].push(":".concat(e5.alternation))), void 0 !== t6) {
                                                for (var a4 in t6.mloc) "string" == typeof a4 && (a4 = parseInt(a4.split(",")[0])), 
                                                e5.mloc[a4 + 0] = t6.mloc[a4];
                                                e5.locator[n7] = Object.keys(e5.mloc).join(",");
                                            }
                                            return e5.alternation > n7 && (e5.alternation = n7), true;
                                        }
                                        return e5.alternation = void 0, false;
                                    }(n6);
                                }
                                function O2(e5, t6) {
                                    if (e5.locator.length !== t6.locator.length) return false;
                                    for (var n6 = e5.alternation + 1; n6 < e5.locator.length; n6++) if (e5.locator[n6] !== t6.locator[n6]) return false;
                                    return true;
                                }
                                if (h3 > e4 + c3._maxTestPos) throw new Error("Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. ".concat(s3.mask));
                                if (h3 === e4 && void 0 === r5.matches) {
                                    if (m2.push({
                                        match: r5,
                                        locator: l5.reverse(),
                                        cd: y2,
                                        mloc: {}
                                    }), !r5.optionality || void 0 !== p5 || !(c3.definitions && c3.definitions[r5.nativeDef] && c3.definitions[r5.nativeDef].optional || a2.default.prototype.definitions[r5.nativeDef] && a2.default.prototype.definitions[r5.nativeDef].optional)) return true;
                                    g2 = true, h3 = e4;
                                } else if (void 0 !== r5.matches) {
                                    if (r5.isGroup && p5 !== r5) return function() {
                                        if (r5 = f3(t5.matches[t5.matches.indexOf(r5) + 1], l5, p5)) return true;
                                    }();
                                    if (r5.isOptional) return function() {
                                        var t6 = r5, a3 = m2.length;
                                        if (r5 = b2(r5, n5, l5, p5), m2.length > 0) {
                                            if (m2.forEach((function(e5, t7) {
                                                t7 >= a3 && (e5.match.optionality = e5.match.optionality ? e5.match.optionality + 1 : 1);
                                            })), i4 = m2[m2.length - 1].match, void 0 !== p5 || !v4(i4, t6)) return r5;
                                            g2 = true, h3 = e4;
                                        }
                                    }();
                                    if (r5.isAlternator) return function() {
                                        function i5(e5) {
                                            for (var t6, n6 = e5.matches[0].matches ? e5.matches[0].matches.length : 1, i6 = 0; i6 < e5.matches.length && n6 === (t6 = e5.matches[i6].matches ? e5.matches[i6].matches.length : 1); i6++) ;
                                            return n6 !== t6;
                                        }
                                        o3.hasAlternator = true;
                                        var a3, v5 = r5, y3 = [], b3 = m2.slice(), x3 = l5.length, _2 = n5.length > 0 ? n5.shift() : -1;
                                        if (-1 === _2 || "string" == typeof _2) {
                                            var M2, E2 = h3, j2 = n5.slice(), T2 = [];
                                            if ("string" == typeof _2) T2 = _2.split(","); else for (M2 = 0; M2 < v5.matches.length; M2++) T2.push(M2.toString());
                                            if (void 0 !== s3.excludes[e4]) {
                                                for (var A2 = T2.slice(), D2 = 0, L2 = s3.excludes[e4].length; D2 < L2; D2++) {
                                                    var C2 = s3.excludes[e4][D2].toString().split(":");
                                                    l5.length == C2[1] && T2.splice(T2.indexOf(C2[0]), 1);
                                                }
                                                0 === T2.length && (delete s3.excludes[e4], T2 = A2);
                                            }
                                            (true === c3.keepStatic || isFinite(parseInt(c3.keepStatic)) && E2 >= c3.keepStatic) && (T2 = T2.slice(0, 1));
                                            for (var B2 = 0; B2 < T2.length; B2++) {
                                                M2 = parseInt(T2[B2]), m2 = [], n5 = "string" == typeof _2 && w3(h3, M2, x3) || j2.slice();
                                                var I2 = v5.matches[M2];
                                                if (I2 && f3(I2, [ M2 ].concat(l5), p5)) r5 = true; else if (0 === B2 && (k2 = i5(v5)), 
                                                I2 && I2.matches && I2.matches.length > v5.matches[0].matches.length) break;
                                                a3 = m2.slice(), h3 = E2, m2 = [];
                                                for (var R2 = 0; R2 < a3.length; R2++) {
                                                    var F2 = a3[R2], N2 = false;
                                                    F2.alternation = F2.alternation || x3, S3(F2);
                                                    for (var V2 = 0; V2 < y3.length; V2++) {
                                                        var G2 = y3[V2];
                                                        if ("string" != typeof _2 || void 0 !== F2.alternation && T2.includes(F2.locator[F2.alternation].toString())) {
                                                            if (F2.match.nativeDef === G2.match.nativeDef) {
                                                                N2 = true, S3(G2, F2);
                                                                break;
                                                            }
                                                            if (d2(F2, G2, c3)) {
                                                                S3(F2, G2) && (N2 = true, y3.splice(y3.indexOf(G2), 0, F2));
                                                                break;
                                                            }
                                                            if (d2(G2, F2, c3)) {
                                                                S3(G2, F2);
                                                                break;
                                                            }
                                                            if (P3(F2, G2)) {
                                                                O2(F2, G2) || void 0 !== u3.inputmask.userOptions.keepStatic ? S3(F2, G2) && (N2 = true, 
                                                                y3.splice(y3.indexOf(G2), 0, F2)) : c3.keepStatic = true;
                                                                break;
                                                            }
                                                            if (P3(G2, F2)) {
                                                                S3(G2, F2);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    N2 || y3.push(F2);
                                                }
                                            }
                                            m2 = b3.concat(y3), h3 = e4, g2 = m2.length > 0 && k2, r5 = y3.length > 0 && !k2, 
                                            k2 && g2 && !r5 && m2.forEach((function(e5, t6) {
                                                e5.unMatchedAlternationStopped = true;
                                            })), n5 = j2.slice();
                                        } else r5 = f3(v5.matches[_2] || t5.matches[_2], [ _2 ].concat(l5), p5);
                                        if (r5) return true;
                                    }();
                                    if (r5.isQuantifier && p5 !== t5.matches[t5.matches.indexOf(r5) - 1]) return function() {
                                        for (var a3 = r5, o4 = false, u4 = n5.length > 0 ? n5.shift() : 0; u4 < (isNaN(a3.quantifier.max) ? u4 + 1 : a3.quantifier.max) && h3 <= e4; u4++) {
                                            var p6 = t5.matches[t5.matches.indexOf(a3) - 1];
                                            if (r5 = f3(p6, [ u4 ].concat(l5), p6)) {
                                                if (m2.forEach((function(t6, n6) {
                                                    (i4 = x2(p6, t6.match) ? t6.match : m2[m2.length - 1].match).optionalQuantifier = u4 >= a3.quantifier.min, 
                                                    i4.jit = (u4 + 1) * (p6.matches.indexOf(i4) + 1) > a3.quantifier.jit, i4.optionalQuantifier && v4(i4, p6) && (g2 = true, 
                                                    h3 = e4, c3.greedy && null == s3.validPositions[e4 - 1] && u4 > a3.quantifier.min && -1 != [ "*", "+" ].indexOf(a3.quantifier.max) && (m2.pop(), 
                                                    y2 = void 0), o4 = true, r5 = false), !o4 && i4.jit && (s3.jitOffset[e4] = p6.matches.length - p6.matches.indexOf(i4));
                                                })), o4) break;
                                                return true;
                                            }
                                        }
                                    }();
                                    if (r5 = b2(r5, n5, l5, p5)) return true;
                                } else h3++;
                            }
                            for (var p4 = n5.length > 0 ? n5.shift() : 0; p4 < t5.matches.length; p4++) if (true !== t5.matches[p4].isQuantifier) {
                                var v3 = f3(t5.matches[p4], [ p4 ].concat(r4), l4);
                                if (v3 && h3 === e4) return v3;
                                if (h3 > e4) break;
                            }
                        }
                        function x2(e5, t5) {
                            var n5 = -1 != e5.matches.indexOf(t5);
                            return n5 || e5.matches.forEach((function(e6, i5) {
                                void 0 === e6.matches || n5 || (n5 = x2(e6, t5));
                            })), n5;
                        }
                        if (e4 > -1) {
                            if (void 0 === t4) {
                                for (var w2, P2 = e4 - 1; void 0 === (w2 = s3.validPositions[P2] || s3.tests[P2]) && P2 > -1; ) P2--;
                                void 0 !== w2 && P2 > -1 && (v2 = function(e5, t5) {
                                    var n5, i5 = [];
                                    return Array.isArray(t5) || (t5 = [ t5 ]), t5.length > 0 && (void 0 === t5[0].alternation || true === c3.keepStatic ? 0 === (i5 = f2.call(o3, e5, t5.slice()).locator.slice()).length && (i5 = t5[0].locator.slice()) : t5.forEach((function(e6) {
                                        "" !== e6.def && (0 === i5.length ? (n5 = e6.alternation, i5 = e6.locator.slice()) : e6.locator[n5] && -1 === i5[n5].toString().indexOf(e6.locator[n5]) && (i5[n5] += "," + e6.locator[n5]));
                                    }))), i5;
                                }(P2, w2), y2 = v2.join(""), h3 = P2);
                            }
                            if (s3.tests[e4] && s3.tests[e4][0].cd === y2) return s3.tests[e4];
                            for (var S2 = v2.shift(); S2 < p3.length; S2++) if (b2(p3[S2], v2, [ S2 ]) && h3 === e4 || h3 > e4) break;
                        }
                        return (0 === m2.length || g2) && m2.push({
                            match: {
                                fn: null,
                                static: true,
                                optionality: false,
                                casing: null,
                                def: "",
                                placeholder: ""
                            },
                            locator: k2 && 0 === m2.filter((function(e5) {
                                return true !== e5.unMatchedAlternationStopped;
                            })).length ? [ 0 ] : [],
                            mloc: {},
                            cd: y2
                        }), void 0 !== t4 && s3.tests[e4] ? r3 = l3.extend(true, [], m2) : (s3.tests[e4] = l3.extend(true, [], m2), 
                        r3 = s3.tests[e4]), m2.forEach((function(e5) {
                            e5.match.optionality = e5.match.defOptionality || false;
                        })), r3;
                    }
                },
                7215: function(e3, t3, n3) {
                    Object.defineProperty(t3, "__esModule", {
                        value: true
                    }), t3.alternate = l2, t3.checkAlternationMatch = function(e4, t4, n4) {
                        for (var i4, a3 = this.opts.greedy ? t4 : t4.slice(0, 1), r3 = false, o3 = void 0 !== n4 ? n4.split(",") : [], l3 = 0; l3 < o3.length; l3++) -1 !== (i4 = e4.indexOf(o3[l3])) && e4.splice(i4, 1);
                        for (var s3 = 0; s3 < e4.length; s3++) if (a3.includes(e4[s3])) {
                            r3 = true;
                            break;
                        }
                        return r3;
                    }, t3.handleRemove = function(e4, t4, n4, i4, s3) {
                        var c3 = this, u3 = this.maskset, f3 = this.opts;
                        if ((f3.numericInput || c3.isRTL) && (t4 === a2.keys.Backspace ? t4 = a2.keys.Delete : t4 === a2.keys.Delete && (t4 = a2.keys.Backspace), 
                        c3.isRTL)) {
                            var p3 = n4.end;
                            n4.end = n4.begin, n4.begin = p3;
                        }
                        var d3, h3 = r2.getLastValidPosition.call(c3, void 0, true);
                        n4.end >= r2.getBuffer.call(c3).length && h3 >= n4.end && (n4.end = h3 + 1);
                        t4 === a2.keys.Backspace ? n4.end - n4.begin < 1 && (n4.begin = r2.seekPrevious.call(c3, n4.begin)) : t4 === a2.keys.Delete && n4.begin === n4.end && (n4.end = r2.isMask.call(c3, n4.end, true, true) ? n4.end + 1 : r2.seekNext.call(c3, n4.end) + 1);
                        false !== (d3 = v2.call(c3, n4)) && ((true !== i4 && false !== f3.keepStatic || null !== f3.regex && -1 !== o2.getTest.call(c3, n4.begin).match.def.indexOf("|")) && l2.call(c3, true), 
                        true !== i4 && (u3.p = t4 === a2.keys.Delete ? n4.begin + d3 : n4.begin, u3.p = r2.determineNewCaretPosition.call(c3, {
                            begin: u3.p,
                            end: u3.p
                        }, false, false === f3.insertMode && t4 === a2.keys.Backspace ? "none" : void 0).begin));
                    }, t3.isComplete = c2, t3.isSelection = u2, t3.isValid = f2, t3.refreshFromBuffer = d2, 
                    t3.revalidateMask = v2;
                    var i3 = n3(6030), a2 = n3(2839), r2 = n3(8711), o2 = n3(4713);
                    function l2(e4, t4, n4, i4, a3, s3) {
                        var c3 = this, u3 = this.dependencyLib, p3 = this.opts, d3 = c3.maskset;
                        if (!c3.hasAlternator) return false;
                        var h3, v3, m2, g2, y2, k2, b2, x2, w2, P2, S2, O2 = u3.extend(true, [], d3.validPositions), _2 = u3.extend(true, {}, d3.tests), M2 = false, E2 = false, j2 = void 0 !== a3 ? a3 : r2.getLastValidPosition.call(c3);
                        if (s3 && (P2 = s3.begin, S2 = s3.end, s3.begin > s3.end && (P2 = s3.end, S2 = s3.begin)), 
                        -1 === j2 && void 0 === a3) h3 = 0, v3 = (g2 = o2.getTest.call(c3, h3)).alternation; else for (;j2 >= 0; j2--) if ((m2 = d3.validPositions[j2]) && void 0 !== m2.alternation) {
                            if (j2 <= (e4 || 0) && g2 && g2.locator[m2.alternation] !== m2.locator[m2.alternation]) break;
                            h3 = j2, v3 = d3.validPositions[h3].alternation, g2 = m2;
                        }
                        if (void 0 !== v3) {
                            b2 = parseInt(h3), d3.excludes[b2] = d3.excludes[b2] || [], true !== e4 && d3.excludes[b2].push((0, 
                            o2.getDecisionTaker)(g2) + ":" + g2.alternation);
                            var T2 = [], A2 = -1;
                            for (y2 = b2; b2 < r2.getLastValidPosition.call(c3, void 0, true) + 1; y2++) -1 === A2 && e4 <= y2 && void 0 !== t4 && (T2.push(t4), 
                            A2 = T2.length - 1), (k2 = d3.validPositions[b2]) && true !== k2.generatedInput && (void 0 === s3 || y2 < P2 || y2 >= S2) && T2.push(k2.input), 
                            d3.validPositions.splice(b2, 1);
                            for (-1 === A2 && void 0 !== t4 && (T2.push(t4), A2 = T2.length - 1); void 0 !== d3.excludes[b2] && d3.excludes[b2].length < 10; ) {
                                for (d3.tests = {}, r2.resetMaskSet.call(c3, true), M2 = true, y2 = 0; y2 < T2.length && (x2 = M2.caret || 0 == p3.insertMode && null != x2 ? r2.seekNext.call(c3, x2) : r2.getLastValidPosition.call(c3, void 0, true) + 1, 
                                w2 = T2[y2], M2 = f2.call(c3, x2, w2, false, i4, true)); y2++) y2 === A2 && (E2 = M2), 
                                1 == e4 && M2 && (E2 = {
                                    caretPos: y2
                                });
                                if (M2) break;
                                if (r2.resetMaskSet.call(c3), g2 = o2.getTest.call(c3, b2), d3.validPositions = u3.extend(true, [], O2), 
                                d3.tests = u3.extend(true, {}, _2), !d3.excludes[b2]) {
                                    E2 = l2.call(c3, e4, t4, n4, i4, b2 - 1, s3);
                                    break;
                                }
                                if (null != g2.alternation) {
                                    var D2 = (0, o2.getDecisionTaker)(g2);
                                    if (-1 !== d3.excludes[b2].indexOf(D2 + ":" + g2.alternation)) {
                                        E2 = l2.call(c3, e4, t4, n4, i4, b2 - 1, s3);
                                        break;
                                    }
                                    for (d3.excludes[b2].push(D2 + ":" + g2.alternation), y2 = b2; y2 < r2.getLastValidPosition.call(c3, void 0, true) + 1; y2++) d3.validPositions.splice(b2);
                                } else delete d3.excludes[b2];
                            }
                        }
                        return E2 && false === p3.keepStatic || delete d3.excludes[b2], E2;
                    }
                    function s2(e4, t4, n4) {
                        var i4 = this.opts, r3 = this.maskset;
                        switch (i4.casing || t4.casing) {
                          case "upper":
                            e4 = e4.toUpperCase();
                            break;

                          case "lower":
                            e4 = e4.toLowerCase();
                            break;

                          case "title":
                            var o3 = r3.validPositions[n4 - 1];
                            e4 = 0 === n4 || o3 && o3.input === String.fromCharCode(a2.keyCode.Space) ? e4.toUpperCase() : e4.toLowerCase();
                            break;

                          default:
                            if ("function" == typeof i4.casing) {
                                var l3 = Array.prototype.slice.call(arguments);
                                l3.push(r3.validPositions), e4 = i4.casing.apply(this, l3);
                            }
                        }
                        return e4;
                    }
                    function c2(e4) {
                        var t4 = this, n4 = this.opts, i4 = this.maskset;
                        if ("function" == typeof n4.isComplete) return n4.isComplete(e4, n4);
                        if ("*" !== n4.repeat) {
                            var a3 = false, l3 = r2.determineLastRequiredPosition.call(t4, true), s3 = l3.l;
                            if (void 0 === l3.def || l3.def.newBlockMarker || l3.def.optionality || l3.def.optionalQuantifier) {
                                a3 = true;
                                for (var c3 = 0; c3 <= s3; c3++) {
                                    var u3 = o2.getTestTemplate.call(t4, c3).match;
                                    if (true !== u3.static && void 0 === i4.validPositions[c3] && (false === u3.optionality || void 0 === u3.optionality || u3.optionality && 0 == u3.newBlockMarker) && (false === u3.optionalQuantifier || void 0 === u3.optionalQuantifier) || true === u3.static && "" != u3.def && e4[c3] !== o2.getPlaceholder.call(t4, c3, u3)) {
                                        a3 = false;
                                        break;
                                    }
                                }
                            }
                            return a3;
                        }
                    }
                    function u2(e4) {
                        var t4 = this.opts.insertMode ? 0 : 1;
                        return this.isRTL ? e4.begin - e4.end > t4 : e4.end - e4.begin > t4;
                    }
                    function f2(e4, t4, n4, i4, a3, p3, m2) {
                        var g2 = this, y2 = this.dependencyLib, k2 = this.opts, b2 = g2.maskset;
                        n4 = true === n4;
                        var x2 = e4;
                        function w2(e5) {
                            if (void 0 !== e5) {
                                if (void 0 !== e5.remove && (Array.isArray(e5.remove) || (e5.remove = [ e5.remove ]), 
                                e5.remove.sort((function(e6, t6) {
                                    return g2.isRTL ? e6.pos - t6.pos : t6.pos - e6.pos;
                                })).forEach((function(e6) {
                                    v2.call(g2, {
                                        begin: e6,
                                        end: e6 + 1
                                    });
                                })), e5.remove = void 0), void 0 !== e5.insert && (Array.isArray(e5.insert) || (e5.insert = [ e5.insert ]), 
                                e5.insert.sort((function(e6, t6) {
                                    return g2.isRTL ? t6.pos - e6.pos : e6.pos - t6.pos;
                                })).forEach((function(e6) {
                                    "" !== e6.c && f2.call(g2, e6.pos, e6.c, void 0 === e6.strict || e6.strict, void 0 !== e6.fromIsValid ? e6.fromIsValid : i4);
                                })), e5.insert = void 0), e5.refreshFromBuffer && e5.buffer) {
                                    var t5 = e5.refreshFromBuffer;
                                    d2.call(g2, true === t5 ? t5 : t5.start, t5.end, e5.buffer), e5.refreshFromBuffer = void 0;
                                }
                                void 0 !== e5.rewritePosition && (x2 = e5.rewritePosition, e5 = true);
                            }
                            return e5;
                        }
                        function P2(t5, n5, a4) {
                            var l3 = false;
                            return o2.getTests.call(g2, t5).every((function(c3, f3) {
                                var p4 = c3.match;
                                if (r2.getBuffer.call(g2, true), false !== (l3 = (!p4.jit || void 0 !== b2.validPositions[r2.seekPrevious.call(g2, t5)]) && (null != p4.fn ? p4.fn.test(n5, b2, t5, a4, k2, u2.call(g2, e4)) : (n5 === p4.def || n5 === k2.skipOptionalPartCharacter) && "" !== p4.def && {
                                    c: o2.getPlaceholder.call(g2, t5, p4, true) || p4.def,
                                    pos: t5
                                }))) {
                                    var d3 = void 0 !== l3.c ? l3.c : n5, h3 = t5;
                                    return d3 = d3 === k2.skipOptionalPartCharacter && true === p4.static ? o2.getPlaceholder.call(g2, t5, p4, true) || p4.def : d3, 
                                    true !== (l3 = w2(l3)) && void 0 !== l3.pos && l3.pos !== t5 && (h3 = l3.pos), true !== l3 && void 0 === l3.pos && void 0 === l3.c ? false : (false === v2.call(g2, e4, y2.extend({}, c3, {
                                        input: s2.call(g2, d3, p4, h3)
                                    }), i4, h3) && (l3 = false), false);
                                }
                                return true;
                            })), l3;
                        }
                        void 0 !== e4.begin && (x2 = g2.isRTL ? e4.end : e4.begin);
                        var S2 = true, O2 = y2.extend(true, [], b2.validPositions);
                        if (false === k2.keepStatic && void 0 !== b2.excludes[x2] && true !== a3 && true !== i4) for (var _2 = x2; _2 < (g2.isRTL ? e4.begin : e4.end); _2++) void 0 !== b2.excludes[_2] && (b2.excludes[_2] = void 0, 
                        delete b2.tests[_2]);
                        if ("function" == typeof k2.preValidation && true !== i4 && true !== p3 && (S2 = w2(S2 = k2.preValidation.call(g2, r2.getBuffer.call(g2), x2, t4, u2.call(g2, e4), k2, b2, e4, n4 || a3))), 
                        true === S2) {
                            if (S2 = P2(x2, t4, n4), (!n4 || true === i4) && false === S2 && true !== p3) {
                                var M2 = b2.validPositions[x2];
                                if (!M2 || true !== M2.match.static || M2.match.def !== t4 && t4 !== k2.skipOptionalPartCharacter) {
                                    if (k2.insertMode || void 0 === b2.validPositions[r2.seekNext.call(g2, x2)] || e4.end > x2) {
                                        var E2 = false;
                                        if (b2.jitOffset[x2] && void 0 === b2.validPositions[r2.seekNext.call(g2, x2)] && false !== (S2 = f2.call(g2, x2 + b2.jitOffset[x2], t4, true, true)) && (true !== a3 && (S2.caret = x2), 
                                        E2 = true), e4.end > x2 && (b2.validPositions[x2] = void 0), !E2 && !r2.isMask.call(g2, x2, k2.keepStatic && 0 === x2)) for (var j2 = x2 + 1, T2 = r2.seekNext.call(g2, x2, false, 0 !== x2); j2 <= T2; j2++) if (false !== (S2 = P2(j2, t4, n4))) {
                                            S2 = h2.call(g2, x2, void 0 !== S2.pos ? S2.pos : j2) || S2, x2 = j2;
                                            break;
                                        }
                                    }
                                } else S2 = {
                                    caret: r2.seekNext.call(g2, x2)
                                };
                            }
                            g2.hasAlternator && true !== a3 && !n4 && (a3 = true, false === S2 && k2.keepStatic && (c2.call(g2, r2.getBuffer.call(g2)) || 0 === x2) ? S2 = l2.call(g2, x2, t4, n4, i4, void 0, e4) : (u2.call(g2, e4) && b2.tests[x2] && b2.tests[x2].length > 1 && k2.keepStatic || 1 == S2 && true !== k2.numericInput && b2.tests[x2] && b2.tests[x2].length > 1 && r2.getLastValidPosition.call(g2, void 0, true) > x2) && (S2 = l2.call(g2, true))), 
                            true === S2 && (S2 = {
                                pos: x2
                            });
                        }
                        if ("function" == typeof k2.postValidation && true !== i4 && true !== p3) {
                            var A2 = k2.postValidation.call(g2, r2.getBuffer.call(g2, true), void 0 !== e4.begin ? g2.isRTL ? e4.end : e4.begin : e4, t4, S2, k2, b2, n4, m2);
                            void 0 !== A2 && (S2 = true === A2 ? S2 : A2);
                        }
                        S2 && void 0 === S2.pos && (S2.pos = x2), false === S2 || true === p3 ? (r2.resetMaskSet.call(g2, true), 
                        b2.validPositions = y2.extend(true, [], O2)) : h2.call(g2, void 0, x2, true);
                        var D2 = w2(S2);
                        void 0 !== g2.maxLength && r2.getBuffer.call(g2).length > g2.maxLength && !i4 && (r2.resetMaskSet.call(g2, true), 
                        b2.validPositions = y2.extend(true, [], O2), D2 = false);
                        return D2;
                    }
                    function p2(e4, t4, n4) {
                        for (var i4 = this.maskset, a3 = false, r3 = o2.getTests.call(this, e4), l3 = 0; l3 < r3.length; l3++) {
                            if (r3[l3].match && (r3[l3].match.nativeDef === t4.match[n4.shiftPositions ? "def" : "nativeDef"] && (!n4.shiftPositions || !t4.match.static) || r3[l3].match.nativeDef === t4.match.nativeDef || n4.regex && !r3[l3].match.static && r3[l3].match.fn.test(t4.input, i4, e4, false, n4))) {
                                a3 = true;
                                break;
                            }
                            if (r3[l3].match && r3[l3].match.def === t4.match.nativeDef) {
                                a3 = void 0;
                                break;
                            }
                        }
                        return false === a3 && void 0 !== i4.jitOffset[e4] && (a3 = p2.call(this, e4 + i4.jitOffset[e4], t4, n4)), 
                        a3;
                    }
                    function d2(e4, t4, n4) {
                        var a3, o3, l3 = this, s3 = this.maskset, c3 = this.opts, u3 = this.dependencyLib, f3 = c3.skipOptionalPartCharacter, p3 = l3.isRTL ? n4.slice().reverse() : n4;
                        if (c3.skipOptionalPartCharacter = "", true === e4) r2.resetMaskSet.call(l3, false), 
                        e4 = 0, t4 = n4.length, o3 = r2.determineNewCaretPosition.call(l3, {
                            begin: 0,
                            end: 0
                        }, false).begin; else {
                            for (a3 = e4; a3 < t4; a3++) s3.validPositions.splice(e4, 0);
                            o3 = e4;
                        }
                        var d3 = new u3.Event("keypress");
                        for (a3 = e4; a3 < t4; a3++) {
                            d3.key = p3[a3].toString(), l3.ignorable = false;
                            var h3 = i3.EventHandlers.keypressEvent.call(l3, d3, true, false, false, o3);
                            false !== h3 && void 0 !== h3 && (o3 = h3.forwardPosition);
                        }
                        c3.skipOptionalPartCharacter = f3;
                    }
                    function h2(e4, t4, n4) {
                        var i4 = this, a3 = this.maskset, l3 = this.dependencyLib;
                        if (void 0 === e4) for (e4 = t4 - 1; e4 > 0 && !a3.validPositions[e4]; e4--) ;
                        for (var s3 = e4; s3 < t4; s3++) if (void 0 === a3.validPositions[s3] && !r2.isMask.call(i4, s3, false)) if (0 == s3 ? o2.getTest.call(i4, s3) : a3.validPositions[s3 - 1]) {
                            var c3 = o2.getTests.call(i4, s3).slice();
                            "" === c3[c3.length - 1].match.def && c3.pop();
                            var u3, p3 = o2.determineTestTemplate.call(i4, s3, c3);
                            if (p3 && (true !== p3.match.jit || "master" === p3.match.newBlockMarker && (u3 = a3.validPositions[s3 + 1]) && true === u3.match.optionalQuantifier) && ((p3 = l3.extend({}, p3, {
                                input: o2.getPlaceholder.call(i4, s3, p3.match, true) || p3.match.def
                            })).generatedInput = true, v2.call(i4, s3, p3, true), true !== n4)) {
                                var d3 = a3.validPositions[t4].input;
                                return a3.validPositions[t4] = void 0, f2.call(i4, t4, d3, true, true);
                            }
                        }
                    }
                    function v2(e4, t4, n4, i4) {
                        var a3 = this, l3 = this.maskset, s3 = this.opts, c3 = this.dependencyLib;
                        function d3(e5, t5, n5) {
                            var i5 = t5[e5];
                            if (void 0 !== i5 && true === i5.match.static && true !== i5.match.optionality && (void 0 === t5[0] || void 0 === t5[0].alternation)) {
                                var a4 = n5.begin <= e5 - 1 ? t5[e5 - 1] && true === t5[e5 - 1].match.static && t5[e5 - 1] : t5[e5 - 1], r3 = n5.end > e5 + 1 ? t5[e5 + 1] && true === t5[e5 + 1].match.static && t5[e5 + 1] : t5[e5 + 1];
                                return a4 && r3;
                            }
                            return false;
                        }
                        var h3 = 0, v3 = void 0 !== e4.begin ? e4.begin : e4, m2 = void 0 !== e4.end ? e4.end : e4, g2 = true;
                        if (e4.begin > e4.end && (v3 = e4.end, m2 = e4.begin), i4 = void 0 !== i4 ? i4 : v3, 
                        void 0 === n4 && (v3 !== m2 || s3.insertMode && void 0 !== l3.validPositions[i4] || void 0 === t4 || t4.match.optionalQuantifier || t4.match.optionality)) {
                            var y2, k2 = c3.extend(true, [], l3.validPositions), b2 = r2.getLastValidPosition.call(a3, void 0, true);
                            l3.p = v3;
                            var x2 = u2.call(a3, e4) ? v3 : i4;
                            for (y2 = b2; y2 >= x2; y2--) l3.validPositions.splice(y2, 1), void 0 === t4 && delete l3.tests[y2 + 1];
                            var w2, P2, S2 = i4, O2 = S2;
                            for (t4 && (l3.validPositions[i4] = c3.extend(true, {}, t4), O2++, S2++), null == k2[m2] && l3.jitOffset[m2] && (m2 += l3.jitOffset[m2] + 1), 
                            y2 = t4 ? m2 : m2 - 1; y2 <= b2; y2++) {
                                if (void 0 !== (w2 = k2[y2]) && true !== w2.generatedInput && (y2 >= m2 || y2 >= v3 && d3(y2, k2, {
                                    begin: v3,
                                    end: m2
                                }))) {
                                    for (;"" !== o2.getTest.call(a3, O2).match.def; ) {
                                        if (false !== (P2 = p2.call(a3, O2, w2, s3)) || "+" === w2.match.def) {
                                            "+" === w2.match.def && r2.getBuffer.call(a3, true);
                                            var _2 = f2.call(a3, O2, w2.input, "+" !== w2.match.def, true);
                                            if (g2 = false !== _2, S2 = (_2.pos || O2) + 1, !g2 && P2) break;
                                        } else g2 = false;
                                        if (g2) {
                                            void 0 === t4 && w2.match.static && y2 === e4.begin && h3++;
                                            break;
                                        }
                                        if (!g2 && r2.getBuffer.call(a3), O2 > l3.maskLength) break;
                                        O2++;
                                    }
                                    "" == o2.getTest.call(a3, O2).match.def && (g2 = false), O2 = S2;
                                }
                                if (!g2) break;
                            }
                            if (!g2) return l3.validPositions = c3.extend(true, [], k2), r2.resetMaskSet.call(a3, true), 
                            false;
                        } else t4 && o2.getTest.call(a3, i4).match.cd === t4.match.cd && (l3.validPositions[i4] = c3.extend(true, {}, t4));
                        return r2.resetMaskSet.call(a3, true), h3;
                    }
                }
            }, t2 = {};
            function n2(i3) {
                var a2 = t2[i3];
                if (void 0 !== a2) return a2.exports;
                var r2 = t2[i3] = {
                    exports: {}
                };
                return e2[i3](r2, r2.exports, n2), r2.exports;
            }
            var i2 = {};
            return function() {
                var e3 = i2;
                Object.defineProperty(e3, "__esModule", {
                    value: true
                }), e3.default = void 0, n2(7149), n2(3194), n2(9302), n2(4013), n2(3851), n2(219), 
                n2(207), n2(5296);
                var t3, a2 = (t3 = n2(2394)) && t3.__esModule ? t3 : {
                    default: t3
                };
                e3.default = a2.default;
            }(), i2;
        }();
    }));
})(inputmask);

var inputmaskExports = inputmask.exports;

const Inputmask =  getDefaultExportFromCjs(inputmaskExports);

var ymapsTouchScroll$1 = {};

Object.defineProperty(ymapsTouchScroll$1, "__esModule", {
    value: true
});

var ymapsTouchScroll = function(map, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.preventScroll, preventScroll = _c === void 0 ? true : _c, _d = _b.preventTouch, preventTouch = _d === void 0 ? true : _d, _e = _b.textScroll, textScroll = _e === void 0 ? "Чтобы изменить масштаб, прокручивайте карту, удерживая клавишу Ctrl" : _e, _f = _b.textTouch, textTouch = _f === void 0 ? "Чтобы переместить карту проведите по ней двумя пальцами" : _f;
    if (typeof window === "undefined" || typeof map !== "object" || !preventScroll && !preventTouch) return;
    var eventsPane = map.panes.get("events");
    if (!eventsPane) return;
    var eventsPaneEl = eventsPane.getElement();
    var isTouch = /Mobi/i.test(navigator.userAgent) || /Android/i.test(navigator.userAgent);
    var text = isTouch ? textTouch : textScroll;
    var styles = {
        alignItems: "center",
        boxSizing: "border-box",
        color: "#fff",
        display: "flex",
        justifyContent: "center",
        padding: "40px",
        textAlign: "center",
        transition: "background .2s",
        touchAction: "auto"
    };
    Object.keys(styles).forEach((function(key) {
        var name = key;
        eventsPaneEl.style[name] = styles[name];
    }));
    var hintToggle = function(fl) {
        eventsPaneEl.style.background = "rgba(0, 0, 0, ".concat(fl ? ".6" : "0", ")");
        eventsPaneEl.textContent = fl ? text : "";
    };
    if (preventTouch && isTouch) {
        map.behaviors.disable("drag");
        eventsPaneEl.addEventListener("touchstart", (function(e2) {
            hintToggle(e2.touches.length === 1);
        }));
        eventsPaneEl.addEventListener("touchend", (function(e2) {
            hintToggle(false);
        }));
    }
    if (preventScroll && !isTouch) {
        var scrollToggle_1 = function(fl) {
            map.behaviors[fl ? "enable" : "disable"]("scrollZoom");
        };
        var isMouseEnter_1 = false;
        var isCtrlPress_1 = false;
        scrollToggle_1(false);
        eventsPane.events.add("wheel", (function() {
            if (!isMouseEnter_1) return;
            scrollToggle_1(isCtrlPress_1);
            hintToggle(!isCtrlPress_1);
        }));
        eventsPane.events.add("mousedown", (function() {
            hintToggle(false);
        }));
        eventsPane.events.add("mouseenter", (function() {
            isMouseEnter_1 = true;
        }));
        eventsPane.events.add("mouseleave", (function() {
            isMouseEnter_1 = false;
            hintToggle(false);
        }));
        document.addEventListener("keydown", (function(e2) {
            isCtrlPress_1 = e2.ctrlKey;
            if (isCtrlPress_1) hintToggle(false);
        }));
        document.addEventListener("keyup", (function() {
            isCtrlPress_1 = false;
        }));
    }
};

var _default = ymapsTouchScroll$1.default = ymapsTouchScroll;

const t = (t2, e2 = 1e4) => (t2 = parseFloat(t2 + "") || 0, Math.round((t2 + Number.EPSILON) * e2) / e2), e = function(t2) {
    if (!(t2 && t2 instanceof Element && t2.offsetParent)) return false;
    const e2 = t2.scrollHeight > t2.clientHeight, i2 = window.getComputedStyle(t2).overflowY, n2 = -1 !== i2.indexOf("hidden"), s2 = -1 !== i2.indexOf("visible");
    return e2 && !n2 && !s2;
}, i = function(t2, n2 = void 0) {
    return !(!t2 || t2 === document.body || n2 && t2 === n2) && (e(t2) ? t2 : i(t2.parentElement, n2));
}, n = function(t2) {
    var e2 = (new DOMParser).parseFromString(t2, "text/html").body;
    if (e2.childElementCount > 1) {
        for (var i2 = document.createElement("div"); e2.firstChild; ) i2.appendChild(e2.firstChild);
        return i2;
    }
    return e2.firstChild;
}, s = t2 => `${t2 || ""}`.split(" ").filter((t3 => !!t3)), o = (t2, e2, i2) => {
    t2 && s(e2).forEach((e3 => {
        t2.classList.toggle(e3, i2 || false);
    }));
};

class a {
    constructor(t2) {
        Object.defineProperty(this, "pageX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "pageY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "clientX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "clientY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "time", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "nativePointer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), this.nativePointer = t2, this.pageX = t2.pageX, this.pageY = t2.pageY, this.clientX = t2.clientX, 
        this.clientY = t2.clientY, this.id = self.Touch && t2 instanceof Touch ? t2.identifier : -1, 
        this.time = Date.now();
    }
}

const r = {
    passive: false
};

class l {
    constructor(t2, {start: e2 = () => true, move: i2 = () => {}, end: n2 = () => {}}) {
        Object.defineProperty(this, "element", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "startCallback", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "moveCallback", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "endCallback", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "currentPointers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        }), Object.defineProperty(this, "startPointers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        }), this.element = t2, this.startCallback = e2, this.moveCallback = i2, this.endCallback = n2;
        for (const t3 of [ "onPointerStart", "onTouchStart", "onMove", "onTouchEnd", "onPointerEnd", "onWindowBlur" ]) this[t3] = this[t3].bind(this);
        this.element.addEventListener("mousedown", this.onPointerStart, r), this.element.addEventListener("touchstart", this.onTouchStart, r), 
        this.element.addEventListener("touchmove", this.onMove, r), this.element.addEventListener("touchend", this.onTouchEnd), 
        this.element.addEventListener("touchcancel", this.onTouchEnd);
    }
    onPointerStart(t2) {
        if (!t2.buttons || 0 !== t2.button) return;
        const e2 = new a(t2);
        this.currentPointers.some((t3 => t3.id === e2.id)) || this.triggerPointerStart(e2, t2) && (window.addEventListener("mousemove", this.onMove), 
        window.addEventListener("mouseup", this.onPointerEnd), window.addEventListener("blur", this.onWindowBlur));
    }
    onTouchStart(t2) {
        for (const e2 of Array.from(t2.changedTouches || [])) this.triggerPointerStart(new a(e2), t2);
        window.addEventListener("blur", this.onWindowBlur);
    }
    onMove(t2) {
        const e2 = this.currentPointers.slice(), i2 = "changedTouches" in t2 ? Array.from(t2.changedTouches || []).map((t3 => new a(t3))) : [ new a(t2) ], n2 = [];
        for (const t3 of i2) {
            const e3 = this.currentPointers.findIndex((e4 => e4.id === t3.id));
            e3 < 0 || (n2.push(t3), this.currentPointers[e3] = t3);
        }
        n2.length && this.moveCallback(t2, this.currentPointers.slice(), e2);
    }
    onPointerEnd(t2) {
        t2.buttons > 0 && 0 !== t2.button || (this.triggerPointerEnd(t2, new a(t2)), window.removeEventListener("mousemove", this.onMove), 
        window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur));
    }
    onTouchEnd(t2) {
        for (const e2 of Array.from(t2.changedTouches || [])) this.triggerPointerEnd(t2, new a(e2));
    }
    triggerPointerStart(t2, e2) {
        return !!this.startCallback(e2, t2, this.currentPointers.slice()) && (this.currentPointers.push(t2), 
        this.startPointers.push(t2), true);
    }
    triggerPointerEnd(t2, e2) {
        const i2 = this.currentPointers.findIndex((t3 => t3.id === e2.id));
        i2 < 0 || (this.currentPointers.splice(i2, 1), this.startPointers.splice(i2, 1), 
        this.endCallback(t2, e2, this.currentPointers.slice()));
    }
    onWindowBlur() {
        this.clear();
    }
    clear() {
        for (;this.currentPointers.length; ) {
            const t2 = this.currentPointers[this.currentPointers.length - 1];
            this.currentPointers.splice(this.currentPointers.length - 1, 1), this.startPointers.splice(this.currentPointers.length - 1, 1), 
            this.endCallback(new Event("touchend", {
                bubbles: true,
                cancelable: true,
                clientX: t2.clientX,
                clientY: t2.clientY
            }), t2, this.currentPointers.slice());
        }
    }
    stop() {
        this.element.removeEventListener("mousedown", this.onPointerStart, r), this.element.removeEventListener("touchstart", this.onTouchStart, r), 
        this.element.removeEventListener("touchmove", this.onMove, r), this.element.removeEventListener("touchend", this.onTouchEnd), 
        this.element.removeEventListener("touchcancel", this.onTouchEnd), window.removeEventListener("mousemove", this.onMove), 
        window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur);
    }
}

function c(t2, e2) {
    return e2 ? Math.sqrt(Math.pow(e2.clientX - t2.clientX, 2) + Math.pow(e2.clientY - t2.clientY, 2)) : 0;
}

function h(t2, e2) {
    return e2 ? {
        clientX: (t2.clientX + e2.clientX) / 2,
        clientY: (t2.clientY + e2.clientY) / 2
    } : t2;
}

const d = t2 => "object" == typeof t2 && null !== t2 && t2.constructor === Object && "[object Object]" === Object.prototype.toString.call(t2), u = (t2, ...e2) => {
    const i2 = e2.length;
    for (let n2 = 0; n2 < i2; n2++) {
        const i3 = e2[n2] || {};
        Object.entries(i3).forEach((([e3, i4]) => {
            const n3 = Array.isArray(i4) ? [] : {};
            t2[e3] || Object.assign(t2, {
                [e3]: n3
            }), d(i4) ? Object.assign(t2[e3], u(n3, i4)) : Array.isArray(i4) ? Object.assign(t2, {
                [e3]: [ ...i4 ]
            }) : Object.assign(t2, {
                [e3]: i4
            });
        }));
    }
    return t2;
}, p = function(t2, e2) {
    return t2.split(".").reduce(((t3, e3) => "object" == typeof t3 ? t3[e3] : void 0), e2);
};

class f {
    constructor(t2 = {}) {
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: t2
        }), Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value:  new Map
        }), this.setOptions(t2);
        for (const t3 of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) t3.startsWith("on") && "function" == typeof this[t3] && (this[t3] = this[t3].bind(this));
    }
    setOptions(t2) {
        this.options = t2 ? u({}, this.constructor.defaults, t2) : {};
        for (const [t3, e2] of Object.entries(this.option("on") || {})) this.on(t3, e2);
    }
    option(t2, ...e2) {
        let i2 = p(t2, this.options);
        return i2 && "function" == typeof i2 && (i2 = i2.call(this, this, ...e2)), i2;
    }
    optionFor(t2, e2, i2, ...n2) {
        let s2 = p(e2, t2);
        var o2;
        "string" != typeof (o2 = s2) || isNaN(o2) || isNaN(parseFloat(o2)) || (s2 = parseFloat(s2)), 
        "true" === s2 && (s2 = true), "false" === s2 && (s2 = false), s2 && "function" == typeof s2 && (s2 = s2.call(this, this, t2, ...n2));
        let a2 = p(e2, this.options);
        return a2 && "function" == typeof a2 ? s2 = a2.call(this, this, t2, ...n2, s2) : void 0 === s2 && (s2 = a2), 
        void 0 === s2 ? i2 : s2;
    }
    cn(t2) {
        const e2 = this.options.classes;
        return e2 && e2[t2] || "";
    }
    localize(t2, e2 = []) {
        t2 = String(t2).replace(/\{\{(\w+).?(\w+)?\}\}/g, ((t3, e3, i2) => {
            let n2 = "";
            return i2 ? n2 = this.option(`${e3[0] + e3.toLowerCase().substring(1)}.l10n.${i2}`) : e3 && (n2 = this.option(`l10n.${e3}`)), 
            n2 || (n2 = t3), n2;
        }));
        for (let i2 = 0; i2 < e2.length; i2++) t2 = t2.split(e2[i2][0]).join(e2[i2][1]);
        return t2 = t2.replace(/\{\{(.*?)\}\}/g, ((t3, e3) => e3));
    }
    on(t2, e2) {
        let i2 = [];
        "string" == typeof t2 ? i2 = t2.split(" ") : Array.isArray(t2) && (i2 = t2), this.events || (this.events =  new Map), 
        i2.forEach((t3 => {
            let i3 = this.events.get(t3);
            i3 || (this.events.set(t3, []), i3 = []), i3.includes(e2) || i3.push(e2), this.events.set(t3, i3);
        }));
    }
    off(t2, e2) {
        let i2 = [];
        "string" == typeof t2 ? i2 = t2.split(" ") : Array.isArray(t2) && (i2 = t2), i2.forEach((t3 => {
            const i3 = this.events.get(t3);
            if (Array.isArray(i3)) {
                const t4 = i3.indexOf(e2);
                t4 > -1 && i3.splice(t4, 1);
            }
        }));
    }
    emit(t2, ...e2) {
        [ ...this.events.get(t2) || [] ].forEach((t3 => t3(this, ...e2))), "*" !== t2 && this.emit("*", t2, ...e2);
    }
}

Object.defineProperty(f, "version", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "5.0.36"
}), Object.defineProperty(f, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {}
});

class g extends f {
    constructor(t2 = {}) {
        super(t2), Object.defineProperty(this, "plugins", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    attachPlugins(t2 = {}) {
        const e2 =  new Map;
        for (const [i2, n2] of Object.entries(t2)) {
            const t3 = this.option(i2), s2 = this.plugins[i2];
            s2 || false === t3 ? s2 && false === t3 && (s2.detach(), delete this.plugins[i2]) : e2.set(i2, new n2(this, t3 || {}));
        }
        for (const [t3, i2] of e2) this.plugins[t3] = i2, i2.attach();
    }
    detachPlugins(t2) {
        t2 = t2 || Object.keys(this.plugins);
        for (const e2 of t2) {
            const t3 = this.plugins[e2];
            t3 && t3.detach(), delete this.plugins[e2];
        }
        return this.emit("detachPlugins"), this;
    }
}

var m;

!function(t2) {
    t2[t2.Init = 0] = "Init", t2[t2.Error = 1] = "Error", t2[t2.Ready = 2] = "Ready", 
    t2[t2.Panning = 3] = "Panning", t2[t2.Mousemove = 4] = "Mousemove", t2[t2.Destroy = 5] = "Destroy";
}(m || (m = {}));

const v = [ "a", "b", "c", "d", "e", "f" ], b = {
    PANUP: "Move up",
    PANDOWN: "Move down",
    PANLEFT: "Move left",
    PANRIGHT: "Move right",
    ZOOMIN: "Zoom in",
    ZOOMOUT: "Zoom out",
    TOGGLEZOOM: "Toggle zoom level",
    TOGGLE1TO1: "Toggle zoom level",
    ITERATEZOOM: "Toggle zoom level",
    ROTATECCW: "Rotate counterclockwise",
    ROTATECW: "Rotate clockwise",
    FLIPX: "Flip horizontally",
    FLIPY: "Flip vertically",
    FITX: "Fit horizontally",
    FITY: "Fit vertically",
    RESET: "Reset",
    TOGGLEFS: "Toggle fullscreen"
}, y = {
    content: null,
    width: "auto",
    height: "auto",
    panMode: "drag",
    touch: true,
    dragMinThreshold: 3,
    lockAxis: false,
    mouseMoveFactor: 1,
    mouseMoveFriction: .12,
    zoom: true,
    pinchToZoom: true,
    panOnlyZoomed: "auto",
    minScale: 1,
    maxScale: 2,
    friction: .25,
    dragFriction: .35,
    decelFriction: .05,
    click: "toggleZoom",
    dblClick: false,
    wheel: "zoom",
    wheelLimit: 7,
    spinner: true,
    bounds: "auto",
    infinite: false,
    rubberband: true,
    bounce: true,
    maxVelocity: 75,
    transformParent: false,
    classes: {
        content: "f-panzoom__content",
        isLoading: "is-loading",
        canZoomIn: "can-zoom_in",
        canZoomOut: "can-zoom_out",
        isDraggable: "is-draggable",
        isDragging: "is-dragging",
        inFullscreen: "in-fullscreen",
        htmlHasFullscreen: "with-panzoom-in-fullscreen"
    },
    l10n: b
}, w = '<circle cx="25" cy="25" r="20"></circle>', x = '<div class="f-spinner"><svg viewBox="0 0 50 50">' + w + w + "</svg></div>", E = t2 => t2 && null !== t2 && t2 instanceof Element && "nodeType" in t2, S = (t2, e2) => {
    t2 && s(e2).forEach((e3 => {
        t2.classList.remove(e3);
    }));
}, P = (t2, e2) => {
    t2 && s(e2).forEach((e3 => {
        t2.classList.add(e3);
    }));
}, C = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
}, T = 1e5, M = 1e4, O = "mousemove", A = "drag", L = "content", z = "auto";

let R = null, k = null;

class I extends g {
    get fits() {
        return this.contentRect.width - this.contentRect.fitWidth < 1 && this.contentRect.height - this.contentRect.fitHeight < 1;
    }
    get isTouchDevice() {
        return null === k && (k = window.matchMedia("(hover: none)").matches), k;
    }
    get isMobile() {
        return null === R && (R = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)), 
        R;
    }
    get panMode() {
        return this.options.panMode !== O || this.isTouchDevice ? A : O;
    }
    get panOnlyZoomed() {
        const t2 = this.options.panOnlyZoomed;
        return t2 === z ? this.isTouchDevice : t2;
    }
    get isInfinite() {
        return this.option("infinite");
    }
    get angle() {
        return 180 * Math.atan2(this.current.b, this.current.a) / Math.PI || 0;
    }
    get targetAngle() {
        return 180 * Math.atan2(this.target.b, this.target.a) / Math.PI || 0;
    }
    get scale() {
        const {a: t2, b: e2} = this.current;
        return Math.sqrt(t2 * t2 + e2 * e2) || 1;
    }
    get targetScale() {
        const {a: t2, b: e2} = this.target;
        return Math.sqrt(t2 * t2 + e2 * e2) || 1;
    }
    get minScale() {
        return this.option("minScale") || 1;
    }
    get fullScale() {
        const {contentRect: t2} = this;
        return t2.fullWidth / t2.fitWidth || 1;
    }
    get maxScale() {
        return this.fullScale * (this.option("maxScale") || 1) || 1;
    }
    get coverScale() {
        const {containerRect: t2, contentRect: e2} = this, i2 = Math.max(t2.height / e2.fitHeight, t2.width / e2.fitWidth) || 1;
        return Math.min(this.fullScale, i2);
    }
    get isScaling() {
        return Math.abs(this.targetScale - this.scale) > 1e-5 && !this.isResting;
    }
    get isContentLoading() {
        const t2 = this.content;
        return !!(t2 && t2 instanceof HTMLImageElement) && !t2.complete;
    }
    get isResting() {
        if (this.isBouncingX || this.isBouncingY) return false;
        for (const t2 of v) {
            const e2 = "e" == t2 || "f" === t2 ? 1e-4 : 1e-5;
            if (Math.abs(this.target[t2] - this.current[t2]) > e2) return false;
        }
        return !(!this.ignoreBounds && !this.checkBounds().inBounds);
    }
    constructor(t2, e2 = {}, i2 = {}) {
        var s2;
        if (super(e2), Object.defineProperty(this, "pointerTracker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "resizeObserver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "updateTimer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "clickTimer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "rAF", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "isTicking", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "ignoreBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "isBouncingX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "isBouncingY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "clicks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "trackingPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        }), Object.defineProperty(this, "pwt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "cwd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "pmme", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "friction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: m.Init
        }), Object.defineProperty(this, "isDragging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "content", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "spinner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "containerRect", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                width: 0,
                height: 0,
                innerWidth: 0,
                innerHeight: 0
            }
        }), Object.defineProperty(this, "contentRect", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
                fullWidth: 0,
                fullHeight: 0,
                fitWidth: 0,
                fitHeight: 0,
                width: 0,
                height: 0
            }
        }), Object.defineProperty(this, "dragStart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                x: 0,
                y: 0,
                top: 0,
                left: 0,
                time: 0
            }
        }), Object.defineProperty(this, "dragOffset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                x: 0,
                y: 0,
                time: 0
            }
        }), Object.defineProperty(this, "current", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object.assign({}, C)
        }), Object.defineProperty(this, "target", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object.assign({}, C)
        }), Object.defineProperty(this, "velocity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                a: 0,
                b: 0,
                c: 0,
                d: 0,
                e: 0,
                f: 0
            }
        }), Object.defineProperty(this, "lockedAxis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), !t2) throw new Error("Container Element Not Found");
        this.container = t2, this.initContent(), this.attachPlugins(Object.assign(Object.assign({}, I.Plugins), i2)), 
        this.emit("attachPlugins"), this.emit("init");
        const o2 = this.content;
        if (o2.addEventListener("load", this.onLoad), o2.addEventListener("error", this.onError), 
        this.isContentLoading) {
            if (this.option("spinner")) {
                t2.classList.add(this.cn("isLoading"));
                const e3 = n(x);
                !t2.contains(o2) || o2.parentElement instanceof HTMLPictureElement ? this.spinner = t2.appendChild(e3) : this.spinner = (null === (s2 = o2.parentElement) || void 0 === s2 ? void 0 : s2.insertBefore(e3, o2)) || null;
            }
            this.emit("beforeLoad");
        } else queueMicrotask((() => {
            this.enable();
        }));
    }
    initContent() {
        const {container: t2} = this, e2 = this.cn(L);
        let i2 = this.option(L) || t2.querySelector(`.${e2}`);
        if (i2 || (i2 = t2.querySelector("img,picture") || t2.firstElementChild, i2 && P(i2, e2)), 
        i2 instanceof HTMLPictureElement && (i2 = i2.querySelector("img")), !i2) throw new Error("No content found");
        this.content = i2;
    }
    onLoad() {
        const {spinner: t2, container: e2, state: i2} = this;
        t2 && (t2.remove(), this.spinner = null), this.option("spinner") && e2.classList.remove(this.cn("isLoading")), 
        this.emit("afterLoad"), i2 === m.Init ? this.enable() : this.updateMetrics();
    }
    onError() {
        this.state !== m.Destroy && (this.spinner && (this.spinner.remove(), this.spinner = null), 
        this.stop(), this.detachEvents(), this.state = m.Error, this.emit("error"));
    }
    getNextScale(t2) {
        const {fullScale: e2, targetScale: i2, coverScale: n2, maxScale: s2, minScale: o2} = this;
        let a2 = o2;
        switch (t2) {
          case "toggleMax":
            a2 = i2 - o2 < .5 * (s2 - o2) ? s2 : o2;
            break;

          case "toggleCover":
            a2 = i2 - o2 < .5 * (n2 - o2) ? n2 : o2;
            break;

          case "toggleZoom":
            a2 = i2 - o2 < .5 * (e2 - o2) ? e2 : o2;
            break;

          case "iterateZoom":
            let t3 = [ 1, e2, s2 ].sort(((t4, e3) => t4 - e3)), r2 = t3.findIndex((t4 => t4 > i2 + 1e-5));
            a2 = t3[r2] || 1;
        }
        return a2;
    }
    attachObserver() {
        var t2;
        const e2 = () => {
            const {container: t3, containerRect: e3} = this;
            return Math.abs(e3.width - t3.getBoundingClientRect().width) > .1 || Math.abs(e3.height - t3.getBoundingClientRect().height) > .1;
        };
        this.resizeObserver || void 0 === window.ResizeObserver || (this.resizeObserver = new ResizeObserver((() => {
            this.updateTimer || (e2() ? (this.onResize(), this.isMobile && (this.updateTimer = setTimeout((() => {
                e2() && this.onResize(), this.updateTimer = null;
            }), 500))) : this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null));
        }))), null === (t2 = this.resizeObserver) || void 0 === t2 || t2.observe(this.container);
    }
    detachObserver() {
        var t2;
        null === (t2 = this.resizeObserver) || void 0 === t2 || t2.disconnect();
    }
    attachEvents() {
        const {container: t2} = this;
        t2.addEventListener("click", this.onClick, {
            passive: false,
            capture: false
        }), t2.addEventListener("wheel", this.onWheel, {
            passive: false
        }), this.pointerTracker = new l(t2, {
            start: this.onPointerDown,
            move: this.onPointerMove,
            end: this.onPointerUp
        }), document.addEventListener(O, this.onMouseMove);
    }
    detachEvents() {
        var t2;
        const {container: e2} = this;
        e2.removeEventListener("click", this.onClick, {
            passive: false,
            capture: false
        }), e2.removeEventListener("wheel", this.onWheel, {
            passive: false
        }), null === (t2 = this.pointerTracker) || void 0 === t2 || t2.stop(), this.pointerTracker = null, 
        document.removeEventListener(O, this.onMouseMove), document.removeEventListener("keydown", this.onKeydown, true), 
        this.clickTimer && (clearTimeout(this.clickTimer), this.clickTimer = null), this.updateTimer && (clearTimeout(this.updateTimer), 
        this.updateTimer = null);
    }
    animate() {
        this.setTargetForce();
        const t2 = this.friction, e2 = this.option("maxVelocity");
        for (const i2 of v) t2 ? (this.velocity[i2] *= 1 - t2, e2 && !this.isScaling && (this.velocity[i2] = Math.max(Math.min(this.velocity[i2], e2), -1 * e2)), 
        this.current[i2] += this.velocity[i2]) : this.current[i2] = this.target[i2];
        this.setTransform(), this.setEdgeForce(), !this.isResting || this.isDragging ? this.rAF = requestAnimationFrame((() => this.animate())) : this.stop("current");
    }
    setTargetForce() {
        for (const t2 of v) "e" === t2 && this.isBouncingX || "f" === t2 && this.isBouncingY || (this.velocity[t2] = (1 / (1 - this.friction) - 1) * (this.target[t2] - this.current[t2]));
    }
    checkBounds(t2 = 0, e2 = 0) {
        const {current: i2} = this, n2 = i2.e + t2, s2 = i2.f + e2, o2 = this.getBounds(), {x: a2, y: r2} = o2, l2 = a2.min, c2 = a2.max, h2 = r2.min, d2 = r2.max;
        let u2 = 0, p2 = 0;
        return l2 !== 1 / 0 && n2 < l2 ? u2 = l2 - n2 : c2 !== 1 / 0 && n2 > c2 && (u2 = c2 - n2), 
        h2 !== 1 / 0 && s2 < h2 ? p2 = h2 - s2 : d2 !== 1 / 0 && s2 > d2 && (p2 = d2 - s2), 
        Math.abs(u2) < 1e-4 && (u2 = 0), Math.abs(p2) < 1e-4 && (p2 = 0), Object.assign(Object.assign({}, o2), {
            xDiff: u2,
            yDiff: p2,
            inBounds: !u2 && !p2
        });
    }
    clampTargetBounds() {
        const {target: t2} = this, {x: e2, y: i2} = this.getBounds();
        e2.min !== 1 / 0 && (t2.e = Math.max(t2.e, e2.min)), e2.max !== 1 / 0 && (t2.e = Math.min(t2.e, e2.max)), 
        i2.min !== 1 / 0 && (t2.f = Math.max(t2.f, i2.min)), i2.max !== 1 / 0 && (t2.f = Math.min(t2.f, i2.max));
    }
    calculateContentDim(t2 = this.current) {
        const {content: e2, contentRect: i2} = this, {fitWidth: n2, fitHeight: s2, fullWidth: o2, fullHeight: a2} = i2;
        let r2 = o2, l2 = a2;
        if (this.option("zoom") || 0 !== this.angle) {
            const i3 = !(e2 instanceof HTMLImageElement) && ("none" === window.getComputedStyle(e2).maxWidth || "none" === window.getComputedStyle(e2).maxHeight), c2 = i3 ? o2 : n2, h2 = i3 ? a2 : s2, d2 = this.getMatrix(t2), u2 = new DOMPoint(0, 0).matrixTransform(d2), p2 = new DOMPoint(0 + c2, 0).matrixTransform(d2), f2 = new DOMPoint(0 + c2, 0 + h2).matrixTransform(d2), g2 = new DOMPoint(0, 0 + h2).matrixTransform(d2), m2 = Math.abs(f2.x - u2.x), v2 = Math.abs(f2.y - u2.y), b2 = Math.abs(g2.x - p2.x), y2 = Math.abs(g2.y - p2.y);
            r2 = Math.max(m2, b2), l2 = Math.max(v2, y2);
        }
        return {
            contentWidth: r2,
            contentHeight: l2
        };
    }
    setEdgeForce() {
        if (this.ignoreBounds || this.isDragging || this.panMode === O || this.targetScale < this.scale) return this.isBouncingX = false, 
        void (this.isBouncingY = false);
        const {target: t2} = this, {x: e2, y: i2, xDiff: n2, yDiff: s2} = this.checkBounds();
        const o2 = this.option("maxVelocity");
        let a2 = this.velocity.e, r2 = this.velocity.f;
        0 !== n2 ? (this.isBouncingX = true, n2 * a2 <= 0 ? a2 += .14 * n2 : (a2 = .14 * n2, 
        e2.min !== 1 / 0 && (this.target.e = Math.max(t2.e, e2.min)), e2.max !== 1 / 0 && (this.target.e = Math.min(t2.e, e2.max))), 
        o2 && (a2 = Math.max(Math.min(a2, o2), -1 * o2))) : this.isBouncingX = false, 0 !== s2 ? (this.isBouncingY = true, 
        s2 * r2 <= 0 ? r2 += .14 * s2 : (r2 = .14 * s2, i2.min !== 1 / 0 && (this.target.f = Math.max(t2.f, i2.min)), 
        i2.max !== 1 / 0 && (this.target.f = Math.min(t2.f, i2.max))), o2 && (r2 = Math.max(Math.min(r2, o2), -1 * o2))) : this.isBouncingY = false, 
        this.isBouncingX && (this.velocity.e = a2), this.isBouncingY && (this.velocity.f = r2);
    }
    enable() {
        const {content: t2} = this, e2 = new DOMMatrixReadOnly(window.getComputedStyle(t2).transform);
        for (const t3 of v) this.current[t3] = this.target[t3] = e2[t3];
        this.updateMetrics(), this.attachObserver(), this.attachEvents(), this.state = m.Ready, 
        this.emit("ready");
    }
    onClick(t2) {
        var e2;
        "click" === t2.type && 0 === t2.detail && (this.dragOffset.x = 0, this.dragOffset.y = 0), 
        this.isDragging && (null === (e2 = this.pointerTracker) || void 0 === e2 || e2.clear(), 
        this.trackingPoints = [], this.startDecelAnim());
        const i2 = t2.target;
        if (!i2 || t2.defaultPrevented) return;
        if (i2.hasAttribute("disabled")) return t2.preventDefault(), void t2.stopPropagation();
        if ((() => {
            const t3 = window.getSelection();
            return t3 && "Range" === t3.type;
        })() && !i2.closest("button")) return;
        const n2 = i2.closest("[data-panzoom-action]"), s2 = i2.closest("[data-panzoom-change]"), o2 = n2 || s2, a2 = o2 && E(o2) ? o2.dataset : null;
        if (a2) {
            const e3 = a2.panzoomChange, i3 = a2.panzoomAction;
            if ((e3 || i3) && t2.preventDefault(), e3) {
                let t3 = {};
                try {
                    t3 = JSON.parse(e3);
                } catch (t4) {
                    console && console.warn("The given data was not valid JSON");
                }
                return void this.applyChange(t3);
            }
            if (i3) return void (this[i3] && this[i3]());
        }
        if (Math.abs(this.dragOffset.x) > 3 || Math.abs(this.dragOffset.y) > 3) return t2.preventDefault(), 
        void t2.stopPropagation();
        if (i2.closest("[data-fancybox]")) return;
        const r2 = this.content.getBoundingClientRect(), l2 = this.dragStart;
        if (l2.time && !this.canZoomOut() && (Math.abs(r2.x - l2.x) > 2 || Math.abs(r2.y - l2.y) > 2)) return;
        this.dragStart.time = 0;
        const c2 = e3 => {
            this.option("zoom", t2) && e3 && "string" == typeof e3 && /(iterateZoom)|(toggle(Zoom|Full|Cover|Max)|(zoomTo(Fit|Cover|Max)))/.test(e3) && "function" == typeof this[e3] && (t2.preventDefault(), 
            this[e3]({
                event: t2
            }));
        }, h2 = this.option("click", t2), d2 = this.option("dblClick", t2);
        d2 ? (this.clicks++, 1 == this.clicks && (this.clickTimer = setTimeout((() => {
            1 === this.clicks ? (this.emit("click", t2), !t2.defaultPrevented && h2 && c2(h2)) : (this.emit("dblClick", t2), 
            t2.defaultPrevented || c2(d2)), this.clicks = 0, this.clickTimer = null;
        }), 350))) : (this.emit("click", t2), !t2.defaultPrevented && h2 && c2(h2));
    }
    addTrackingPoint(t2) {
        const e2 = this.trackingPoints.filter((t3 => t3.time > Date.now() - 100));
        e2.push(t2), this.trackingPoints = e2;
    }
    onPointerDown(t2, e2, i2) {
        var n2;
        if (false === this.option("touch", t2)) return false;
        this.pwt = 0, this.dragOffset = {
            x: 0,
            y: 0,
            time: 0
        }, this.trackingPoints = [];
        const s2 = this.content.getBoundingClientRect();
        if (this.dragStart = {
            x: s2.x,
            y: s2.y,
            top: s2.top,
            left: s2.left,
            time: Date.now()
        }, this.clickTimer) return false;
        if (this.panMode === O && this.targetScale > 1) return t2.preventDefault(), t2.stopPropagation(), 
        false;
        const o2 = t2.composedPath()[0];
        if (!i2.length) {
            if ([ "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO", "IFRAME" ].includes(o2.nodeName) || o2.closest("[contenteditable],[data-selectable],[data-draggable],[data-clickable],[data-panzoom-change],[data-panzoom-action]")) return false;
            null === (n2 = window.getSelection()) || void 0 === n2 || n2.removeAllRanges();
        }
        if ("mousedown" === t2.type) [ "A", "BUTTON" ].includes(o2.nodeName) || t2.preventDefault(); else if (Math.abs(this.velocity.a) > .3) return false;
        return this.target.e = this.current.e, this.target.f = this.current.f, this.stop(), 
        this.isDragging || (this.isDragging = true, this.addTrackingPoint(e2), this.emit("touchStart", t2)), 
        true;
    }
    onPointerMove(e2, n2, s2) {
        if (false === this.option("touch", e2)) return;
        if (!this.isDragging) return;
        if (n2.length < 2 && this.panOnlyZoomed && t(this.targetScale) <= t(this.minScale)) return;
        if (this.emit("touchMove", e2), e2.defaultPrevented) return;
        this.addTrackingPoint(n2[0]);
        const {content: o2} = this, a2 = h(s2[0], s2[1]), r2 = h(n2[0], n2[1]);
        let l2 = 0, d2 = 0;
        if (n2.length > 1) {
            const t2 = o2.getBoundingClientRect();
            l2 = a2.clientX - t2.left - .5 * t2.width, d2 = a2.clientY - t2.top - .5 * t2.height;
        }
        const u2 = c(s2[0], s2[1]), p2 = c(n2[0], n2[1]);
        let f2 = u2 ? p2 / u2 : 1, g2 = r2.clientX - a2.clientX, m2 = r2.clientY - a2.clientY;
        this.dragOffset.x += g2, this.dragOffset.y += m2, this.dragOffset.time = Date.now() - this.dragStart.time;
        let v2 = t(this.targetScale) === t(this.minScale) && this.option("lockAxis");
        if (v2 && !this.lockedAxis) if ("xy" === v2 || "y" === v2 || "touchmove" === e2.type) {
            if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) return void e2.preventDefault();
            const t2 = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI);
            this.lockedAxis = t2 > 45 && t2 < 135 ? "y" : "x", this.dragOffset.x = 0, this.dragOffset.y = 0, 
            g2 = 0, m2 = 0;
        } else this.lockedAxis = v2;
        if (i(e2.target, this.content) && (v2 = "x", this.dragOffset.y = 0), v2 && "xy" !== v2 && this.lockedAxis !== v2 && t(this.targetScale) === t(this.minScale)) return;
        e2.cancelable && e2.preventDefault(), this.container.classList.add(this.cn("isDragging"));
        const b2 = this.checkBounds(g2, m2);
        this.option("rubberband") ? ("x" !== this.isInfinite && (b2.xDiff > 0 && g2 < 0 || b2.xDiff < 0 && g2 > 0) && (g2 *= Math.max(0, .5 - Math.abs(.75 / this.contentRect.fitWidth * b2.xDiff))), 
        "y" !== this.isInfinite && (b2.yDiff > 0 && m2 < 0 || b2.yDiff < 0 && m2 > 0) && (m2 *= Math.max(0, .5 - Math.abs(.75 / this.contentRect.fitHeight * b2.yDiff)))) : (b2.xDiff && (g2 = 0), 
        b2.yDiff && (m2 = 0));
        const y2 = this.targetScale, w2 = this.minScale, x2 = this.maxScale;
        y2 < .5 * w2 && (f2 = Math.max(f2, w2)), y2 > 1.5 * x2 && (f2 = Math.min(f2, x2)), 
        "y" === this.lockedAxis && t(y2) === t(w2) && (g2 = 0), "x" === this.lockedAxis && t(y2) === t(w2) && (m2 = 0), 
        this.applyChange({
            originX: l2,
            originY: d2,
            panX: g2,
            panY: m2,
            scale: f2,
            friction: this.option("dragFriction"),
            ignoreBounds: true
        });
    }
    onPointerUp(t2, e2, n2) {
        if (n2.length) return this.dragOffset.x = 0, this.dragOffset.y = 0, void (this.trackingPoints = []);
        this.container.classList.remove(this.cn("isDragging")), this.isDragging && (this.addTrackingPoint(e2), 
        this.panOnlyZoomed && this.contentRect.width - this.contentRect.fitWidth < 1 && this.contentRect.height - this.contentRect.fitHeight < 1 && (this.trackingPoints = []), 
        i(t2.target, this.content) && "y" === this.lockedAxis && (this.trackingPoints = []), 
        this.emit("touchEnd", t2), this.isDragging = false, this.lockedAxis = false, this.state !== m.Destroy && (t2.defaultPrevented || this.startDecelAnim()));
    }
    startDecelAnim() {
        var e2;
        const i2 = this.isScaling;
        this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = false, 
        this.isBouncingY = false;
        for (const t2 of v) this.velocity[t2] = 0;
        this.target.e = this.current.e, this.target.f = this.current.f, S(this.container, "is-scaling"), 
        S(this.container, "is-animating"), this.isTicking = false;
        const {trackingPoints: n2} = this, s2 = n2[0], o2 = n2[n2.length - 1];
        let a2 = 0, r2 = 0, l2 = 0;
        o2 && s2 && (a2 = o2.clientX - s2.clientX, r2 = o2.clientY - s2.clientY, l2 = o2.time - s2.time);
        const c2 = (null === (e2 = window.visualViewport) || void 0 === e2 ? void 0 : e2.scale) || 1;
        1 !== c2 && (a2 *= c2, r2 *= c2);
        let h2 = 0, d2 = 0, u2 = 0, p2 = 0, f2 = this.option("decelFriction");
        const g2 = this.targetScale;
        if (l2 > 0) {
            u2 = Math.abs(a2) > 3 ? a2 / (l2 / 30) : 0, p2 = Math.abs(r2) > 3 ? r2 / (l2 / 30) : 0;
            const t2 = this.option("maxVelocity");
            t2 && (u2 = Math.max(Math.min(u2, t2), -1 * t2), p2 = Math.max(Math.min(p2, t2), -1 * t2));
        }
        u2 && (h2 = u2 / (1 / (1 - f2) - 1)), p2 && (d2 = p2 / (1 / (1 - f2) - 1)), ("y" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "y" === this.lockedAxis && t(g2) === this.minScale) && (h2 = u2 = 0), 
        ("x" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "x" === this.lockedAxis && t(g2) === this.minScale) && (d2 = p2 = 0);
        const m2 = this.dragOffset.x, b2 = this.dragOffset.y, y2 = this.option("dragMinThreshold") || 0;
        Math.abs(m2) < y2 && Math.abs(b2) < y2 && (h2 = d2 = 0, u2 = p2 = 0), (this.option("zoom") && (g2 < this.minScale - 1e-5 || g2 > this.maxScale + 1e-5) || i2 && !h2 && !d2) && (f2 = .35), 
        this.applyChange({
            panX: h2,
            panY: d2,
            friction: f2
        }), this.emit("decel", u2, p2, m2, b2);
    }
    onWheel(t2) {
        var e2 = [ -t2.deltaX || 0, -t2.deltaY || 0, -t2.detail || 0 ].reduce((function(t3, e3) {
            return Math.abs(e3) > Math.abs(t3) ? e3 : t3;
        }));
        const i2 = Math.max(-1, Math.min(1, e2));
        if (this.emit("wheel", t2, i2), this.panMode === O) return;
        if (t2.defaultPrevented) return;
        const n2 = this.option("wheel");
        "pan" === n2 ? (t2.preventDefault(), this.panOnlyZoomed && !this.canZoomOut() || this.applyChange({
            panX: 2 * -t2.deltaX,
            panY: 2 * -t2.deltaY,
            bounce: false
        })) : "zoom" === n2 && false !== this.option("zoom") && this.zoomWithWheel(t2);
    }
    onMouseMove(t2) {
        this.panWithMouse(t2);
    }
    onKeydown(t2) {
        "Escape" === t2.key && this.toggleFS();
    }
    onResize() {
        this.updateMetrics(), this.checkBounds().inBounds || this.requestTick();
    }
    setTransform() {
        this.emit("beforeTransform");
        const {current: e2, target: i2, content: n2, contentRect: s2} = this, o2 = Object.assign({}, C);
        for (const n3 of v) {
            const s3 = "e" == n3 || "f" === n3 ? M : T;
            o2[n3] = t(e2[n3], s3), Math.abs(i2[n3] - e2[n3]) < ("e" == n3 || "f" === n3 ? .51 : .001) && (e2[n3] = i2[n3]);
        }
        let {a: a2, b: r2, c: l2, d: c2, e: h2, f: d2} = o2, u2 = `matrix(${a2}, ${r2}, ${l2}, ${c2}, ${h2}, ${d2})`, p2 = n2.parentElement instanceof HTMLPictureElement ? n2.parentElement : n2;
        if (this.option("transformParent") && (p2 = p2.parentElement || p2), p2.style.transform === u2) return;
        p2.style.transform = u2;
        const {contentWidth: f2, contentHeight: g2} = this.calculateContentDim();
        s2.width = f2, s2.height = g2, this.emit("afterTransform");
    }
    updateMetrics(e2 = false) {
        var i2;
        if (!this || this.state === m.Destroy) return;
        if (this.isContentLoading) return;
        const n2 = Math.max(1, (null === (i2 = window.visualViewport) || void 0 === i2 ? void 0 : i2.scale) || 1), {container: s2, content: o2} = this, a2 = o2 instanceof HTMLImageElement, r2 = s2.getBoundingClientRect(), l2 = getComputedStyle(this.container);
        let c2 = r2.width * n2, h2 = r2.height * n2;
        const d2 = parseFloat(l2.paddingTop) + parseFloat(l2.paddingBottom), u2 = c2 - (parseFloat(l2.paddingLeft) + parseFloat(l2.paddingRight)), p2 = h2 - d2;
        this.containerRect = {
            width: c2,
            height: h2,
            innerWidth: u2,
            innerHeight: p2
        };
        const f2 = parseFloat(o2.dataset.width || "") || (t2 => {
            let e3 = 0;
            return e3 = t2 instanceof HTMLImageElement ? t2.naturalWidth : t2 instanceof SVGElement ? t2.width.baseVal.value : Math.max(t2.offsetWidth, t2.scrollWidth), 
            e3 || 0;
        })(o2), g2 = parseFloat(o2.dataset.height || "") || (t2 => {
            let e3 = 0;
            return e3 = t2 instanceof HTMLImageElement ? t2.naturalHeight : t2 instanceof SVGElement ? t2.height.baseVal.value : Math.max(t2.offsetHeight, t2.scrollHeight), 
            e3 || 0;
        })(o2);
        let v2 = this.option("width", f2) || z, b2 = this.option("height", g2) || z;
        const y2 = v2 === z, w2 = b2 === z;
        "number" != typeof v2 && (v2 = f2), "number" != typeof b2 && (b2 = g2), y2 && (v2 = f2 * (b2 / g2)), 
        w2 && (b2 = g2 / (f2 / v2));
        let x2 = o2.parentElement instanceof HTMLPictureElement ? o2.parentElement : o2;
        this.option("transformParent") && (x2 = x2.parentElement || x2);
        const E2 = x2.getAttribute("style") || "";
        x2.style.setProperty("transform", "none", "important"), a2 && (x2.style.width = "", 
        x2.style.height = ""), x2.offsetHeight;
        const S2 = o2.getBoundingClientRect();
        let P2 = S2.width * n2, C2 = S2.height * n2, T2 = P2, M2 = C2;
        P2 = Math.min(P2, v2), C2 = Math.min(C2, b2), a2 ? ({width: P2, height: C2} = ((t2, e3, i3, n3) => {
            const s3 = i3 / t2, o3 = n3 / e3, a3 = Math.min(s3, o3);
            return {
                width: t2 *= a3,
                height: e3 *= a3
            };
        })(v2, b2, P2, C2)) : (P2 = Math.min(P2, v2), C2 = Math.min(C2, b2));
        let O2 = .5 * (M2 - C2), A2 = .5 * (T2 - P2);
        this.contentRect = Object.assign(Object.assign({}, this.contentRect), {
            top: S2.top - r2.top + O2,
            bottom: r2.bottom - S2.bottom + O2,
            left: S2.left - r2.left + A2,
            right: r2.right - S2.right + A2,
            fitWidth: P2,
            fitHeight: C2,
            width: P2,
            height: C2,
            fullWidth: v2,
            fullHeight: b2
        }), x2.style.cssText = E2, a2 && (x2.style.width = `${P2}px`, x2.style.height = `${C2}px`), 
        this.setTransform(), true !== e2 && this.emit("refresh"), this.ignoreBounds || (t(this.targetScale) < t(this.minScale) ? this.zoomTo(this.minScale, {
            friction: 0
        }) : this.targetScale > this.maxScale ? this.zoomTo(this.maxScale, {
            friction: 0
        }) : this.state === m.Init || this.checkBounds().inBounds || this.requestTick()), 
        this.updateControls();
    }
    calculateBounds() {
        const {contentWidth: e2, contentHeight: i2} = this.calculateContentDim(this.target), {targetScale: n2, lockedAxis: s2} = this, {fitWidth: o2, fitHeight: a2} = this.contentRect;
        let r2 = 0, l2 = 0, c2 = 0, h2 = 0;
        const d2 = this.option("infinite");
        if (true === d2 || s2 && d2 === s2) r2 = -1 / 0, c2 = 1 / 0, l2 = -1 / 0, h2 = 1 / 0; else {
            let {containerRect: s3, contentRect: d3} = this, u2 = t(o2 * n2, M), p2 = t(a2 * n2, M), {innerWidth: f2, innerHeight: g2} = s3;
            if (s3.width === u2 && (f2 = s3.width), s3.width === p2 && (g2 = s3.height), e2 > f2) {
                c2 = .5 * (e2 - f2), r2 = -1 * c2;
                let t2 = .5 * (d3.right - d3.left);
                r2 += t2, c2 += t2;
            }
            if (o2 > f2 && e2 < f2 && (r2 -= .5 * (o2 - f2), c2 -= .5 * (o2 - f2)), i2 > g2) {
                h2 = .5 * (i2 - g2), l2 = -1 * h2;
                let t2 = .5 * (d3.bottom - d3.top);
                l2 += t2, h2 += t2;
            }
            a2 > g2 && i2 < g2 && (r2 -= .5 * (a2 - g2), c2 -= .5 * (a2 - g2));
        }
        return {
            x: {
                min: r2,
                max: c2
            },
            y: {
                min: l2,
                max: h2
            }
        };
    }
    getBounds() {
        const t2 = this.option("bounds");
        return t2 !== z ? t2 : this.calculateBounds();
    }
    updateControls() {
        const e2 = this, i2 = e2.container, {panMode: n2, contentRect: s2, targetScale: a2, minScale: r2} = e2;
        let l2 = r2, c2 = e2.option("click") || false;
        c2 && (l2 = e2.getNextScale(c2));
        let h2 = e2.canZoomIn(), d2 = e2.canZoomOut(), u2 = n2 === A && !!this.option("touch"), p2 = d2 && u2;
        if (u2 && (t(a2) < t(r2) && !this.panOnlyZoomed && (p2 = true), (t(s2.width, 1) > t(s2.fitWidth, 1) || t(s2.height, 1) > t(s2.fitHeight, 1)) && (p2 = true)), 
        t(s2.width * a2, 1) < t(s2.fitWidth, 1) && (p2 = false), n2 === O && (p2 = false), 
        o(i2, this.cn("isDraggable"), p2), !this.option("zoom")) return;
        let f2 = h2 && t(l2) > t(a2), g2 = !f2 && !p2 && d2 && t(l2) < t(a2);
        o(i2, this.cn("canZoomIn"), f2), o(i2, this.cn("canZoomOut"), g2);
        for (const t2 of i2.querySelectorAll("[data-panzoom-action]")) {
            let e3 = false, i3 = false;
            switch (t2.dataset.panzoomAction) {
              case "zoomIn":
                h2 ? e3 = true : i3 = true;
                break;

              case "zoomOut":
                d2 ? e3 = true : i3 = true;
                break;

              case "toggleZoom":
              case "iterateZoom":
                h2 || d2 ? e3 = true : i3 = true;
                const n3 = t2.querySelector("g");
                n3 && (n3.style.display = h2 ? "" : "none");
            }
            e3 ? (t2.removeAttribute("disabled"), t2.removeAttribute("tabindex")) : i3 && (t2.setAttribute("disabled", ""), 
            t2.setAttribute("tabindex", "-1"));
        }
    }
    panTo({x: t2 = this.target.e, y: e2 = this.target.f, scale: i2 = this.targetScale, friction: n2 = this.option("friction"), angle: s2 = 0, originX: o2 = 0, originY: a2 = 0, flipX: r2 = false, flipY: l2 = false, ignoreBounds: c2 = false}) {
        this.state !== m.Destroy && this.applyChange({
            panX: t2 - this.target.e,
            panY: e2 - this.target.f,
            scale: i2 / this.targetScale,
            angle: s2,
            originX: o2,
            originY: a2,
            friction: n2,
            flipX: r2,
            flipY: l2,
            ignoreBounds: c2
        });
    }
    applyChange({panX: e2 = 0, panY: i2 = 0, scale: n2 = 1, angle: s2 = 0, originX: o2 = -this.current.e, originY: a2 = -this.current.f, friction: r2 = this.option("friction"), flipX: l2 = false, flipY: c2 = false, ignoreBounds: h2 = false, bounce: d2 = this.option("bounce")}) {
        const u2 = this.state;
        if (u2 === m.Destroy) return;
        this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.friction = r2 || 0, 
        this.ignoreBounds = h2;
        const {current: p2} = this, f2 = p2.e, g2 = p2.f, b2 = this.getMatrix(this.target);
        let y2 = (new DOMMatrix).translate(f2, g2).translate(o2, a2).translate(e2, i2);
        if (this.option("zoom")) {
            if (!h2) {
                const t2 = this.targetScale, e3 = this.minScale, i3 = this.maxScale;
                t2 * n2 < e3 && (n2 = e3 / t2), t2 * n2 > i3 && (n2 = i3 / t2);
            }
            y2 = y2.scale(n2);
        }
        y2 = y2.translate(-o2, -a2).translate(-f2, -g2).multiply(b2), s2 && (y2 = y2.rotate(s2)), 
        l2 && (y2 = y2.scale(-1, 1)), c2 && (y2 = y2.scale(1, -1));
        for (const e3 of v) "e" !== e3 && "f" !== e3 && (y2[e3] > this.minScale + 1e-5 || y2[e3] < this.minScale - 1e-5) ? this.target[e3] = y2[e3] : this.target[e3] = t(y2[e3], M);
        (this.targetScale < this.scale || Math.abs(n2 - 1) > .1 || this.panMode === O || false === d2) && !h2 && this.clampTargetBounds(), 
        u2 === m.Init ? this.animate() : this.isResting || (this.state = m.Panning, this.requestTick());
    }
    stop(t2 = false) {
        if (this.state === m.Init || this.state === m.Destroy) return;
        const e2 = this.isTicking;
        this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = false, 
        this.isBouncingY = false;
        for (const e3 of v) this.velocity[e3] = 0, "current" === t2 ? this.current[e3] = this.target[e3] : "target" === t2 && (this.target[e3] = this.current[e3]);
        this.setTransform(), S(this.container, "is-scaling"), S(this.container, "is-animating"), 
        this.isTicking = false, this.state = m.Ready, e2 && (this.emit("endAnimation"), 
        this.updateControls());
    }
    requestTick() {
        this.isTicking || (this.emit("startAnimation"), this.updateControls(), P(this.container, "is-animating"), 
        this.isScaling && P(this.container, "is-scaling")), this.isTicking = true, this.rAF || (this.rAF = requestAnimationFrame((() => this.animate())));
    }
    panWithMouse(e2, i2 = this.option("mouseMoveFriction")) {
        if (this.pmme = e2, this.panMode !== O || !e2) return;
        if (t(this.targetScale) <= t(this.minScale)) return;
        this.emit("mouseMove", e2);
        const {container: n2, containerRect: s2, contentRect: o2} = this, a2 = s2.width, r2 = s2.height, l2 = n2.getBoundingClientRect(), c2 = (e2.clientX || 0) - l2.left, h2 = (e2.clientY || 0) - l2.top;
        let {contentWidth: d2, contentHeight: u2} = this.calculateContentDim(this.target);
        const p2 = this.option("mouseMoveFactor");
        p2 > 1 && (d2 !== a2 && (d2 *= p2), u2 !== r2 && (u2 *= p2));
        let f2 = .5 * (d2 - a2) - c2 / a2 * 100 / 100 * (d2 - a2);
        f2 += .5 * (o2.right - o2.left);
        let g2 = .5 * (u2 - r2) - h2 / r2 * 100 / 100 * (u2 - r2);
        g2 += .5 * (o2.bottom - o2.top), this.applyChange({
            panX: f2 - this.target.e,
            panY: g2 - this.target.f,
            friction: i2
        });
    }
    zoomWithWheel(e2) {
        if (this.state === m.Destroy || this.state === m.Init) return;
        const i2 = Date.now();
        if (i2 - this.pwt < 45) return void e2.preventDefault();
        this.pwt = i2;
        var n2 = [ -e2.deltaX || 0, -e2.deltaY || 0, -e2.detail || 0 ].reduce((function(t2, e3) {
            return Math.abs(e3) > Math.abs(t2) ? e3 : t2;
        }));
        const s2 = Math.max(-1, Math.min(1, n2)), {targetScale: o2, maxScale: a2, minScale: r2} = this;
        let l2 = o2 * (100 + 45 * s2) / 100;
        t(l2) < t(r2) && t(o2) <= t(r2) ? (this.cwd += Math.abs(s2), l2 = r2) : t(l2) > t(a2) && t(o2) >= t(a2) ? (this.cwd += Math.abs(s2), 
        l2 = a2) : (this.cwd = 0, l2 = Math.max(Math.min(l2, a2), r2)), this.cwd > this.option("wheelLimit") || (e2.preventDefault(), 
        t(l2) !== t(o2) && this.zoomTo(l2, {
            event: e2
        }));
    }
    canZoomIn() {
        return this.option("zoom") && (t(this.contentRect.width, 1) < t(this.contentRect.fitWidth, 1) || t(this.targetScale) < t(this.maxScale));
    }
    canZoomOut() {
        return this.option("zoom") && t(this.targetScale) > t(this.minScale);
    }
    zoomIn(t2 = 1.25, e2) {
        this.zoomTo(this.targetScale * t2, e2);
    }
    zoomOut(t2 = .8, e2) {
        this.zoomTo(this.targetScale * t2, e2);
    }
    zoomToFit(t2) {
        this.zoomTo("fit", t2);
    }
    zoomToCover(t2) {
        this.zoomTo("cover", t2);
    }
    zoomToFull(t2) {
        this.zoomTo("full", t2);
    }
    zoomToMax(t2) {
        this.zoomTo("max", t2);
    }
    toggleZoom(t2) {
        this.zoomTo(this.getNextScale("toggleZoom"), t2);
    }
    toggleMax(t2) {
        this.zoomTo(this.getNextScale("toggleMax"), t2);
    }
    toggleCover(t2) {
        this.zoomTo(this.getNextScale("toggleCover"), t2);
    }
    iterateZoom(t2) {
        this.zoomTo("next", t2);
    }
    zoomTo(t2 = 1, {friction: e2 = z, originX: i2 = z, originY: n2 = z, event: s2} = {}) {
        if (this.isContentLoading || this.state === m.Destroy) return;
        const {targetScale: o2, fullScale: a2, maxScale: r2, coverScale: l2} = this;
        if (this.stop(), this.panMode === O && (s2 = this.pmme || s2), s2 || i2 === z || n2 === z) {
            const t3 = this.content.getBoundingClientRect(), e3 = this.container.getBoundingClientRect(), o3 = s2 ? s2.clientX : e3.left + .5 * e3.width, a3 = s2 ? s2.clientY : e3.top + .5 * e3.height;
            i2 = o3 - t3.left - .5 * t3.width, n2 = a3 - t3.top - .5 * t3.height;
        }
        let c2 = 1;
        "number" == typeof t2 ? c2 = t2 : "full" === t2 ? c2 = a2 : "cover" === t2 ? c2 = l2 : "max" === t2 ? c2 = r2 : "fit" === t2 ? c2 = 1 : "next" === t2 && (c2 = this.getNextScale("iterateZoom")), 
        c2 = c2 / o2 || 1, e2 = e2 === z ? c2 > 1 ? .15 : .25 : e2, this.applyChange({
            scale: c2,
            originX: i2,
            originY: n2,
            friction: e2
        }), s2 && this.panMode === O && this.panWithMouse(s2, e2);
    }
    rotateCCW() {
        this.applyChange({
            angle: -90
        });
    }
    rotateCW() {
        this.applyChange({
            angle: 90
        });
    }
    flipX() {
        this.applyChange({
            flipX: true
        });
    }
    flipY() {
        this.applyChange({
            flipY: true
        });
    }
    fitX() {
        this.stop("target");
        const {containerRect: t2, contentRect: e2, target: i2} = this;
        this.applyChange({
            panX: .5 * t2.width - (e2.left + .5 * e2.fitWidth) - i2.e,
            panY: .5 * t2.height - (e2.top + .5 * e2.fitHeight) - i2.f,
            scale: t2.width / e2.fitWidth / this.targetScale,
            originX: 0,
            originY: 0,
            ignoreBounds: true
        });
    }
    fitY() {
        this.stop("target");
        const {containerRect: t2, contentRect: e2, target: i2} = this;
        this.applyChange({
            panX: .5 * t2.width - (e2.left + .5 * e2.fitWidth) - i2.e,
            panY: .5 * t2.innerHeight - (e2.top + .5 * e2.fitHeight) - i2.f,
            scale: t2.height / e2.fitHeight / this.targetScale,
            originX: 0,
            originY: 0,
            ignoreBounds: true
        });
    }
    toggleFS() {
        const {container: t2} = this, e2 = this.cn("inFullscreen"), i2 = this.cn("htmlHasFullscreen");
        t2.classList.toggle(e2);
        const n2 = t2.classList.contains(e2);
        n2 ? (document.documentElement.classList.add(i2), document.addEventListener("keydown", this.onKeydown, true)) : (document.documentElement.classList.remove(i2), 
        document.removeEventListener("keydown", this.onKeydown, true)), this.updateMetrics(), 
        this.emit(n2 ? "enterFS" : "exitFS");
    }
    getMatrix(t2 = this.current) {
        const {a: e2, b: i2, c: n2, d: s2, e: o2, f: a2} = t2;
        return new DOMMatrix([ e2, i2, n2, s2, o2, a2 ]);
    }
    reset(t2) {
        if (this.state !== m.Init && this.state !== m.Destroy) {
            this.stop("current");
            for (const t3 of v) this.target[t3] = C[t3];
            this.target.a = this.minScale, this.target.d = this.minScale, this.clampTargetBounds(), 
            this.isResting || (this.friction = void 0 === t2 ? this.option("friction") : t2, 
            this.state = m.Panning, this.requestTick());
        }
    }
    destroy() {
        this.stop(), this.state = m.Destroy, this.detachEvents(), this.detachObserver();
        const {container: t2, content: e2} = this, i2 = this.option("classes") || {};
        for (const e3 of Object.values(i2)) t2.classList.remove(e3 + "");
        e2 && (e2.removeEventListener("load", this.onLoad), e2.removeEventListener("error", this.onError)), 
        this.detachPlugins();
    }
}

Object.defineProperty(I, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: y
}), Object.defineProperty(I, "Plugins", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {}
});

const D = function(t2, e2) {
    let i2 = true;
    return (...n2) => {
        i2 && (i2 = false, t2(...n2), setTimeout((() => {
            i2 = true;
        }), e2));
    };
}, F = (t2, e2) => {
    let i2 = [];
    return t2.childNodes.forEach((t3 => {
        t3.nodeType !== Node.ELEMENT_NODE || e2 && !t3.matches(e2) || i2.push(t3);
    })), i2;
}, j = {
    viewport: null,
    track: null,
    enabled: true,
    slides: [],
    axis: "x",
    transition: "fade",
    preload: 1,
    slidesPerPage: "auto",
    initialPage: 0,
    friction: .12,
    Panzoom: {
        decelFriction: .12
    },
    center: true,
    infinite: true,
    fill: true,
    dragFree: false,
    adaptiveHeight: false,
    direction: "ltr",
    classes: {
        container: "f-carousel",
        viewport: "f-carousel__viewport",
        track: "f-carousel__track",
        slide: "f-carousel__slide",
        isLTR: "is-ltr",
        isRTL: "is-rtl",
        isHorizontal: "is-horizontal",
        isVertical: "is-vertical",
        inTransition: "in-transition",
        isSelected: "is-selected"
    },
    l10n: {
        NEXT: "Next slide",
        PREV: "Previous slide",
        GOTO: "Go to slide #%d"
    }
};

var B;

!function(t2) {
    t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Destroy = 2] = "Destroy";
}(B || (B = {}));

const H = t2 => {
    if ("string" == typeof t2 || t2 instanceof HTMLElement) t2 = {
        html: t2
    }; else {
        const e2 = t2.thumb;
        void 0 !== e2 && ("string" == typeof e2 && (t2.thumbSrc = e2), e2 instanceof HTMLImageElement && (t2.thumbEl = e2, 
        t2.thumbElSrc = e2.src, t2.thumbSrc = e2.src), delete t2.thumb);
    }
    return Object.assign({
        html: "",
        el: null,
        isDom: false,
        class: "",
        customClass: "",
        index: -1,
        dim: 0,
        gap: 0,
        pos: 0,
        transition: false
    }, t2);
}, N = (t2 = {}) => Object.assign({
    index: -1,
    slides: [],
    dim: 0,
    pos: -1
}, t2);

class _ extends f {
    constructor(t2, e2) {
        super(e2), Object.defineProperty(this, "instance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: t2
        });
    }
    attach() {}
    detach() {}
}

const $ = {
    classes: {
        list: "f-carousel__dots",
        isDynamic: "is-dynamic",
        hasDots: "has-dots",
        dot: "f-carousel__dot",
        isBeforePrev: "is-before-prev",
        isPrev: "is-prev",
        isCurrent: "is-current",
        isNext: "is-next",
        isAfterNext: "is-after-next"
    },
    dotTpl: '<button type="button" data-carousel-page="%i" aria-label="{{GOTO}}"><span class="f-carousel__dot" aria-hidden="true"></span></button>',
    dynamicFrom: 11,
    maxCount: 1 / 0,
    minCount: 2
};

class W extends _ {
    constructor() {
        super(...arguments), Object.defineProperty(this, "isDynamic", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "list", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
    }
    onRefresh() {
        this.refresh();
    }
    build() {
        let t2 = this.list;
        if (!t2) {
            t2 = document.createElement("ul"), P(t2, this.cn("list")), t2.setAttribute("role", "tablist");
            const e2 = this.instance.container;
            e2.appendChild(t2), P(e2, this.cn("hasDots")), this.list = t2;
        }
        return t2;
    }
    refresh() {
        var t2;
        const e2 = this.instance.pages.length, i2 = Math.min(2, this.option("minCount")), n2 = Math.max(2e3, this.option("maxCount")), s2 = this.option("dynamicFrom");
        if (e2 < i2 || e2 > n2) return void this.cleanup();
        const a2 = "number" == typeof s2 && e2 > 5 && e2 >= s2, r2 = !this.list || this.isDynamic !== a2 || this.list.children.length !== e2;
        r2 && this.cleanup();
        const l2 = this.build();
        if (o(l2, this.cn("isDynamic"), !!a2), r2) for (let t3 = 0; t3 < e2; t3++) l2.append(this.createItem(t3));
        let c2, h2 = 0;
        for (const e3 of [ ...l2.children ]) {
            const i3 = h2 === this.instance.page;
            i3 && (c2 = e3), o(e3, this.cn("isCurrent"), i3), null === (t2 = e3.children[0]) || void 0 === t2 || t2.setAttribute("aria-selected", i3 ? "true" : "false");
            for (const t3 of [ "isBeforePrev", "isPrev", "isNext", "isAfterNext" ]) S(e3, this.cn(t3));
            h2++;
        }
        if (c2 = c2 || l2.firstChild, a2 && c2) {
            const t3 = c2.previousElementSibling, e3 = t3 && t3.previousElementSibling;
            P(t3, this.cn("isPrev")), P(e3, this.cn("isBeforePrev"));
            const i3 = c2.nextElementSibling, n3 = i3 && i3.nextElementSibling;
            P(i3, this.cn("isNext")), P(n3, this.cn("isAfterNext"));
        }
        this.isDynamic = a2;
    }
    createItem(t2 = 0) {
        var e2;
        const i2 = document.createElement("li");
        i2.setAttribute("role", "presentation");
        const s2 = n(this.instance.localize(this.option("dotTpl"), [ [ "%d", t2 + 1 ] ]).replace(/\%i/g, t2 + ""));
        return i2.appendChild(s2), null === (e2 = i2.children[0]) || void 0 === e2 || e2.setAttribute("role", "tab"), 
        i2;
    }
    cleanup() {
        this.list && (this.list.remove(), this.list = null), this.isDynamic = false, S(this.instance.container, this.cn("hasDots"));
    }
    attach() {
        this.instance.on([ "refresh", "change" ], this.onRefresh);
    }
    detach() {
        this.instance.off([ "refresh", "change" ], this.onRefresh), this.cleanup();
    }
}

Object.defineProperty(W, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: $
});

const X = "disabled", q = "next", Y = "prev";

class V extends _ {
    constructor() {
        super(...arguments), Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "prev", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "next", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "isDom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    onRefresh() {
        const t2 = this.instance, e2 = t2.pages.length, i2 = t2.page;
        if (e2 < 2) return void this.cleanup();
        this.build();
        let n2 = this.prev, s2 = this.next;
        n2 && s2 && (n2.removeAttribute(X), s2.removeAttribute(X), t2.isInfinite || (i2 <= 0 && n2.setAttribute(X, ""), 
        i2 >= e2 - 1 && s2.setAttribute(X, "")));
    }
    addBtn(t2) {
        var e2;
        const i2 = this.instance, n2 = document.createElement("button");
        n2.setAttribute("tabindex", "0"), n2.setAttribute("title", i2.localize(`{{${t2.toUpperCase()}}}`)), 
        P(n2, this.cn("button") + " " + this.cn(t2 === q ? "isNext" : "isPrev"));
        const s2 = i2.isRTL ? t2 === q ? Y : q : t2;
        var o2;
        return n2.innerHTML = i2.localize(this.option(`${s2}Tpl`)), n2.dataset[`carousel${o2 = t2, 
        o2 ? o2.match("^[a-z]") ? o2.charAt(0).toUpperCase() + o2.substring(1) : o2 : ""}`] = "true", 
        null === (e2 = this.container) || void 0 === e2 || e2.appendChild(n2), n2;
    }
    build() {
        const t2 = this.instance.container, e2 = this.cn("container");
        let {container: i2, prev: n2, next: s2} = this;
        i2 || (i2 = t2.querySelector("." + e2), this.isDom = !!i2), i2 || (i2 = document.createElement("div"), 
        P(i2, e2), t2.appendChild(i2)), this.container = i2, s2 || (s2 = i2.querySelector("[data-carousel-next]")), 
        s2 || (s2 = this.addBtn(q)), this.next = s2, n2 || (n2 = i2.querySelector("[data-carousel-prev]")), 
        n2 || (n2 = this.addBtn(Y)), this.prev = n2;
    }
    cleanup() {
        this.isDom || (this.prev && this.prev.remove(), this.next && this.next.remove(), 
        this.container && this.container.remove()), this.prev = null, this.next = null, 
        this.container = null, this.isDom = false;
    }
    attach() {
        this.instance.on([ "refresh", "change" ], this.onRefresh);
    }
    detach() {
        this.instance.off([ "refresh", "change" ], this.onRefresh), this.cleanup();
    }
}

Object.defineProperty(V, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        classes: {
            container: "f-carousel__nav",
            button: "f-button",
            isNext: "is-next",
            isPrev: "is-prev"
        },
        nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>',
        prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>'
    }
});

class Z extends _ {
    constructor() {
        super(...arguments), Object.defineProperty(this, "selectedIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "target", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "nav", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
    }
    addAsTargetFor(t2) {
        this.target = this.instance, this.nav = t2, this.attachEvents();
    }
    addAsNavFor(t2) {
        this.nav = this.instance, this.target = t2, this.attachEvents();
    }
    attachEvents() {
        const {nav: t2, target: e2} = this;
        t2 && e2 && (t2.options.initialSlide = e2.options.initialPage, t2.state === B.Ready ? this.onNavReady(t2) : t2.on("ready", this.onNavReady), 
        e2.state === B.Ready ? this.onTargetReady(e2) : e2.on("ready", this.onTargetReady));
    }
    onNavReady(t2) {
        t2.on("createSlide", this.onNavCreateSlide), t2.on("Panzoom.click", this.onNavClick), 
        t2.on("Panzoom.touchEnd", this.onNavTouch), this.onTargetChange();
    }
    onTargetReady(t2) {
        t2.on("change", this.onTargetChange), t2.on("Panzoom.refresh", this.onTargetChange), 
        this.onTargetChange();
    }
    onNavClick(t2, e2, i2) {
        this.onNavTouch(t2, t2.panzoom, i2);
    }
    onNavTouch(t2, e2, i2) {
        var n2, s2;
        if (Math.abs(e2.dragOffset.x) > 3 || Math.abs(e2.dragOffset.y) > 3) return;
        const o2 = i2.target, {nav: a2, target: r2} = this;
        if (!a2 || !r2 || !o2) return;
        const l2 = o2.closest("[data-index]");
        if (i2.stopPropagation(), i2.preventDefault(), !l2) return;
        const c2 = parseInt(l2.dataset.index || "", 10) || 0, h2 = r2.getPageForSlide(c2), d2 = a2.getPageForSlide(c2);
        a2.slideTo(d2), r2.slideTo(h2, {
            friction: (null === (s2 = null === (n2 = this.nav) || void 0 === n2 ? void 0 : n2.plugins) || void 0 === s2 ? void 0 : s2.Sync.option("friction")) || 0
        }), this.markSelectedSlide(c2);
    }
    onNavCreateSlide(t2, e2) {
        e2.index === this.selectedIndex && this.markSelectedSlide(e2.index);
    }
    onTargetChange() {
        var t2, e2;
        const {target: i2, nav: n2} = this;
        if (!i2 || !n2) return;
        if (n2.state !== B.Ready || i2.state !== B.Ready) return;
        const s2 = null === (e2 = null === (t2 = i2.pages[i2.page]) || void 0 === t2 ? void 0 : t2.slides[0]) || void 0 === e2 ? void 0 : e2.index, o2 = n2.getPageForSlide(s2);
        this.markSelectedSlide(s2), n2.slideTo(o2, null === n2.prevPage && null === i2.prevPage ? {
            friction: 0
        } : void 0);
    }
    markSelectedSlide(t2) {
        const e2 = this.nav;
        e2 && e2.state === B.Ready && (this.selectedIndex = t2, [ ...e2.slides ].map((e3 => {
            e3.el && e3.el.classList[e3.index === t2 ? "add" : "remove"]("is-nav-selected");
        })));
    }
    attach() {
        const t2 = this;
        let e2 = t2.options.target, i2 = t2.options.nav;
        e2 ? t2.addAsNavFor(e2) : i2 && t2.addAsTargetFor(i2);
    }
    detach() {
        const t2 = this, e2 = t2.nav, i2 = t2.target;
        e2 && (e2.off("ready", t2.onNavReady), e2.off("createSlide", t2.onNavCreateSlide), 
        e2.off("Panzoom.click", t2.onNavClick), e2.off("Panzoom.touchEnd", t2.onNavTouch)), 
        t2.nav = null, i2 && (i2.off("ready", t2.onTargetReady), i2.off("refresh", t2.onTargetChange), 
        i2.off("change", t2.onTargetChange)), t2.target = null;
    }
}

Object.defineProperty(Z, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        friction: .35
    }
});

const U = {
    Navigation: V,
    Dots: W,
    Sync: Z
}, G = "animationend", K = "isSelected", J = "slide";

class Q extends g {
    get axis() {
        return this.isHorizontal ? "e" : "f";
    }
    get isEnabled() {
        return this.state === B.Ready;
    }
    get isInfinite() {
        let t2 = false;
        const {contentDim: e2, viewportDim: i2, pages: n2, slides: s2} = this, o2 = s2[0];
        return n2.length >= 2 && o2 && e2 + o2.dim >= i2 && (t2 = this.option("infinite")), 
        t2;
    }
    get isRTL() {
        return "rtl" === this.option("direction");
    }
    get isHorizontal() {
        return "x" === this.option("axis");
    }
    constructor(t2, e2 = {}, i2 = {}) {
        if (super(), Object.defineProperty(this, "bp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        }), Object.defineProperty(this, "lp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "userOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        }), Object.defineProperty(this, "userPlugins", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        }), Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: B.Init
        }), Object.defineProperty(this, "page", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "prevPage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), Object.defineProperty(this, "viewport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "track", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "slides", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        }), Object.defineProperty(this, "pages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        }), Object.defineProperty(this, "panzoom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "inTransition", {
            enumerable: true,
            configurable: true,
            writable: true,
            value:  new Set
        }), Object.defineProperty(this, "contentDim", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "viewportDim", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), "string" == typeof t2 && (t2 = document.querySelector(t2)), !t2 || !E(t2)) throw new Error("No Element found");
        this.container = t2, this.slideNext = D(this.slideNext.bind(this), 150), this.slidePrev = D(this.slidePrev.bind(this), 150), 
        this.userOptions = e2, this.userPlugins = i2, queueMicrotask((() => {
            this.processOptions();
        }));
    }
    processOptions() {
        var t2, e2;
        const i2 = u({}, Q.defaults, this.userOptions);
        let n2 = "";
        const s2 = i2.breakpoints;
        if (s2 && d(s2)) for (const [t3, e3] of Object.entries(s2)) window.matchMedia(t3).matches && d(e3) && (n2 += t3, 
        u(i2, e3));
        n2 === this.bp && this.state !== B.Init || (this.bp = n2, this.state === B.Ready && (i2.initialSlide = (null === (e2 = null === (t2 = this.pages[this.page]) || void 0 === t2 ? void 0 : t2.slides[0]) || void 0 === e2 ? void 0 : e2.index) || 0), 
        this.state !== B.Init && this.destroy(), super.setOptions(i2), false === this.option("enabled") ? this.attachEvents() : setTimeout((() => {
            this.init();
        }), 0));
    }
    init() {
        this.state = B.Init, this.emit("init"), this.attachPlugins(Object.assign(Object.assign({}, Q.Plugins), this.userPlugins)), 
        this.emit("attachPlugins"), this.initLayout(), this.initSlides(), this.updateMetrics(), 
        this.setInitialPosition(), this.initPanzoom(), this.attachEvents(), this.state = B.Ready, 
        this.emit("ready");
    }
    initLayout() {
        const {container: t2} = this, e2 = this.option("classes");
        P(t2, this.cn("container")), o(t2, e2.isLTR, !this.isRTL), o(t2, e2.isRTL, this.isRTL), 
        o(t2, e2.isVertical, !this.isHorizontal), o(t2, e2.isHorizontal, this.isHorizontal);
        let i2 = this.option("viewport") || t2.querySelector(`.${e2.viewport}`);
        i2 || (i2 = document.createElement("div"), P(i2, e2.viewport), i2.append(...F(t2, `.${e2.slide}`)), 
        t2.prepend(i2)), i2.addEventListener("scroll", this.onScroll);
        let n2 = this.option("track") || t2.querySelector(`.${e2.track}`);
        n2 || (n2 = document.createElement("div"), P(n2, e2.track), n2.append(...Array.from(i2.childNodes))), 
        n2.setAttribute("aria-live", "polite"), i2.contains(n2) || i2.prepend(n2), this.viewport = i2, 
        this.track = n2, this.emit("initLayout");
    }
    initSlides() {
        const {track: t2} = this;
        if (!t2) return;
        const e2 = [ ...this.slides ], i2 = [];
        [ ...F(t2, `.${this.cn(J)}`) ].forEach((t3 => {
            if (E(t3)) {
                const e3 = H({
                    el: t3,
                    isDom: true,
                    index: this.slides.length
                });
                i2.push(e3);
            }
        }));
        for (let t3 of [ ...this.option("slides", []) || [], ...e2 ]) i2.push(H(t3));
        this.slides = i2;
        for (let t3 = 0; t3 < this.slides.length; t3++) this.slides[t3].index = t3;
        for (const t3 of i2) this.emit("beforeInitSlide", t3, t3.index), this.emit("initSlide", t3, t3.index);
        this.emit("initSlides");
    }
    setInitialPage() {
        const t2 = this.option("initialSlide");
        this.page = "number" == typeof t2 ? this.getPageForSlide(t2) : parseInt(this.option("initialPage", 0) + "", 10) || 0;
    }
    setInitialPosition() {
        const {track: t2, pages: e2, isHorizontal: i2} = this;
        if (!t2 || !e2.length) return;
        let n2 = this.page;
        e2[n2] || (this.page = n2 = 0);
        const s2 = (e2[n2].pos || 0) * (this.isRTL && i2 ? 1 : -1), o2 = i2 ? `${s2}px` : "0", a2 = i2 ? "0" : `${s2}px`;
        t2.style.transform = `translate3d(${o2}, ${a2}, 0) scale(1)`, this.option("adaptiveHeight") && this.setViewportHeight();
    }
    initPanzoom() {
        this.panzoom && (this.panzoom.destroy(), this.panzoom = null);
        const t2 = this.option("Panzoom") || {};
        this.panzoom = new I(this.viewport, u({}, {
            content: this.track,
            zoom: false,
            panOnlyZoomed: false,
            lockAxis: this.isHorizontal ? "x" : "y",
            infinite: this.isInfinite,
            click: false,
            dblClick: false,
            touch: t3 => !(this.pages.length < 2 && !t3.options.infinite),
            bounds: () => this.getBounds(),
            maxVelocity: t3 => Math.abs(t3.target[this.axis] - t3.current[this.axis]) < 2 * this.viewportDim ? 100 : 0
        }, t2)), this.panzoom.on("*", ((t3, e2, ...i2) => {
            this.emit(`Panzoom.${e2}`, t3, ...i2);
        })), this.panzoom.on("decel", this.onDecel), this.panzoom.on("refresh", this.onRefresh), 
        this.panzoom.on("beforeTransform", this.onBeforeTransform), this.panzoom.on("endAnimation", this.onEndAnimation);
    }
    attachEvents() {
        const t2 = this.container;
        t2 && (t2.addEventListener("click", this.onClick, {
            passive: false,
            capture: false
        }), t2.addEventListener("slideTo", this.onSlideTo)), window.addEventListener("resize", this.onResize);
    }
    createPages() {
        let t2 = [];
        const {contentDim: e2, viewportDim: i2} = this;
        let n2 = this.option("slidesPerPage");
        n2 = ("auto" === n2 || e2 <= i2) && false !== this.option("fill") ? 1 / 0 : parseFloat(n2 + "");
        let s2 = 0, o2 = 0, a2 = 0;
        for (const e3 of this.slides) (!t2.length || o2 + e3.dim - i2 > .05 || a2 >= n2) && (t2.push(N()), 
        s2 = t2.length - 1, o2 = 0, a2 = 0), t2[s2].slides.push(e3), o2 += e3.dim + e3.gap, 
        a2++;
        return t2;
    }
    processPages() {
        const e2 = this.pages, {contentDim: i2, viewportDim: n2, isInfinite: s2} = this, o2 = this.option("center"), a2 = this.option("fill"), r2 = a2 && o2 && i2 > n2 && !s2;
        if (e2.forEach(((t2, e3) => {
            var s3;
            t2.index = e3, t2.pos = (null === (s3 = t2.slides[0]) || void 0 === s3 ? void 0 : s3.pos) || 0, 
            t2.dim = 0;
            for (const [e4, i3] of t2.slides.entries()) t2.dim += i3.dim, e4 < t2.slides.length - 1 && (t2.dim += i3.gap);
            r2 && t2.pos + .5 * t2.dim < .5 * n2 ? t2.pos = 0 : r2 && t2.pos + .5 * t2.dim >= i2 - .5 * n2 ? t2.pos = i2 - n2 : o2 && (t2.pos += -.5 * (n2 - t2.dim));
        })), e2.forEach((e3 => {
            a2 && !s2 && i2 > n2 && (e3.pos = Math.max(e3.pos, 0), e3.pos = Math.min(e3.pos, i2 - n2)), 
            e3.pos = t(e3.pos, 1e3), e3.dim = t(e3.dim, 1e3), Math.abs(e3.pos) <= .1 && (e3.pos = 0);
        })), s2) return e2;
        const l2 = [];
        let c2;
        return e2.forEach((t2 => {
            const e3 = Object.assign({}, t2);
            c2 && e3.pos === c2.pos ? (c2.dim += e3.dim, c2.slides = [ ...c2.slides, ...e3.slides ]) : (e3.index = l2.length, 
            c2 = e3, l2.push(e3));
        })), l2;
    }
    getPageFromIndex(t2 = 0) {
        const e2 = this.pages.length;
        let i2;
        return t2 = parseInt((t2 || 0).toString()) || 0, i2 = this.isInfinite ? (t2 % e2 + e2) % e2 : Math.max(Math.min(t2, e2 - 1), 0), 
        i2;
    }
    getSlideMetrics(e2) {
        var i2, n2;
        const s2 = this.isHorizontal ? "width" : "height";
        let o2 = 0, a2 = 0, r2 = e2.el;
        const l2 = !(!r2 || r2.parentNode);
        if (r2 ? o2 = parseFloat(r2.dataset[s2] || "") || 0 : (r2 = document.createElement("div"), 
        r2.style.visibility = "hidden", (this.track || document.body).prepend(r2)), P(r2, this.cn(J) + " " + e2.class + " " + e2.customClass), 
        o2) r2.style[s2] = `${o2}px`, r2.style["width" === s2 ? "height" : "width"] = ""; else {
            l2 && (this.track || document.body).prepend(r2), o2 = r2.getBoundingClientRect()[s2] * Math.max(1, (null === (i2 = window.visualViewport) || void 0 === i2 ? void 0 : i2.scale) || 1);
            let t2 = r2[this.isHorizontal ? "offsetWidth" : "offsetHeight"];
            t2 - 1 > o2 && (o2 = t2);
        }
        const c2 = getComputedStyle(r2);
        return "content-box" === c2.boxSizing && (this.isHorizontal ? (o2 += parseFloat(c2.paddingLeft) || 0, 
        o2 += parseFloat(c2.paddingRight) || 0) : (o2 += parseFloat(c2.paddingTop) || 0, 
        o2 += parseFloat(c2.paddingBottom) || 0)), a2 = parseFloat(c2[this.isHorizontal ? "marginRight" : "marginBottom"]) || 0, 
        l2 ? null === (n2 = r2.parentElement) || void 0 === n2 || n2.removeChild(r2) : e2.el || r2.remove(), 
        {
            dim: t(o2, 1e3),
            gap: t(a2, 1e3)
        };
    }
    getBounds() {
        const {isInfinite: t2, isRTL: e2, isHorizontal: i2, pages: n2} = this;
        let s2 = {
            min: 0,
            max: 0
        };
        if (t2) s2 = {
            min: -1 / 0,
            max: 1 / 0
        }; else if (n2.length) {
            const t3 = n2[0].pos, o2 = n2[n2.length - 1].pos;
            s2 = e2 && i2 ? {
                min: t3,
                max: o2
            } : {
                min: -1 * o2,
                max: -1 * t3
            };
        }
        return {
            x: i2 ? s2 : {
                min: 0,
                max: 0
            },
            y: i2 ? {
                min: 0,
                max: 0
            } : s2
        };
    }
    repositionSlides() {
        let e2, {isHorizontal: i2, isRTL: n2, isInfinite: s2, viewport: o2, viewportDim: a2, contentDim: r2, page: l2, pages: c2, slides: h2, panzoom: d2} = this, u2 = 0, p2 = 0, f2 = 0, g2 = 0;
        d2 ? g2 = -1 * d2.current[this.axis] : c2[l2] && (g2 = c2[l2].pos || 0), e2 = i2 ? n2 ? "right" : "left" : "top", 
        n2 && i2 && (g2 *= -1);
        for (const i3 of h2) {
            const n3 = i3.el;
            n3 ? ("top" === e2 ? (n3.style.right = "", n3.style.left = "") : n3.style.top = "", 
            i3.index !== u2 ? n3.style[e2] = 0 === p2 ? "" : `${t(p2, 1e3)}px` : n3.style[e2] = "", 
            f2 += i3.dim + i3.gap, u2++) : p2 += i3.dim + i3.gap;
        }
        if (s2 && f2 && o2) {
            let n3 = getComputedStyle(o2), s3 = "padding", l3 = i2 ? "Right" : "Bottom", c3 = parseFloat(n3[s3 + (i2 ? "Left" : "Top")]);
            g2 -= c3, a2 += c3, a2 += parseFloat(n3[s3 + l3]);
            for (const i3 of h2) i3.el && (t(i3.pos) < t(a2) && t(i3.pos + i3.dim + i3.gap) < t(g2) && t(g2) > t(r2 - a2) && (i3.el.style[e2] = `${t(p2 + f2, 1e3)}px`), 
            t(i3.pos + i3.gap) >= t(r2 - a2) && t(i3.pos) > t(g2 + a2) && t(g2) < t(a2) && (i3.el.style[e2] = `-${t(f2, 1e3)}px`));
        }
        let m2, v2, b2 = [ ...this.inTransition ];
        if (b2.length > 1 && (m2 = c2[b2[0]], v2 = c2[b2[1]]), m2 && v2) {
            let i3 = 0;
            for (const n3 of h2) n3.el ? this.inTransition.has(n3.index) && m2.slides.indexOf(n3) < 0 && (n3.el.style[e2] = `${t(i3 + (m2.pos - v2.pos), 1e3)}px`) : i3 += n3.dim + n3.gap;
        }
    }
    createSlideEl(t2) {
        const {track: e2, slides: i2} = this;
        if (!e2 || !t2) return;
        if (t2.el && t2.el.parentNode) return;
        const n2 = t2.el || document.createElement("div");
        P(n2, this.cn(J)), P(n2, t2.class), P(n2, t2.customClass);
        const s2 = t2.html;
        s2 && (s2 instanceof HTMLElement ? n2.appendChild(s2) : n2.innerHTML = t2.html + "");
        const o2 = [];
        i2.forEach(((t3, e3) => {
            t3.el && o2.push(e3);
        }));
        const a2 = t2.index;
        let r2 = null;
        if (o2.length) r2 = i2[o2.reduce(((t3, e3) => Math.abs(e3 - a2) < Math.abs(t3 - a2) ? e3 : t3))];
        const l2 = r2 && r2.el && r2.el.parentNode ? r2.index < t2.index ? r2.el.nextSibling : r2.el : null;
        e2.insertBefore(n2, e2.contains(l2) ? l2 : null), t2.el = n2, this.emit("createSlide", t2);
    }
    removeSlideEl(t2, e2 = false) {
        const i2 = null == t2 ? void 0 : t2.el;
        if (!i2 || !i2.parentNode) return;
        const n2 = this.cn(K);
        if (i2.classList.contains(n2) && (S(i2, n2), this.emit("unselectSlide", t2)), t2.isDom && !e2) return i2.removeAttribute("aria-hidden"), 
        i2.removeAttribute("data-index"), void (i2.style.left = "");
        this.emit("removeSlide", t2);
        const s2 = new CustomEvent(G);
        i2.dispatchEvent(s2), t2.el && (t2.el.remove(), t2.el = null);
    }
    transitionTo(t2 = 0, e2 = this.option("transition")) {
        var i2, n2, s2, o2;
        if (!e2) return false;
        const a2 = this.page, {pages: r2, panzoom: l2} = this;
        t2 = parseInt((t2 || 0).toString()) || 0;
        const c2 = this.getPageFromIndex(t2);
        if (!l2 || !r2[c2] || r2.length < 2 || Math.abs(((null === (n2 = null === (i2 = r2[a2]) || void 0 === i2 ? void 0 : i2.slides[0]) || void 0 === n2 ? void 0 : n2.dim) || 0) - this.viewportDim) > 1) return false;
        let h2 = t2 > a2 ? 1 : -1;
        this.isInfinite && (0 === a2 && t2 === r2.length - 1 && (h2 = -1), a2 === r2.length - 1 && 0 === t2 && (h2 = 1));
        const d2 = r2[c2].pos * (this.isRTL ? 1 : -1);
        if (a2 === c2 && Math.abs(d2 - l2.target[this.axis]) < 1) return false;
        this.clearTransitions();
        const u2 = l2.isResting;
        P(this.container, this.cn("inTransition"));
        const p2 = (null === (s2 = r2[a2]) || void 0 === s2 ? void 0 : s2.slides[0]) || null, f2 = (null === (o2 = r2[c2]) || void 0 === o2 ? void 0 : o2.slides[0]) || null;
        this.inTransition.add(f2.index), this.createSlideEl(f2);
        let g2 = p2.el, m2 = f2.el;
        u2 || e2 === J || (e2 = "fadeFast", g2 = null);
        const v2 = this.isRTL ? "next" : "prev", b2 = this.isRTL ? "prev" : "next";
        return g2 && (this.inTransition.add(p2.index), p2.transition = e2, g2.addEventListener(G, this.onAnimationEnd), 
        g2.classList.add(`f-${e2}Out`, `to-${h2 > 0 ? b2 : v2}`)), m2 && (f2.transition = e2, 
        m2.addEventListener(G, this.onAnimationEnd), m2.classList.add(`f-${e2}In`, `from-${h2 > 0 ? v2 : b2}`)), 
        l2.current[this.axis] = d2, l2.target[this.axis] = d2, l2.requestTick(), this.onChange(c2), 
        true;
    }
    manageSlideVisiblity() {
        const t2 =  new Set, e2 =  new Set, i2 = this.getVisibleSlides(parseFloat(this.option("preload", 0) + "") || 0);
        for (const n2 of this.slides) i2.has(n2) ? t2.add(n2) : e2.add(n2);
        for (const e3 of this.inTransition) t2.add(this.slides[e3]);
        for (const e3 of t2) this.createSlideEl(e3), this.lazyLoadSlide(e3);
        for (const i3 of e2) t2.has(i3) || this.removeSlideEl(i3);
        this.markSelectedSlides(), this.repositionSlides();
    }
    markSelectedSlides() {
        if (!this.pages[this.page] || !this.pages[this.page].slides) return;
        const t2 = "aria-hidden";
        let e2 = this.cn(K);
        if (e2) for (const i2 of this.slides) {
            const n2 = i2.el;
            n2 && (n2.dataset.index = `${i2.index}`, n2.classList.contains("f-thumbs__slide") ? this.getVisibleSlides(0).has(i2) ? n2.removeAttribute(t2) : n2.setAttribute(t2, "true") : this.pages[this.page].slides.includes(i2) ? (n2.classList.contains(e2) || (P(n2, e2), 
            this.emit("selectSlide", i2)), n2.removeAttribute(t2)) : (n2.classList.contains(e2) && (S(n2, e2), 
            this.emit("unselectSlide", i2)), n2.setAttribute(t2, "true")));
        }
    }
    flipInfiniteTrack() {
        const {axis: t2, isHorizontal: e2, isInfinite: i2, isRTL: n2, viewportDim: s2, contentDim: o2} = this, a2 = this.panzoom;
        if (!a2 || !i2) return;
        let r2 = a2.current[t2], l2 = a2.target[t2] - r2, c2 = 0, h2 = .5 * s2;
        n2 && e2 ? (r2 < -h2 && (c2 = -1, r2 += o2), r2 > o2 - h2 && (c2 = 1, r2 -= o2)) : (r2 > h2 && (c2 = 1, 
        r2 -= o2), r2 < -o2 + h2 && (c2 = -1, r2 += o2)), c2 && (a2.current[t2] = r2, a2.target[t2] = r2 + l2);
    }
    lazyLoadImg(t2, e2) {
        const i2 = this, s2 = "f-fadeIn", o2 = "is-preloading";
        let a2 = false, r2 = null;
        const l2 = () => {
            a2 || (a2 = true, r2 && (r2.remove(), r2 = null), S(e2, o2), e2.complete && (P(e2, s2), 
            setTimeout((() => {
                S(e2, s2);
            }), 350)), this.option("adaptiveHeight") && t2.el && this.pages[this.page].slides.indexOf(t2) > -1 && (i2.updateMetrics(), 
            i2.setViewportHeight()), this.emit("load", t2));
        };
        P(e2, o2), e2.src = e2.dataset.lazySrcset || e2.dataset.lazySrc || "", delete e2.dataset.lazySrc, 
        delete e2.dataset.lazySrcset, e2.addEventListener("error", (() => {
            l2();
        })), e2.addEventListener("load", (() => {
            l2();
        })), setTimeout((() => {
            const i3 = e2.parentNode;
            i3 && t2.el && (e2.complete ? l2() : a2 || (r2 = n(x), i3.insertBefore(r2, e2)));
        }), 300);
    }
    lazyLoadSlide(t2) {
        const e2 = t2 && t2.el;
        if (!e2) return;
        const i2 =  new Set;
        let n2 = Array.from(e2.querySelectorAll("[data-lazy-src],[data-lazy-srcset]"));
        e2.dataset.lazySrc && n2.push(e2), n2.map((t3 => {
            t3 instanceof HTMLImageElement ? i2.add(t3) : t3 instanceof HTMLElement && t3.dataset.lazySrc && (t3.style.backgroundImage = `url('${t3.dataset.lazySrc}')`, 
            delete t3.dataset.lazySrc);
        }));
        for (const e3 of i2) this.lazyLoadImg(t2, e3);
    }
    onAnimationEnd(t2) {
        var e2;
        const i2 = t2.target, n2 = i2 ? parseInt(i2.dataset.index || "", 10) || 0 : -1, s2 = this.slides[n2], o2 = t2.animationName;
        if (!i2 || !s2 || !o2) return;
        const a2 = !!this.inTransition.has(n2) && s2.transition;
        a2 && o2.substring(0, a2.length + 2) === `f-${a2}` && this.inTransition.delete(n2), 
        this.inTransition.size || this.clearTransitions(), n2 === this.page && (null === (e2 = this.panzoom) || void 0 === e2 ? void 0 : e2.isResting) && this.emit("settle");
    }
    onDecel(t2, e2 = 0, i2 = 0, n2 = 0, s2 = 0) {
        if (this.option("dragFree")) return void this.setPageFromPosition();
        const {isRTL: o2, isHorizontal: a2, axis: r2, pages: l2} = this, c2 = l2.length, h2 = Math.abs(Math.atan2(i2, e2) / (Math.PI / 180));
        let d2 = 0;
        if (d2 = h2 > 45 && h2 < 135 ? a2 ? 0 : i2 : a2 ? e2 : 0, !c2) return;
        let u2 = this.page, p2 = o2 && a2 ? 1 : -1;
        const f2 = t2.current[r2] * p2;
        let {pageIndex: g2} = this.getPageFromPosition(f2);
        Math.abs(d2) > 5 ? (l2[u2].dim < document.documentElement["client" + (this.isHorizontal ? "Width" : "Height")] - 1 && (u2 = g2), 
        u2 = o2 && a2 ? d2 < 0 ? u2 - 1 : u2 + 1 : d2 < 0 ? u2 + 1 : u2 - 1) : u2 = 0 === n2 && 0 === s2 ? u2 : g2, 
        this.slideTo(u2, {
            transition: false,
            friction: t2.option("decelFriction")
        });
    }
    onClick(t2) {
        const e2 = t2.target, i2 = e2 && E(e2) ? e2.dataset : null;
        let n2, s2;
        i2 && (void 0 !== i2.carouselPage ? (s2 = "slideTo", n2 = i2.carouselPage) : void 0 !== i2.carouselNext ? s2 = "slideNext" : void 0 !== i2.carouselPrev && (s2 = "slidePrev")), 
        s2 ? (t2.preventDefault(), t2.stopPropagation(), e2 && !e2.hasAttribute("disabled") && this[s2](n2)) : this.emit("click", t2);
    }
    onSlideTo(t2) {
        const e2 = t2.detail || 0;
        this.slideTo(this.getPageForSlide(e2), {
            friction: 0
        });
    }
    onChange(t2, e2 = 0) {
        const i2 = this.page;
        this.prevPage = i2, this.page = t2, this.option("adaptiveHeight") && this.setViewportHeight(), 
        t2 !== i2 && (this.markSelectedSlides(), this.emit("change", t2, i2, e2));
    }
    onRefresh() {
        let t2 = this.contentDim, e2 = this.viewportDim;
        this.updateMetrics(), this.contentDim === t2 && this.viewportDim === e2 || this.slideTo(this.page, {
            friction: 0,
            transition: false
        });
    }
    onScroll() {
        var t2;
        null === (t2 = this.viewport) || void 0 === t2 || t2.scroll(0, 0);
    }
    onResize() {
        this.option("breakpoints") && this.processOptions();
    }
    onBeforeTransform(t2) {
        this.lp !== t2.current[this.axis] && (this.flipInfiniteTrack(), this.manageSlideVisiblity()), 
        this.lp = t2.current.e;
    }
    onEndAnimation() {
        this.inTransition.size || this.emit("settle");
    }
    reInit(t2 = null, e2 = null) {
        this.destroy(), this.state = B.Init, this.prevPage = null, this.userOptions = t2 || this.userOptions, 
        this.userPlugins = e2 || this.userPlugins, this.processOptions();
    }
    slideTo(t2 = 0, {friction: e2 = this.option("friction"), transition: i2 = this.option("transition")} = {}) {
        if (this.state === B.Destroy) return;
        t2 = parseInt((t2 || 0).toString()) || 0;
        const n2 = this.getPageFromIndex(t2), {axis: s2, isHorizontal: o2, isRTL: a2, pages: r2, panzoom: l2} = this, c2 = r2.length, h2 = a2 && o2 ? 1 : -1;
        if (!l2 || !c2) return;
        if (this.page !== n2) {
            const e3 = new Event("beforeChange", {
                bubbles: true,
                cancelable: true
            });
            if (this.emit("beforeChange", e3, t2), e3.defaultPrevented) return;
        }
        if (this.transitionTo(t2, i2)) return;
        let d2 = r2[n2].pos;
        if (this.isInfinite) {
            const e3 = this.contentDim, i3 = l2.target[s2] * h2;
            if (2 === c2) d2 += e3 * Math.floor(parseFloat(t2 + "") / 2); else d2 = [ d2, d2 - e3, d2 + e3 ].reduce((function(t3, e4) {
                return Math.abs(e4 - i3) < Math.abs(t3 - i3) ? e4 : t3;
            }));
        }
        d2 *= h2, Math.abs(l2.target[s2] - d2) < 1 || (l2.panTo({
            x: o2 ? d2 : 0,
            y: o2 ? 0 : d2,
            friction: e2
        }), this.onChange(n2));
    }
    slideToClosest(t2) {
        if (this.panzoom) {
            const {pageIndex: e2} = this.getPageFromPosition();
            this.slideTo(e2, t2);
        }
    }
    slideNext() {
        this.slideTo(this.page + 1);
    }
    slidePrev() {
        this.slideTo(this.page - 1);
    }
    clearTransitions() {
        this.inTransition.clear(), S(this.container, this.cn("inTransition"));
        const t2 = [ "to-prev", "to-next", "from-prev", "from-next" ];
        for (const e2 of this.slides) {
            const i2 = e2.el;
            if (i2) {
                i2.removeEventListener(G, this.onAnimationEnd), i2.classList.remove(...t2);
                const n2 = e2.transition;
                n2 && i2.classList.remove(`f-${n2}Out`, `f-${n2}In`);
            }
        }
        this.manageSlideVisiblity();
    }
    addSlide(t2, e2) {
        var i2, n2, s2, o2;
        const a2 = this.panzoom, r2 = (null === (i2 = this.pages[this.page]) || void 0 === i2 ? void 0 : i2.pos) || 0, l2 = (null === (n2 = this.pages[this.page]) || void 0 === n2 ? void 0 : n2.dim) || 0, c2 = this.contentDim < this.viewportDim;
        let h2 = Array.isArray(e2) ? e2 : [ e2 ];
        const d2 = [];
        for (const t3 of h2) d2.push(H(t3));
        this.slides.splice(t2, 0, ...d2);
        for (let t3 = 0; t3 < this.slides.length; t3++) this.slides[t3].index = t3;
        for (const t3 of d2) this.emit("beforeInitSlide", t3, t3.index);
        if (this.page >= t2 && (this.page += d2.length), this.updateMetrics(), a2) {
            const e3 = (null === (s2 = this.pages[this.page]) || void 0 === s2 ? void 0 : s2.pos) || 0, i3 = (null === (o2 = this.pages[this.page]) || void 0 === o2 ? void 0 : o2.dim) || 0, n3 = this.pages.length || 1, h3 = this.isRTL ? l2 - i3 : i3 - l2, d3 = this.isRTL ? r2 - e3 : e3 - r2;
            c2 && 1 === n3 ? (t2 <= this.page && (a2.current[this.axis] -= h3, a2.target[this.axis] -= h3), 
            a2.panTo({
                [this.isHorizontal ? "x" : "y"]: -1 * e3
            })) : d3 && t2 <= this.page && (a2.target[this.axis] -= d3, a2.current[this.axis] -= d3, 
            a2.requestTick());
        }
        for (const t3 of d2) this.emit("initSlide", t3, t3.index);
    }
    prependSlide(t2) {
        this.addSlide(0, t2);
    }
    appendSlide(t2) {
        this.addSlide(this.slides.length, t2);
    }
    removeSlide(t2) {
        const e2 = this.slides.length;
        t2 = (t2 % e2 + e2) % e2;
        const i2 = this.slides[t2];
        if (i2) {
            this.removeSlideEl(i2, true), this.slides.splice(t2, 1);
            for (let t3 = 0; t3 < this.slides.length; t3++) this.slides[t3].index = t3;
            this.updateMetrics(), this.slideTo(this.page, {
                friction: 0,
                transition: false
            }), this.emit("destroySlide", i2);
        }
    }
    updateMetrics() {
        const {panzoom: e2, viewport: i2, track: n2, slides: s2, isHorizontal: o2, isInfinite: a2} = this;
        if (!n2) return;
        const r2 = o2 ? "width" : "height", l2 = o2 ? "offsetWidth" : "offsetHeight";
        if (i2) {
            let e3 = Math.max(i2[l2], t(i2.getBoundingClientRect()[r2], 1e3)), n3 = getComputedStyle(i2), s3 = "padding", a3 = o2 ? "Right" : "Bottom";
            e3 -= parseFloat(n3[s3 + (o2 ? "Left" : "Top")]) + parseFloat(n3[s3 + a3]), this.viewportDim = e3;
        }
        let c2, h2 = 0;
        for (const [e3, i3] of s2.entries()) {
            let n3 = 0, o3 = 0;
            !i3.el && c2 ? (n3 = c2.dim, o3 = c2.gap) : (({dim: n3, gap: o3} = this.getSlideMetrics(i3)), 
            c2 = i3), n3 = t(n3, 1e3), o3 = t(o3, 1e3), i3.dim = n3, i3.gap = o3, i3.pos = h2, 
            h2 += n3, (a2 || e3 < s2.length - 1) && (h2 += o3);
        }
        h2 = t(h2, 1e3), this.contentDim = h2, e2 && (e2.contentRect[r2] = h2, e2.contentRect[o2 ? "fullWidth" : "fullHeight"] = h2), 
        this.pages = this.createPages(), this.pages = this.processPages(), this.state === B.Init && this.setInitialPage(), 
        this.page = Math.max(0, Math.min(this.page, this.pages.length - 1)), this.manageSlideVisiblity(), 
        this.emit("refresh");
    }
    getProgress(e2, i2 = false, n2 = false) {
        void 0 === e2 && (e2 = this.page);
        const s2 = this, o2 = s2.panzoom, a2 = s2.contentDim, r2 = s2.pages[e2] || 0;
        if (!r2 || !o2) return e2 > this.page ? -1 : 1;
        let l2 = -1 * o2.current.e, c2 = t((l2 - r2.pos) / (1 * r2.dim), 1e3), h2 = c2, d2 = c2;
        this.isInfinite && true !== n2 && (h2 = t((l2 - r2.pos + a2) / (1 * r2.dim), 1e3), 
        d2 = t((l2 - r2.pos - a2) / (1 * r2.dim), 1e3));
        let u2 = [ c2, h2, d2 ].reduce((function(t2, e3) {
            return Math.abs(e3) < Math.abs(t2) ? e3 : t2;
        }));
        return i2 ? u2 : u2 > 1 ? 1 : u2 < -1 ? -1 : u2;
    }
    setViewportHeight() {
        const {page: t2, pages: e2, viewport: i2, isHorizontal: n2} = this;
        if (!i2 || !e2[t2]) return;
        let s2 = 0;
        n2 && this.track && (this.track.style.height = "auto", e2[t2].slides.forEach((t3 => {
            t3.el && (s2 = Math.max(s2, t3.el.offsetHeight));
        }))), i2.style.height = s2 ? `${s2}px` : "";
    }
    getPageForSlide(t2) {
        for (const e2 of this.pages) for (const i2 of e2.slides) if (i2.index === t2) return e2.index;
        return -1;
    }
    getVisibleSlides(t2 = 0) {
        var e2;
        const i2 =  new Set;
        let {panzoom: n2, contentDim: s2, viewportDim: o2, pages: a2, page: r2} = this;
        if (o2) {
            s2 = s2 + (null === (e2 = this.slides[this.slides.length - 1]) || void 0 === e2 ? void 0 : e2.gap) || 0;
            let l2 = 0;
            l2 = n2 && n2.state !== m.Init && n2.state !== m.Destroy ? -1 * n2.current[this.axis] : a2[r2] && a2[r2].pos || 0, 
            this.isInfinite && (l2 -= Math.floor(l2 / s2) * s2), this.isRTL && this.isHorizontal && (l2 *= -1);
            const c2 = l2 - o2 * t2, h2 = l2 + o2 * (t2 + 1), d2 = this.isInfinite ? [ -1, 0, 1 ] : [ 0 ];
            for (const t3 of this.slides) for (const e3 of d2) {
                const n3 = t3.pos + e3 * s2, o3 = n3 + t3.dim + t3.gap;
                n3 < h2 && o3 > c2 && i2.add(t3);
            }
        }
        return i2;
    }
    getPageFromPosition(t2) {
        const {viewportDim: e2, contentDim: i2, slides: n2, pages: s2, panzoom: o2} = this, a2 = s2.length, r2 = n2.length, l2 = n2[0], c2 = n2[r2 - 1], h2 = this.option("center");
        let d2 = 0, u2 = 0, p2 = 0, f2 = void 0 === t2 ? -1 * ((null == o2 ? void 0 : o2.target[this.axis]) || 0) : t2;
        h2 && (f2 += .5 * e2), this.isInfinite ? (f2 < l2.pos - .5 * c2.gap && (f2 -= i2, 
        p2 = -1), f2 > c2.pos + c2.dim + .5 * c2.gap && (f2 -= i2, p2 = 1)) : f2 = Math.max(l2.pos || 0, Math.min(f2, c2.pos));
        let g2 = c2, m2 = n2.find((t3 => {
            const e3 = t3.pos - .5 * g2.gap, i3 = t3.pos + t3.dim + .5 * t3.gap;
            return g2 = t3, f2 >= e3 && f2 < i3;
        }));
        return m2 || (m2 = c2), u2 = this.getPageForSlide(m2.index), d2 = u2 + p2 * a2, 
        {
            page: d2,
            pageIndex: u2
        };
    }
    setPageFromPosition() {
        const {pageIndex: t2} = this.getPageFromPosition();
        this.onChange(t2);
    }
    destroy() {
        if ([ B.Destroy ].includes(this.state)) return;
        this.state = B.Destroy;
        const {container: t2, viewport: e2, track: i2, slides: n2, panzoom: s2} = this, o2 = this.option("classes");
        t2.removeEventListener("click", this.onClick, {
            passive: false,
            capture: false
        }), t2.removeEventListener("slideTo", this.onSlideTo), window.removeEventListener("resize", this.onResize), 
        s2 && (s2.destroy(), this.panzoom = null), n2 && n2.forEach((t3 => {
            this.removeSlideEl(t3);
        })), this.detachPlugins(), e2 && (e2.removeEventListener("scroll", this.onScroll), 
        e2.offsetParent && i2 && i2.offsetParent && e2.replaceWith(...i2.childNodes));
        for (const [e3, i3] of Object.entries(o2)) "container" !== e3 && i3 && t2.classList.remove(i3);
        this.track = null, this.viewport = null, this.page = 0, this.slides = [];
        const a2 = this.events.get("ready");
        this.events =  new Map, a2 && this.events.set("ready", a2);
    }
}

Object.defineProperty(Q, "Panzoom", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: I
}), Object.defineProperty(Q, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: j
}), Object.defineProperty(Q, "Plugins", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: U
});

const tt = function(t2) {
    if (!E(t2)) return 0;
    const e2 = window.scrollY, i2 = window.innerHeight, n2 = e2 + i2, s2 = t2.getBoundingClientRect(), o2 = s2.y + e2, a2 = s2.height, r2 = o2 + a2;
    if (e2 > r2 || n2 < o2) return 0;
    if (e2 < o2 && n2 > r2) return 100;
    if (o2 < e2 && r2 > n2) return 100;
    let l2 = a2;
    o2 < e2 && (l2 -= e2 - o2), r2 > n2 && (l2 -= r2 - n2);
    const c2 = l2 / i2 * 100;
    return Math.round(c2);
}, et = !("undefined" == typeof window || !window.document || !window.document.createElement);

let it;

const nt = [ "a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden]):not(.fancybox-focus-guard)", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])' ].join(","), st = t2 => {
    if (t2 && et) {
        void 0 === it && document.createElement("div").focus({
            get preventScroll() {
                return it = true, false;
            }
        });
        try {
            if (it) t2.focus({
                preventScroll: true
            }); else {
                const e2 = window.scrollY || document.body.scrollTop, i2 = window.scrollX || document.body.scrollLeft;
                t2.focus(), document.body.scrollTo({
                    top: e2,
                    left: i2,
                    behavior: "auto"
                });
            }
        } catch (t3) {}
    }
}, ot = () => {
    const t2 = document;
    let e2, i2 = "", n2 = "", s2 = "";
    return t2.fullscreenEnabled ? (i2 = "requestFullscreen", n2 = "exitFullscreen", 
    s2 = "fullscreenElement") : t2.webkitFullscreenEnabled && (i2 = "webkitRequestFullscreen", 
    n2 = "webkitExitFullscreen", s2 = "webkitFullscreenElement"), i2 && (e2 = {
        request: function(e3 = t2.documentElement) {
            return "webkitRequestFullscreen" === i2 ? e3[i2](Element.ALLOW_KEYBOARD_INPUT) : e3[i2]();
        },
        exit: function() {
            return t2[s2] && t2[n2]();
        },
        isFullscreen: function() {
            return t2[s2];
        }
    }), e2;
}, at = {
    animated: true,
    autoFocus: true,
    backdropClick: "close",
    Carousel: {
        classes: {
            container: "fancybox__carousel",
            viewport: "fancybox__viewport",
            track: "fancybox__track",
            slide: "fancybox__slide"
        }
    },
    closeButton: "auto",
    closeExisting: false,
    commonCaption: false,
    compact: () => window.matchMedia("(max-width: 578px), (max-height: 578px)").matches,
    contentClick: "toggleZoom",
    contentDblClick: false,
    defaultType: "image",
    defaultDisplay: "flex",
    dragToClose: true,
    Fullscreen: {
        autoStart: false
    },
    groupAll: false,
    groupAttr: "data-fancybox",
    hideClass: "f-fadeOut",
    hideScrollbar: true,
    idle: 3500,
    keyboard: {
        Escape: "close",
        Delete: "close",
        Backspace: "close",
        PageUp: "next",
        PageDown: "prev",
        ArrowUp: "prev",
        ArrowDown: "next",
        ArrowRight: "next",
        ArrowLeft: "prev"
    },
    l10n: Object.assign(Object.assign({}, b), {
        CLOSE: "Close",
        NEXT: "Next",
        PREV: "Previous",
        MODAL: "You can close this modal content with the ESC key",
        ERROR: "Something Went Wrong, Please Try Again Later",
        IMAGE_ERROR: "Image Not Found",
        ELEMENT_NOT_FOUND: "HTML Element Not Found",
        AJAX_NOT_FOUND: "Error Loading AJAX : Not Found",
        AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden",
        IFRAME_ERROR: "Error Loading Page",
        TOGGLE_ZOOM: "Toggle zoom level",
        TOGGLE_THUMBS: "Toggle thumbnails",
        TOGGLE_SLIDESHOW: "Toggle slideshow",
        TOGGLE_FULLSCREEN: "Toggle full-screen mode",
        DOWNLOAD: "Download"
    }),
    parentEl: null,
    placeFocusBack: true,
    showClass: "f-zoomInUp",
    startIndex: 0,
    tpl: {
        closeButton: '<button data-fancybox-close class="f-button is-close-btn" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg></button>',
        main: '<div class="fancybox__container" role="dialog" aria-modal="true" aria-label="{{MODAL}}" tabindex="-1">\n    <div class="fancybox__backdrop"></div>\n    <div class="fancybox__carousel"></div>\n    <div class="fancybox__footer"></div>\n  </div>'
    },
    trapFocus: true,
    wheel: "zoom"
};

var rt, lt;

!function(t2) {
    t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Closing = 2] = "Closing", 
    t2[t2.CustomClosing = 3] = "CustomClosing", t2[t2.Destroy = 4] = "Destroy";
}(rt || (rt = {})), function(t2) {
    t2[t2.Loading = 0] = "Loading", t2[t2.Opening = 1] = "Opening", t2[t2.Ready = 2] = "Ready", 
    t2[t2.Closing = 3] = "Closing";
}(lt || (lt = {}));

let ct = "", ht = false, dt = false, ut = null;

const pt = () => {
    let t2 = "", e2 = "";
    const i2 = Oe.getInstance();
    if (i2) {
        const n2 = i2.carousel, s2 = i2.getSlide();
        if (n2 && s2) {
            let o2 = s2.slug || void 0, a2 = s2.triggerEl || void 0;
            e2 = o2 || i2.option("slug") || "", !e2 && a2 && a2.dataset && (e2 = a2.dataset.fancybox || ""), 
            e2 && "true" !== e2 && (t2 = "#" + e2 + (!o2 && n2.slides.length > 1 ? "-" + (s2.index + 1) : ""));
        }
    }
    return {
        hash: t2,
        slug: e2,
        index: 1
    };
}, ft = () => {
    const t2 = new URL(document.URL).hash, e2 = t2.slice(1).split("-"), i2 = e2[e2.length - 1], n2 = i2 && /^\+?\d+$/.test(i2) && parseInt(e2.pop() || "1", 10) || 1;
    return {
        hash: t2,
        slug: e2.join("-"),
        index: n2
    };
}, gt = () => {
    const {slug: t2, index: e2} = ft();
    if (!t2) return;
    let i2 = document.querySelector(`[data-slug="${t2}"]`);
    if (i2 && i2.dispatchEvent(new CustomEvent("click", {
        bubbles: true,
        cancelable: true
    })), Oe.getInstance()) return;
    const n2 = document.querySelectorAll(`[data-fancybox="${t2}"]`);
    n2.length && (i2 = n2[e2 - 1], i2 && i2.dispatchEvent(new CustomEvent("click", {
        bubbles: true,
        cancelable: true
    })));
}, mt = () => {
    if (false === Oe.defaults.Hash) return;
    const t2 = Oe.getInstance();
    if (false === (null == t2 ? void 0 : t2.options.Hash)) return;
    const {slug: e2, index: i2} = ft(), {slug: n2} = pt();
    t2 && (e2 === n2 ? t2.jumpTo(i2 - 1) : (ht = true, t2.close())), gt();
}, vt = () => {
    ut && clearTimeout(ut), queueMicrotask((() => {
        mt();
    }));
}, bt = () => {
    window.addEventListener("hashchange", vt, false), setTimeout((() => {
        mt();
    }), 500);
};

et && (/complete|interactive|loaded/.test(document.readyState) ? bt() : document.addEventListener("DOMContentLoaded", bt));

const yt = "is-zooming-in";

class wt extends _ {
    onCreateSlide(t2, e2, i2) {
        const n2 = this.instance.optionFor(i2, "src") || "";
        i2.el && "image" === i2.type && "string" == typeof n2 && this.setImage(i2, n2);
    }
    onRemoveSlide(t2, e2, i2) {
        i2.panzoom && i2.panzoom.destroy(), i2.panzoom = void 0, i2.imageEl = void 0;
    }
    onChange(t2, e2, i2, n2) {
        S(this.instance.container, yt);
        for (const t3 of e2.slides) {
            const e3 = t3.panzoom;
            e3 && t3.index !== i2 && e3.reset(.35);
        }
    }
    onClose() {
        var t2;
        const e2 = this.instance, i2 = e2.container, n2 = e2.getSlide();
        if (!i2 || !i2.parentElement || !n2) return;
        const {el: s2, contentEl: o2, panzoom: a2, thumbElSrc: r2} = n2;
        if (!s2 || !r2 || !o2 || !a2 || a2.isContentLoading || a2.state === m.Init || a2.state === m.Destroy) return;
        a2.updateMetrics();
        let l2 = this.getZoomInfo(n2);
        if (!l2) return;
        this.instance.state = rt.CustomClosing, i2.classList.remove(yt), i2.classList.add("is-zooming-out"), 
        o2.style.backgroundImage = `url('${r2}')`;
        const c2 = i2.getBoundingClientRect();
        1 === ((null === (t2 = window.visualViewport) || void 0 === t2 ? void 0 : t2.scale) || 1) && Object.assign(i2.style, {
            position: "absolute",
            top: `${i2.offsetTop + window.scrollY}px`,
            left: `${i2.offsetLeft + window.scrollX}px`,
            bottom: "auto",
            right: "auto",
            width: `${c2.width}px`,
            height: `${c2.height}px`,
            overflow: "hidden"
        });
        const {x: h2, y: d2, scale: u2, opacity: p2} = l2;
        if (p2) {
            const t3 = ((t4, e3, i3, n3) => {
                const s3 = e3 - t4, o3 = n3 - i3;
                return e4 => i3 + ((e4 - t4) / s3 * o3 || 0);
            })(a2.scale, u2, 1, 0);
            a2.on("afterTransform", (() => {
                o2.style.opacity = t3(a2.scale) + "";
            }));
        }
        a2.on("endAnimation", (() => {
            e2.destroy();
        })), a2.target.a = u2, a2.target.b = 0, a2.target.c = 0, a2.target.d = u2, a2.panTo({
            x: h2,
            y: d2,
            scale: u2,
            friction: p2 ? .2 : .33,
            ignoreBounds: true
        }), a2.isResting && e2.destroy();
    }
    setImage(t2, e2) {
        const i2 = this.instance;
        t2.src = e2, this.process(t2, e2).then((e3 => {
            const {contentEl: n2, imageEl: s2, thumbElSrc: o2, el: a2} = t2;
            if (i2.isClosing() || !n2 || !s2) return;
            n2.offsetHeight;
            const r2 = !!i2.isOpeningSlide(t2) && this.getZoomInfo(t2);
            if (this.option("protected") && a2) {
                a2.addEventListener("contextmenu", (t4 => {
                    t4.preventDefault();
                }));
                const t3 = document.createElement("div");
                P(t3, "fancybox-protected"), n2.appendChild(t3);
            }
            if (o2 && r2) {
                const s3 = e3.contentRect, a3 = Math.max(s3.fullWidth, s3.fullHeight);
                let c2 = null;
                !r2.opacity && a3 > 1200 && (c2 = document.createElement("img"), P(c2, "fancybox-ghost"), 
                c2.src = o2, n2.appendChild(c2));
                const h2 = () => {
                    c2 && (P(c2, "f-fadeFastOut"), setTimeout((() => {
                        c2 && (c2.remove(), c2 = null);
                    }), 200));
                };
                (l2 = o2, new Promise(((t3, e4) => {
                    const i3 = new Image;
                    i3.onload = t3, i3.onerror = e4, i3.src = l2;
                }))).then((() => {
                    i2.hideLoading(t2), t2.state = lt.Opening, this.instance.emit("reveal", t2), this.zoomIn(t2).then((() => {
                        h2(), this.instance.done(t2);
                    }), (() => {})), c2 && setTimeout((() => {
                        h2();
                    }), a3 > 2500 ? 800 : 200);
                }), (() => {
                    i2.hideLoading(t2), i2.revealContent(t2);
                }));
            } else {
                const n3 = this.optionFor(t2, "initialSize"), s3 = this.optionFor(t2, "zoom"), o3 = {
                    event: i2.prevMouseMoveEvent || i2.options.event,
                    friction: s3 ? .12 : 0
                };
                let a3 = i2.optionFor(t2, "showClass") || void 0, r3 = true;
                i2.isOpeningSlide(t2) && ("full" === n3 ? e3.zoomToFull(o3) : "cover" === n3 ? e3.zoomToCover(o3) : "max" === n3 ? e3.zoomToMax(o3) : r3 = false, 
                e3.stop("current")), r3 && a3 && (a3 = e3.isDragging ? "f-fadeIn" : ""), i2.hideLoading(t2), 
                i2.revealContent(t2, a3);
            }
            var l2;
        }), (() => {
            i2.setError(t2, "{{IMAGE_ERROR}}");
        }));
    }
    process(t2, e2) {
        return new Promise(((i2, s2) => {
            var o2;
            const a2 = this.instance, r2 = t2.el;
            a2.clearContent(t2), a2.showLoading(t2);
            let l2 = this.optionFor(t2, "content");
            if ("string" == typeof l2 && (l2 = n(l2)), !l2 || !E(l2)) {
                if (l2 = document.createElement("img"), l2 instanceof HTMLImageElement) {
                    let i3 = "", n2 = t2.caption;
                    i3 = "string" == typeof n2 && n2 ? n2.replace(/<[^>]+>/gi, "").substring(0, 1e3) : `Image ${t2.index + 1} of ${(null === (o2 = a2.carousel) || void 0 === o2 ? void 0 : o2.pages.length) || 1}`, 
                    l2.src = e2 || "", l2.alt = i3, l2.draggable = false, t2.srcset && l2.setAttribute("srcset", t2.srcset), 
                    this.instance.isOpeningSlide(t2) && (l2.fetchPriority = "high");
                }
                t2.sizes && l2.setAttribute("sizes", t2.sizes);
            }
            P(l2, "fancybox-image"), t2.imageEl = l2, a2.setContent(t2, l2, false);
            t2.panzoom = new I(r2, u({
                transformParent: true
            }, this.option("Panzoom") || {}, {
                content: l2,
                width: (e3, i3) => a2.optionFor(t2, "width", "auto", i3) || "auto",
                height: (e3, i3) => a2.optionFor(t2, "height", "auto", i3) || "auto",
                wheel: () => {
                    const t3 = a2.option("wheel");
                    return ("zoom" === t3 || "pan" == t3) && t3;
                },
                click: (e3, i3) => {
                    var n2, s3;
                    if (a2.isCompact || a2.isClosing()) return false;
                    if (t2.index !== (null === (n2 = a2.getSlide()) || void 0 === n2 ? void 0 : n2.index)) return false;
                    if (i3) {
                        const t3 = i3.composedPath()[0];
                        if ([ "A", "BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO" ].includes(t3.nodeName)) return false;
                    }
                    let o3 = !i3 || i3.target && (null === (s3 = t2.contentEl) || void 0 === s3 ? void 0 : s3.contains(i3.target));
                    return a2.option(o3 ? "contentClick" : "backdropClick") || false;
                },
                dblClick: () => a2.isCompact ? "toggleZoom" : a2.option("contentDblClick") || false,
                spinner: false,
                panOnlyZoomed: true,
                wheelLimit: 1 / 0,
                on: {
                    ready: t3 => {
                        i2(t3);
                    },
                    error: () => {
                        s2();
                    },
                    destroy: () => {
                        s2();
                    }
                }
            }));
        }));
    }
    zoomIn(t2) {
        return new Promise(((e2, i2) => {
            const n2 = this.instance, s2 = n2.container, {panzoom: o2, contentEl: a2, el: r2} = t2;
            o2 && o2.updateMetrics();
            const l2 = this.getZoomInfo(t2);
            if (!(l2 && r2 && a2 && o2 && s2)) return void i2();
            const {x: c2, y: h2, scale: d2, opacity: u2} = l2, p2 = () => {
                t2.state !== lt.Closing && (u2 && (a2.style.opacity = Math.max(Math.min(1, 1 - (1 - o2.scale) / (1 - d2)), 0) + ""), 
                o2.scale >= 1 && o2.scale > o2.targetScale - .1 && e2(o2));
            }, f2 = t3 => {
                (t3.scale < .99 || t3.scale > 1.01) && !t3.isDragging || (S(s2, yt), a2.style.opacity = "", 
                t3.off("endAnimation", f2), t3.off("touchStart", f2), t3.off("afterTransform", p2), 
                e2(t3));
            };
            o2.on("endAnimation", f2), o2.on("touchStart", f2), o2.on("afterTransform", p2), 
            o2.on([ "error", "destroy" ], (() => {
                i2();
            })), o2.panTo({
                x: c2,
                y: h2,
                scale: d2,
                friction: 0,
                ignoreBounds: true
            }), o2.stop("current");
            const g2 = {
                event: "mousemove" === o2.panMode ? n2.prevMouseMoveEvent || n2.options.event : void 0
            }, m2 = this.optionFor(t2, "initialSize");
            P(s2, yt), n2.hideLoading(t2), "full" === m2 ? o2.zoomToFull(g2) : "cover" === m2 ? o2.zoomToCover(g2) : "max" === m2 ? o2.zoomToMax(g2) : o2.reset(.172);
        }));
    }
    getZoomInfo(t2) {
        const {el: e2, imageEl: i2, thumbEl: n2, panzoom: s2} = t2, o2 = this.instance, a2 = o2.container;
        if (!e2 || !i2 || !n2 || !s2 || tt(n2) < 3 || !this.optionFor(t2, "zoom") || !a2 || o2.state === rt.Destroy) return false;
        if ("0" === getComputedStyle(a2).getPropertyValue("--f-images-zoom")) return false;
        const r2 = window.visualViewport || null;
        if (1 !== (r2 ? r2.scale : 1)) return false;
        let {top: l2, left: c2, width: h2, height: d2} = n2.getBoundingClientRect(), {top: u2, left: p2, fitWidth: f2, fitHeight: g2} = s2.contentRect;
        if (!(h2 && d2 && f2 && g2)) return false;
        const m2 = s2.container.getBoundingClientRect();
        p2 += m2.left, u2 += m2.top;
        const v2 = -1 * (p2 + .5 * f2 - (c2 + .5 * h2)), b2 = -1 * (u2 + .5 * g2 - (l2 + .5 * d2)), y2 = h2 / f2;
        let w2 = this.option("zoomOpacity") || false;
        return "auto" === w2 && (w2 = Math.abs(h2 / d2 - f2 / g2) > .1), {
            x: v2,
            y: b2,
            scale: y2,
            opacity: w2
        };
    }
    attach() {
        const t2 = this, e2 = t2.instance;
        e2.on("Carousel.change", t2.onChange), e2.on("Carousel.createSlide", t2.onCreateSlide), 
        e2.on("Carousel.removeSlide", t2.onRemoveSlide), e2.on("close", t2.onClose);
    }
    detach() {
        const t2 = this, e2 = t2.instance;
        e2.off("Carousel.change", t2.onChange), e2.off("Carousel.createSlide", t2.onCreateSlide), 
        e2.off("Carousel.removeSlide", t2.onRemoveSlide), e2.off("close", t2.onClose);
    }
}

Object.defineProperty(wt, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        initialSize: "fit",
        Panzoom: {
            maxScale: 1
        },
        protected: false,
        zoom: true,
        zoomOpacity: "auto"
    }
}), "function" == typeof SuppressedError && SuppressedError;

const xt = "html", Et = "image", St = "map", Pt = "youtube", Ct = "vimeo", Tt = "html5video", Mt = (t2, e2 = {}) => {
    const i2 = new URL(t2), n2 = new URLSearchParams(i2.search), s2 = new URLSearchParams;
    for (const [t3, i3] of [ ...n2, ...Object.entries(e2) ]) {
        let e3 = i3 + "";
        if ("t" === t3) {
            let t4 = e3.match(/((\d*)m)?(\d*)s?/);
            t4 && s2.set("start", 60 * parseInt(t4[2] || "0") + parseInt(t4[3] || "0") + "");
        } else s2.set(t3, e3);
    }
    let o2 = s2 + "", a2 = t2.match(/#t=((.*)?\d+s)/);
    return a2 && (o2 += `#t=${a2[1]}`), o2;
}, Ot = {
    ajax: null,
    autoSize: true,
    iframeAttr: {
        allow: "autoplay; fullscreen",
        scrolling: "auto"
    },
    preload: true,
    videoAutoplay: true,
    videoRatio: 16 / 9,
    videoTpl: `<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn't support embedded videos.</video>`,
    videoFormat: "",
    vimeo: {
        byline: 1,
        color: "00adef",
        controls: 1,
        dnt: 1,
        muted: 0
    },
    youtube: {
        controls: 1,
        enablejsapi: 1,
        nocookie: 1,
        rel: 0,
        fs: 1
    }
}, At = [ "image", "html", "ajax", "inline", "clone", "iframe", "map", "pdf", "html5video", "youtube", "vimeo" ];

class Lt extends _ {
    onBeforeInitSlide(t2, e2, i2) {
        this.processType(i2);
    }
    onCreateSlide(t2, e2, i2) {
        this.setContent(i2);
    }
    onClearContent(t2, e2) {
        e2.xhr && (e2.xhr.abort(), e2.xhr = null);
        const i2 = e2.iframeEl;
        i2 && (i2.onload = i2.onerror = null, i2.src = "//about:blank", e2.iframeEl = null);
        const n2 = e2.contentEl, s2 = e2.placeholderEl;
        if ("inline" === e2.type && n2 && s2) n2.classList.remove("fancybox__content"), 
        "none" !== getComputedStyle(n2).getPropertyValue("display") && (n2.style.display = "none"), 
        setTimeout((() => {
            s2 && (n2 && s2.parentNode && s2.parentNode.insertBefore(n2, s2), s2.remove());
        }), 0), e2.contentEl = void 0, e2.placeholderEl = void 0; else for (;e2.el && e2.el.firstChild; ) e2.el.removeChild(e2.el.firstChild);
    }
    onSelectSlide(t2, e2, i2) {
        i2.state === lt.Ready && this.playVideo();
    }
    onUnselectSlide(t2, e2, i2) {
        var n2, s2;
        if (i2.type === Tt) {
            try {
                null === (s2 = null === (n2 = i2.el) || void 0 === n2 ? void 0 : n2.querySelector("video")) || void 0 === s2 || s2.pause();
            } catch (t3) {}
            return;
        }
        let o2;
        i2.type === Ct ? o2 = {
            method: "pause",
            value: "true"
        } : i2.type === Pt && (o2 = {
            event: "command",
            func: "pauseVideo"
        }), o2 && i2.iframeEl && i2.iframeEl.contentWindow && i2.iframeEl.contentWindow.postMessage(JSON.stringify(o2), "*"), 
        i2.poller && clearTimeout(i2.poller);
    }
    onDone(t2, e2) {
        t2.isCurrentSlide(e2) && !t2.isClosing() && this.playVideo();
    }
    onRefresh(t2, e2) {
        e2.slides.forEach((t3 => {
            t3.el && (this.resizeIframe(t3), this.setAspectRatio(t3));
        }));
    }
    onMessage(t2) {
        try {
            let e2 = JSON.parse(t2.data);
            if ("https://player.vimeo.com" === t2.origin) {
                if ("ready" === e2.event) for (let e3 of Array.from(document.getElementsByClassName("fancybox__iframe"))) e3 instanceof HTMLIFrameElement && e3.contentWindow === t2.source && (e3.dataset.ready = "true");
            } else if (t2.origin.match(/^https:\/\/(www.)?youtube(-nocookie)?.com$/) && "onReady" === e2.event) {
                const t3 = document.getElementById(e2.id);
                t3 && (t3.dataset.ready = "true");
            }
        } catch (t3) {}
    }
    loadAjaxContent(t2) {
        const e2 = this.instance.optionFor(t2, "src") || "";
        this.instance.showLoading(t2);
        const i2 = this.instance, n2 = new XMLHttpRequest;
        i2.showLoading(t2), n2.onreadystatechange = function() {
            n2.readyState === XMLHttpRequest.DONE && i2.state === rt.Ready && (i2.hideLoading(t2), 
            200 === n2.status ? i2.setContent(t2, n2.responseText) : i2.setError(t2, 404 === n2.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"));
        };
        const s2 = t2.ajax || null;
        n2.open(s2 ? "POST" : "GET", e2 + ""), n2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), 
        n2.setRequestHeader("X-Requested-With", "XMLHttpRequest"), n2.send(s2), t2.xhr = n2;
    }
    setInlineContent(t2) {
        let e2 = null;
        if (E(t2.src)) e2 = t2.src; else if ("string" == typeof t2.src) {
            const i2 = t2.src.split("#", 2).pop();
            e2 = i2 ? document.getElementById(i2) : null;
        }
        if (e2) {
            if ("clone" === t2.type || e2.closest(".fancybox__slide")) {
                e2 = e2.cloneNode(true);
                const i2 = e2.dataset.animationName;
                i2 && (e2.classList.remove(i2), delete e2.dataset.animationName);
                let n2 = e2.getAttribute("id");
                n2 = n2 ? `${n2}--clone` : `clone-${this.instance.id}-${t2.index}`, e2.setAttribute("id", n2);
            } else if (e2.parentNode) {
                const i2 = document.createElement("div");
                i2.classList.add("fancybox-placeholder"), e2.parentNode.insertBefore(i2, e2), t2.placeholderEl = i2;
            }
            this.instance.setContent(t2, e2);
        } else this.instance.setError(t2, "{{ELEMENT_NOT_FOUND}}");
    }
    setIframeContent(t2) {
        const {src: e2, el: i2} = t2;
        if (!e2 || "string" != typeof e2 || !i2) return;
        i2.classList.add("is-loading");
        const n2 = this.instance, s2 = document.createElement("iframe");
        s2.className = "fancybox__iframe", s2.setAttribute("id", `fancybox__iframe_${n2.id}_${t2.index}`);
        for (const [e3, i3] of Object.entries(this.optionFor(t2, "iframeAttr") || {})) s2.setAttribute(e3, i3);
        s2.onerror = () => {
            n2.setError(t2, "{{IFRAME_ERROR}}");
        }, t2.iframeEl = s2;
        const o2 = this.optionFor(t2, "preload");
        if ("iframe" !== t2.type || false === o2) return s2.setAttribute("src", t2.src + ""), 
        n2.setContent(t2, s2, false), this.resizeIframe(t2), void n2.revealContent(t2);
        n2.showLoading(t2), s2.onload = () => {
            if (!s2.src.length) return;
            const e3 = "true" !== s2.dataset.ready;
            s2.dataset.ready = "true", this.resizeIframe(t2), e3 ? n2.revealContent(t2) : n2.hideLoading(t2);
        }, s2.setAttribute("src", e2), n2.setContent(t2, s2, false);
    }
    resizeIframe(t2) {
        const {type: e2, iframeEl: i2} = t2;
        if (e2 === Pt || e2 === Ct) return;
        const n2 = null == i2 ? void 0 : i2.parentElement;
        if (!i2 || !n2) return;
        let s2 = t2.autoSize;
        void 0 === s2 && (s2 = this.optionFor(t2, "autoSize"));
        let o2 = t2.width || 0, a2 = t2.height || 0;
        o2 && a2 && (s2 = false);
        const r2 = n2 && n2.style;
        if (false !== t2.preload && false !== s2 && r2) try {
            const t3 = window.getComputedStyle(n2), e3 = parseFloat(t3.paddingLeft) + parseFloat(t3.paddingRight), s3 = parseFloat(t3.paddingTop) + parseFloat(t3.paddingBottom), l2 = i2.contentWindow;
            if (l2) {
                const t4 = l2.document, i3 = t4.getElementsByTagName(xt)[0], n3 = t4.body;
                r2.width = "", n3.style.overflow = "hidden", o2 = o2 || i3.scrollWidth + e3, r2.width = `${o2}px`, 
                n3.style.overflow = "", r2.flex = "0 0 auto", r2.height = `${n3.scrollHeight}px`, 
                a2 = i3.scrollHeight + s3;
            }
        } catch (t3) {}
        if (o2 || a2) {
            const t3 = {
                flex: "0 1 auto",
                width: "",
                height: ""
            };
            o2 && "auto" !== o2 && (t3.width = `${o2}px`), a2 && "auto" !== a2 && (t3.height = `${a2}px`), 
            Object.assign(r2, t3);
        }
    }
    playVideo() {
        const t2 = this.instance.getSlide();
        if (!t2) return;
        const {el: e2} = t2;
        if (!e2 || !e2.offsetParent) return;
        if (!this.optionFor(t2, "videoAutoplay")) return;
        if (t2.type === Tt) try {
            const t3 = e2.querySelector("video");
            if (t3) {
                const e3 = t3.play();
                void 0 !== e3 && e3.then((() => {})).catch((e4 => {
                    t3.muted = true, t3.play();
                }));
            }
        } catch (t3) {}
        if (t2.type !== Pt && t2.type !== Ct) return;
        const i2 = () => {
            if (t2.iframeEl && t2.iframeEl.contentWindow) {
                let e3;
                if ("true" === t2.iframeEl.dataset.ready) return e3 = t2.type === Pt ? {
                    event: "command",
                    func: "playVideo"
                } : {
                    method: "play",
                    value: "true"
                }, e3 && t2.iframeEl.contentWindow.postMessage(JSON.stringify(e3), "*"), void (t2.poller = void 0);
                t2.type === Pt && (e3 = {
                    event: "listening",
                    id: t2.iframeEl.getAttribute("id")
                }, t2.iframeEl.contentWindow.postMessage(JSON.stringify(e3), "*"));
            }
            t2.poller = setTimeout(i2, 250);
        };
        i2();
    }
    processType(t2) {
        if (t2.html) return t2.type = xt, t2.src = t2.html, void (t2.html = "");
        const e2 = this.instance.optionFor(t2, "src", "");
        if (!e2 || "string" != typeof e2) return;
        let i2 = t2.type, n2 = null;
        if (n2 = e2.match(/(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|shorts\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) {
            const s2 = this.optionFor(t2, Pt), {nocookie: o2} = s2, a2 = function(t3, e3) {
                var i3 = {};
                for (var n3 in t3) Object.prototype.hasOwnProperty.call(t3, n3) && e3.indexOf(n3) < 0 && (i3[n3] = t3[n3]);
                if (null != t3 && "function" == typeof Object.getOwnPropertySymbols) {
                    var s3 = 0;
                    for (n3 = Object.getOwnPropertySymbols(t3); s3 < n3.length; s3++) e3.indexOf(n3[s3]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, n3[s3]) && (i3[n3[s3]] = t3[n3[s3]]);
                }
                return i3;
            }(s2, [ "nocookie" ]), r2 = `www.youtube${o2 ? "-nocookie" : ""}.com`, l2 = Mt(e2, a2), c2 = encodeURIComponent(n2[2]);
            t2.videoId = c2, t2.src = `https://${r2}/embed/${c2}?${l2}`, t2.thumbSrc = t2.thumbSrc || `https://i.ytimg.com/vi/${c2}/mqdefault.jpg`, 
            i2 = Pt;
        } else if (n2 = e2.match(/^.+vimeo.com\/(?:\/)?([\d]+)((\/|\?h=)([a-z0-9]+))?(.*)?/)) {
            const s2 = Mt(e2, this.optionFor(t2, Ct)), o2 = encodeURIComponent(n2[1]), a2 = n2[4] || "";
            t2.videoId = o2, t2.src = `https://player.vimeo.com/video/${o2}?${a2 ? `h=${a2}${s2 ? "&" : ""}` : ""}${s2}`, 
            i2 = Ct;
        }
        if (!i2 && t2.triggerEl) {
            const e3 = t2.triggerEl.dataset.type;
            At.includes(e3) && (i2 = e3);
        }
        i2 || "string" == typeof e2 && ("#" === e2.charAt(0) ? i2 = "inline" : (n2 = e2.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (i2 = Tt, 
        t2.videoFormat = t2.videoFormat || "video/" + ("ogv" === n2[1] ? "ogg" : n2[1])) : e2.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? i2 = Et : e2.match(/\.(pdf)((\?|#).*)?$/i) && (i2 = "pdf")), 
        (n2 = e2.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t2.src = `https://maps.google.${n2[1]}/?ll=${(n2[2] ? n2[2] + "&z=" + Math.floor(parseFloat(n2[3])) + (n2[4] ? n2[4].replace(/^\//, "&") : "") : n2[4] + "").replace(/\?/, "&")}&output=${n2[4] && n2[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, 
        i2 = St) : (n2 = e2.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t2.src = `https://maps.google.${n2[1]}/maps?q=${n2[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, 
        i2 = St), i2 = i2 || this.instance.option("defaultType"), t2.type = i2, i2 === Et && (t2.thumbSrc = t2.thumbSrc || t2.src);
    }
    setContent(t2) {
        const e2 = this.instance.optionFor(t2, "src") || "";
        if (t2 && t2.type && e2) {
            switch (t2.type) {
              case xt:
                this.instance.setContent(t2, e2);
                break;

              case Tt:
                const i2 = this.option("videoTpl");
                i2 && this.instance.setContent(t2, i2.replace(/\{\{src\}\}/gi, e2 + "").replace(/\{\{format\}\}/gi, this.optionFor(t2, "videoFormat") || "").replace(/\{\{poster\}\}/gi, t2.poster || t2.thumbSrc || ""));
                break;

              case "inline":
              case "clone":
                this.setInlineContent(t2);
                break;

              case "ajax":
                this.loadAjaxContent(t2);
                break;

              case "pdf":
              case St:
              case Pt:
              case Ct:
                t2.preload = false;

              case "iframe":
                this.setIframeContent(t2);
            }
            this.setAspectRatio(t2);
        }
    }
    setAspectRatio(t2) {
        const e2 = t2.contentEl;
        if (!(t2.el && e2 && t2.type && [ Pt, Ct, Tt ].includes(t2.type))) return;
        let i2, n2 = t2.width || "auto", s2 = t2.height || "auto";
        if ("auto" === n2 || "auto" === s2) {
            i2 = this.optionFor(t2, "videoRatio");
            const e3 = (i2 + "").match(/(\d+)\s*\/\s?(\d+)/);
            i2 = e3 && e3.length > 2 ? parseFloat(e3[1]) / parseFloat(e3[2]) : parseFloat(i2 + "");
        } else n2 && s2 && (i2 = n2 / s2);
        if (!i2) return;
        e2.style.aspectRatio = "", e2.style.width = "", e2.style.height = "", e2.offsetHeight;
        const o2 = e2.getBoundingClientRect(), a2 = o2.width || 1, r2 = o2.height || 1;
        e2.style.aspectRatio = i2 + "", i2 < a2 / r2 ? (s2 = "auto" === s2 ? r2 : Math.min(r2, s2), 
        e2.style.width = "auto", e2.style.height = `${s2}px`) : (n2 = "auto" === n2 ? a2 : Math.min(a2, n2), 
        e2.style.width = `${n2}px`, e2.style.height = "auto");
    }
    attach() {
        const t2 = this, e2 = t2.instance;
        e2.on("Carousel.beforeInitSlide", t2.onBeforeInitSlide), e2.on("Carousel.createSlide", t2.onCreateSlide), 
        e2.on("Carousel.selectSlide", t2.onSelectSlide), e2.on("Carousel.unselectSlide", t2.onUnselectSlide), 
        e2.on("Carousel.Panzoom.refresh", t2.onRefresh), e2.on("done", t2.onDone), e2.on("clearContent", t2.onClearContent), 
        window.addEventListener("message", t2.onMessage);
    }
    detach() {
        const t2 = this, e2 = t2.instance;
        e2.off("Carousel.beforeInitSlide", t2.onBeforeInitSlide), e2.off("Carousel.createSlide", t2.onCreateSlide), 
        e2.off("Carousel.selectSlide", t2.onSelectSlide), e2.off("Carousel.unselectSlide", t2.onUnselectSlide), 
        e2.off("Carousel.Panzoom.refresh", t2.onRefresh), e2.off("done", t2.onDone), e2.off("clearContent", t2.onClearContent), 
        window.removeEventListener("message", t2.onMessage);
    }
}

Object.defineProperty(Lt, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Ot
});

const zt = "play", Rt = "pause", kt = "ready";

class It extends _ {
    constructor() {
        super(...arguments), Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: kt
        }), Object.defineProperty(this, "inHover", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "timer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "progressBar", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
    }
    get isActive() {
        return this.state !== kt;
    }
    onReady(t2) {
        this.option("autoStart") && (t2.isInfinite || t2.page < t2.pages.length - 1) && this.start();
    }
    onChange() {
        this.removeProgressBar(), this.pause();
    }
    onSettle() {
        this.resume();
    }
    onVisibilityChange() {
        "visible" === document.visibilityState ? this.resume() : this.pause();
    }
    onMouseEnter() {
        this.inHover = true, this.pause();
    }
    onMouseLeave() {
        var t2;
        this.inHover = false, (null === (t2 = this.instance.panzoom) || void 0 === t2 ? void 0 : t2.isResting) && this.resume();
    }
    onTimerEnd() {
        const t2 = this.instance;
        "play" === this.state && (t2.isInfinite || t2.page !== t2.pages.length - 1 ? t2.slideNext() : t2.slideTo(0));
    }
    removeProgressBar() {
        this.progressBar && (this.progressBar.remove(), this.progressBar = null);
    }
    createProgressBar() {
        var t2;
        if (!this.option("showProgress")) return null;
        this.removeProgressBar();
        const e2 = this.instance, i2 = (null === (t2 = e2.pages[e2.page]) || void 0 === t2 ? void 0 : t2.slides) || [];
        let n2 = this.option("progressParentEl");
        if (n2 || (n2 = (1 === i2.length ? i2[0].el : null) || e2.viewport), !n2) return null;
        const s2 = document.createElement("div");
        return P(s2, "f-progress"), n2.prepend(s2), this.progressBar = s2, s2.offsetHeight, 
        s2;
    }
    set() {
        const t2 = this, e2 = t2.instance;
        if (e2.pages.length < 2) return;
        if (t2.timer) return;
        const i2 = t2.option("timeout");
        t2.state = zt, P(e2.container, "has-autoplay");
        let n2 = t2.createProgressBar();
        n2 && (n2.style.transitionDuration = `${i2}ms`, n2.style.transform = "scaleX(1)"), 
        t2.timer = setTimeout((() => {
            t2.timer = null, t2.inHover || t2.onTimerEnd();
        }), i2), t2.emit("set");
    }
    clear() {
        const t2 = this;
        t2.timer && (clearTimeout(t2.timer), t2.timer = null), t2.removeProgressBar();
    }
    start() {
        const t2 = this;
        if (t2.set(), t2.state !== kt) {
            if (t2.option("pauseOnHover")) {
                const e2 = t2.instance.container;
                e2.addEventListener("mouseenter", t2.onMouseEnter, false), e2.addEventListener("mouseleave", t2.onMouseLeave, false);
            }
            document.addEventListener("visibilitychange", t2.onVisibilityChange, false), t2.emit("start");
        }
    }
    stop() {
        const t2 = this, e2 = t2.state, i2 = t2.instance.container;
        t2.clear(), t2.state = kt, i2.removeEventListener("mouseenter", t2.onMouseEnter, false), 
        i2.removeEventListener("mouseleave", t2.onMouseLeave, false), document.removeEventListener("visibilitychange", t2.onVisibilityChange, false), 
        S(i2, "has-autoplay"), e2 !== kt && t2.emit("stop");
    }
    pause() {
        const t2 = this;
        t2.state === zt && (t2.state = Rt, t2.clear(), t2.emit(Rt));
    }
    resume() {
        const t2 = this, e2 = t2.instance;
        if (e2.isInfinite || e2.page !== e2.pages.length - 1) if (t2.state !== zt) {
            if (t2.state === Rt && !t2.inHover) {
                const e3 = new Event("resume", {
                    bubbles: true,
                    cancelable: true
                });
                t2.emit("resume", e3), e3.defaultPrevented || t2.set();
            }
        } else t2.set(); else t2.stop();
    }
    toggle() {
        this.state === zt || this.state === Rt ? this.stop() : this.start();
    }
    attach() {
        const t2 = this, e2 = t2.instance;
        e2.on("ready", t2.onReady), e2.on("Panzoom.startAnimation", t2.onChange), e2.on("Panzoom.endAnimation", t2.onSettle), 
        e2.on("Panzoom.touchMove", t2.onChange);
    }
    detach() {
        const t2 = this, e2 = t2.instance;
        e2.off("ready", t2.onReady), e2.off("Panzoom.startAnimation", t2.onChange), e2.off("Panzoom.endAnimation", t2.onSettle), 
        e2.off("Panzoom.touchMove", t2.onChange), t2.stop();
    }
}

Object.defineProperty(It, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        autoStart: true,
        pauseOnHover: true,
        progressParentEl: null,
        showProgress: true,
        timeout: 3e3
    }
});

class Dt extends _ {
    constructor() {
        super(...arguments), Object.defineProperty(this, "ref", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
    }
    onPrepare(t2) {
        const e2 = t2.carousel;
        if (!e2) return;
        const i2 = t2.container;
        i2 && (e2.options.Autoplay = u({
            autoStart: false
        }, this.option("Autoplay") || {}, {
            pauseOnHover: false,
            timeout: this.option("timeout"),
            progressParentEl: () => this.option("progressParentEl") || null,
            on: {
                start: () => {
                    t2.emit("startSlideshow");
                },
                set: e3 => {
                    var n2;
                    i2.classList.add("has-slideshow"), (null === (n2 = t2.getSlide()) || void 0 === n2 ? void 0 : n2.state) !== lt.Ready && e3.pause();
                },
                stop: () => {
                    i2.classList.remove("has-slideshow"), t2.isCompact || t2.endIdle(), t2.emit("endSlideshow");
                },
                resume: (e3, i3) => {
                    var n2, s2, o2;
                    !i3 || !i3.cancelable || (null === (n2 = t2.getSlide()) || void 0 === n2 ? void 0 : n2.state) === lt.Ready && (null === (o2 = null === (s2 = t2.carousel) || void 0 === s2 ? void 0 : s2.panzoom) || void 0 === o2 ? void 0 : o2.isResting) || i3.preventDefault();
                }
            }
        }), e2.attachPlugins({
            Autoplay: It
        }), this.ref = e2.plugins.Autoplay);
    }
    onReady(t2) {
        const e2 = t2.carousel, i2 = this.ref;
        i2 && e2 && this.option("playOnStart") && (e2.isInfinite || e2.page < e2.pages.length - 1) && i2.start();
    }
    onDone(t2, e2) {
        const i2 = this.ref, n2 = t2.carousel;
        if (!i2 || !n2) return;
        const s2 = e2.panzoom;
        s2 && s2.on("startAnimation", (() => {
            t2.isCurrentSlide(e2) && i2.stop();
        })), t2.isCurrentSlide(e2) && i2.resume();
    }
    onKeydown(t2, e2) {
        var i2;
        const n2 = this.ref;
        n2 && e2 === this.option("key") && "BUTTON" !== (null === (i2 = document.activeElement) || void 0 === i2 ? void 0 : i2.nodeName) && n2.toggle();
    }
    attach() {
        const t2 = this, e2 = t2.instance;
        e2.on("Carousel.init", t2.onPrepare), e2.on("Carousel.ready", t2.onReady), e2.on("done", t2.onDone), 
        e2.on("keydown", t2.onKeydown);
    }
    detach() {
        const t2 = this, e2 = t2.instance;
        e2.off("Carousel.init", t2.onPrepare), e2.off("Carousel.ready", t2.onReady), e2.off("done", t2.onDone), 
        e2.off("keydown", t2.onKeydown);
    }
}

Object.defineProperty(Dt, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        key: " ",
        playOnStart: false,
        progressParentEl: t2 => {
            var e2;
            return (null === (e2 = t2.instance.container) || void 0 === e2 ? void 0 : e2.querySelector(".fancybox__toolbar [data-fancybox-toggle-slideshow]")) || t2.instance.container;
        },
        timeout: 3e3
    }
});

const Ft = {
    classes: {
        container: "f-thumbs f-carousel__thumbs",
        viewport: "f-thumbs__viewport",
        track: "f-thumbs__track",
        slide: "f-thumbs__slide",
        isResting: "is-resting",
        isSelected: "is-selected",
        isLoading: "is-loading",
        hasThumbs: "has-thumbs"
    },
    minCount: 2,
    parentEl: null,
    thumbTpl: '<button class="f-thumbs__slide__button" tabindex="0" type="button" aria-label="{{GOTO}}" data-carousel-index="%i"><img class="f-thumbs__slide__img" data-lazy-src="{{%s}}" alt="" /></button>',
    type: "modern"
};

var jt;

!function(t2) {
    t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Hidden = 2] = "Hidden";
}(jt || (jt = {}));

const Bt = "isResting", Ht = "thumbWidth", Nt = "thumbHeight", _t = "thumbClipWidth";

let $t = class extends _ {
    constructor() {
        super(...arguments), Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "modern"
        }), Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "track", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "carousel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "thumbWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "thumbClipWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "thumbHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "thumbGap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "thumbExtraGap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: jt.Init
        });
    }
    get isModern() {
        return "modern" === this.type;
    }
    onInitSlide(t2, e2) {
        const i2 = e2.el ? e2.el.dataset : void 0;
        i2 && (e2.thumbSrc = i2.thumbSrc || e2.thumbSrc || "", e2[_t] = parseFloat(i2[_t] || "") || e2[_t] || 0, 
        e2[Nt] = parseFloat(i2.thumbHeight || "") || e2[Nt] || 0), this.addSlide(e2);
    }
    onInitSlides() {
        this.build();
    }
    onChange() {
        var t2;
        if (!this.isModern) return;
        const e2 = this.container, i2 = this.instance, n2 = i2.panzoom, s2 = this.carousel, a2 = s2 ? s2.panzoom : null, r2 = i2.page;
        if (n2 && s2 && a2) {
            if (n2.isDragging) {
                S(e2, this.cn(Bt));
                let n3 = (null === (t2 = s2.pages[r2]) || void 0 === t2 ? void 0 : t2.pos) || 0;
                n3 += i2.getProgress(r2) * (this[_t] + this.thumbGap);
                let o2 = a2.getBounds();
                -1 * n3 > o2.x.min && -1 * n3 < o2.x.max && a2.panTo({
                    x: -1 * n3,
                    friction: .12
                });
            } else o(e2, this.cn(Bt), n2.isResting);
            this.shiftModern();
        }
    }
    onRefresh() {
        this.updateProps();
        for (const t2 of this.instance.slides || []) this.resizeModernSlide(t2);
        this.shiftModern();
    }
    isDisabled() {
        const t2 = this.option("minCount") || 0;
        if (t2) {
            const e3 = this.instance;
            let i2 = 0;
            for (const t3 of e3.slides || []) t3.thumbSrc && i2++;
            if (i2 < t2) return true;
        }
        const e2 = this.option("type");
        return [ "modern", "classic" ].indexOf(e2) < 0;
    }
    getThumb(t2) {
        const e2 = this.option("thumbTpl") || "";
        return {
            html: this.instance.localize(e2, [ [ "%i", t2.index ], [ "%d", t2.index + 1 ], [ "%s", t2.thumbSrc || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" ] ])
        };
    }
    addSlide(t2) {
        const e2 = this.carousel;
        e2 && e2.addSlide(t2.index, this.getThumb(t2));
    }
    getSlides() {
        const t2 = [];
        for (const e2 of this.instance.slides || []) t2.push(this.getThumb(e2));
        return t2;
    }
    resizeModernSlide(t2) {
        this.isModern && (t2[Ht] = t2[_t] && t2[Nt] ? Math.round(this[Nt] * (t2[_t] / t2[Nt])) : this[Ht]);
    }
    updateProps() {
        const t2 = this.container;
        if (!t2) return;
        const e2 = e3 => parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-" + e3)) || 0;
        this.thumbGap = e2("gap"), this.thumbExtraGap = e2("extra-gap"), this[Ht] = e2("width") || 40, 
        this[_t] = e2("clip-width") || 40, this[Nt] = e2("height") || 40;
    }
    build() {
        const t2 = this;
        if (t2.state !== jt.Init) return;
        if (t2.isDisabled()) return void t2.emit("disabled");
        const e2 = t2.instance, i2 = e2.container, n2 = t2.getSlides(), s2 = t2.option("type");
        t2.type = s2;
        const o2 = t2.option("parentEl"), a2 = t2.cn("container"), r2 = t2.cn("track");
        let l2 = null == o2 ? void 0 : o2.querySelector("." + a2);
        l2 || (l2 = document.createElement("div"), P(l2, a2), o2 ? o2.appendChild(l2) : i2.after(l2)), 
        P(l2, `is-${s2}`), P(i2, t2.cn("hasThumbs")), t2.container = l2, t2.updateProps();
        let c2 = l2.querySelector("." + r2);
        c2 || (c2 = document.createElement("div"), P(c2, t2.cn("track")), l2.appendChild(c2)), 
        t2.track = c2;
        const h2 = u({}, {
            track: c2,
            infinite: false,
            center: true,
            fill: "classic" === s2,
            dragFree: true,
            slidesPerPage: 1,
            transition: false,
            preload: .25,
            friction: .12,
            Panzoom: {
                maxVelocity: 0
            },
            Dots: false,
            Navigation: false,
            classes: {
                container: "f-thumbs",
                viewport: "f-thumbs__viewport",
                track: "f-thumbs__track",
                slide: "f-thumbs__slide"
            }
        }, t2.option("Carousel") || {}, {
            Sync: {
                target: e2
            },
            slides: n2
        }), d2 = new e2.constructor(l2, h2);
        d2.on("createSlide", ((e3, i3) => {
            t2.setProps(i3.index), t2.emit("createSlide", i3, i3.el);
        })), d2.on("ready", (() => {
            t2.shiftModern(), t2.emit("ready");
        })), d2.on("refresh", (() => {
            t2.shiftModern();
        })), d2.on("Panzoom.click", ((e3, i3, n3) => {
            t2.onClick(n3);
        })), t2.carousel = d2, t2.state = jt.Ready;
    }
    onClick(t2) {
        t2.preventDefault(), t2.stopPropagation();
        const e2 = this.instance, {pages: i2, page: n2} = e2, s2 = t3 => {
            if (t3) {
                const e3 = t3.closest("[data-carousel-index]");
                if (e3) return [ parseInt(e3.dataset.carouselIndex || "", 10) || 0, e3 ];
            }
            return [ -1, void 0 ];
        }, o2 = (t3, e3) => {
            const i3 = document.elementFromPoint(t3, e3);
            return i3 ? s2(i3) : [ -1, void 0 ];
        };
        let [a2, r2] = s2(t2.target);
        if (a2 > -1) return;
        const l2 = this[_t], c2 = t2.clientX, h2 = t2.clientY;
        let [d2, u2] = o2(c2 - l2, h2), [p2, f2] = o2(c2 + l2, h2);
        u2 && f2 ? (a2 = Math.abs(c2 - u2.getBoundingClientRect().right) < Math.abs(c2 - f2.getBoundingClientRect().left) ? d2 : p2, 
        a2 === n2 && (a2 = a2 === d2 ? p2 : d2)) : u2 ? a2 = d2 : f2 && (a2 = p2), a2 > -1 && i2[a2] && e2.slideTo(a2);
    }
    getShift(t2) {
        var e2;
        const i2 = this, {instance: n2} = i2, s2 = i2.carousel;
        if (!n2 || !s2) return 0;
        const o2 = i2[Ht], a2 = i2[_t], r2 = i2.thumbGap, l2 = i2.thumbExtraGap;
        if (!(null === (e2 = s2.slides[t2]) || void 0 === e2 ? void 0 : e2.el)) return 0;
        const c2 = .5 * (o2 - a2), h2 = n2.pages.length - 1;
        let d2 = n2.getProgress(0), u2 = n2.getProgress(h2), p2 = n2.getProgress(t2, false, true), f2 = 0, g2 = c2 + l2 + r2;
        const m2 = d2 < 0 && d2 > -1, v2 = u2 > 0 && u2 < 1;
        return 0 === t2 ? (f2 = g2 * Math.abs(d2), v2 && 1 === d2 && (f2 -= g2 * Math.abs(u2))) : t2 === h2 ? (f2 = g2 * Math.abs(u2) * -1, 
        m2 && -1 === u2 && (f2 += g2 * Math.abs(d2))) : m2 || v2 ? (f2 = -1 * g2, f2 += g2 * Math.abs(d2), 
        f2 += g2 * (1 - Math.abs(u2))) : f2 = g2 * p2, f2;
    }
    setProps(e2) {
        var i2;
        const n2 = this;
        if (!n2.isModern) return;
        const {instance: s2} = n2, o2 = n2.carousel;
        if (s2 && o2) {
            const a2 = null === (i2 = o2.slides[e2]) || void 0 === i2 ? void 0 : i2.el;
            if (a2 && a2.childNodes.length) {
                let i3 = t(1 - Math.abs(s2.getProgress(e2))), o3 = t(n2.getShift(e2));
                a2.style.setProperty("--progress", i3 ? i3 + "" : ""), a2.style.setProperty("--shift", o3 + "");
            }
        }
    }
    shiftModern() {
        const t2 = this;
        if (!t2.isModern) return;
        const {instance: e2, track: i2} = t2, n2 = e2.panzoom, s2 = t2.carousel;
        if (!(e2 && i2 && n2 && s2)) return;
        if (n2.state === m.Init || n2.state === m.Destroy) return;
        for (const i3 of e2.slides) t2.setProps(i3.index);
        let o2 = (t2[_t] + t2.thumbGap) * (s2.slides.length || 0);
        i2.style.setProperty("--width", o2 + "");
    }
    cleanup() {
        const t2 = this;
        t2.carousel && t2.carousel.destroy(), t2.carousel = null, t2.container && t2.container.remove(), 
        t2.container = null, t2.track && t2.track.remove(), t2.track = null, t2.state = jt.Init, 
        S(t2.instance.container, t2.cn("hasThumbs"));
    }
    attach() {
        const t2 = this, e2 = t2.instance;
        e2.on("initSlide", t2.onInitSlide), e2.state === B.Init ? e2.on("initSlides", t2.onInitSlides) : t2.onInitSlides(), 
        e2.on([ "change", "Panzoom.afterTransform" ], t2.onChange), e2.on("Panzoom.refresh", t2.onRefresh);
    }
    detach() {
        const t2 = this, e2 = t2.instance;
        e2.off("initSlide", t2.onInitSlide), e2.off("initSlides", t2.onInitSlides), e2.off([ "change", "Panzoom.afterTransform" ], t2.onChange), 
        e2.off("Panzoom.refresh", t2.onRefresh), t2.cleanup();
    }
};

Object.defineProperty($t, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Ft
});

const Wt = Object.assign(Object.assign({}, Ft), {
    key: "t",
    showOnStart: true,
    parentEl: null
}), Xt = "is-masked", qt = "aria-hidden";

class Yt extends _ {
    constructor() {
        super(...arguments), Object.defineProperty(this, "ref", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "hidden", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    get isEnabled() {
        const t2 = this.ref;
        return t2 && !t2.isDisabled();
    }
    get isHidden() {
        return this.hidden;
    }
    onClick(t2, e2) {
        e2.stopPropagation();
    }
    onCreateSlide(t2, e2) {
        var i2, n2, s2;
        const o2 = (null === (s2 = null === (n2 = null === (i2 = this.instance) || void 0 === i2 ? void 0 : i2.carousel) || void 0 === n2 ? void 0 : n2.slides[e2.index]) || void 0 === s2 ? void 0 : s2.type) || "", a2 = e2.el;
        if (a2 && o2) {
            let t3 = `for-${o2}`;
            [ "video", "youtube", "vimeo", "html5video" ].includes(o2) && (t3 += " for-video"), 
            P(a2, t3);
        }
    }
    onInit() {
        var t2;
        const e2 = this, i2 = e2.instance, n2 = i2.carousel;
        if (e2.ref || !n2) return;
        const s2 = e2.option("parentEl") || i2.footer || i2.container;
        if (!s2) return;
        const o2 = u({}, e2.options, {
            parentEl: s2,
            classes: {
                container: "f-thumbs fancybox__thumbs"
            },
            Carousel: {
                Sync: {
                    friction: i2.option("Carousel.friction") || 0
                }
            },
            on: {
                ready: t3 => {
                    const i3 = t3.container;
                    i3 && this.hidden && (e2.refresh(), i3.style.transition = "none", e2.hide(), i3.offsetHeight, 
                    queueMicrotask((() => {
                        i3.style.transition = "", e2.show();
                    })));
                }
            }
        });
        o2.Carousel = o2.Carousel || {}, o2.Carousel.on = u((null === (t2 = e2.options.Carousel) || void 0 === t2 ? void 0 : t2.on) || {}, {
            click: this.onClick,
            createSlide: this.onCreateSlide
        }), n2.options.Thumbs = o2, n2.attachPlugins({
            Thumbs: $t
        }), e2.ref = n2.plugins.Thumbs, e2.option("showOnStart") || (e2.ref.state = jt.Hidden, 
        e2.hidden = true);
    }
    onResize() {
        var t2;
        const e2 = null === (t2 = this.ref) || void 0 === t2 ? void 0 : t2.container;
        e2 && (e2.style.maxHeight = "");
    }
    onKeydown(t2, e2) {
        const i2 = this.option("key");
        i2 && i2 === e2 && this.toggle();
    }
    toggle() {
        const t2 = this.ref;
        if (t2 && !t2.isDisabled()) return t2.state === jt.Hidden ? (t2.state = jt.Init, 
        void t2.build()) : void (this.hidden ? this.show() : this.hide());
    }
    show() {
        const t2 = this.ref;
        if (!t2 || t2.isDisabled()) return;
        const e2 = t2.container;
        e2 && (this.refresh(), e2.offsetHeight, e2.removeAttribute(qt), e2.classList.remove(Xt), 
        this.hidden = false);
    }
    hide() {
        const t2 = this.ref, e2 = t2 && t2.container;
        e2 && (this.refresh(), e2.offsetHeight, e2.classList.add(Xt), e2.setAttribute(qt, "true")), 
        this.hidden = true;
    }
    refresh() {
        const t2 = this.ref;
        if (!t2 || !t2.state) return;
        const e2 = t2.container, i2 = (null == e2 ? void 0 : e2.firstChild) || null;
        e2 && i2 && i2.childNodes.length && (e2.style.maxHeight = `${i2.getBoundingClientRect().height}px`);
    }
    attach() {
        const t2 = this, e2 = t2.instance;
        e2.state === rt.Init ? e2.on("Carousel.init", t2.onInit) : t2.onInit(), e2.on("resize", t2.onResize), 
        e2.on("keydown", t2.onKeydown);
    }
    detach() {
        var t2;
        const e2 = this, i2 = e2.instance;
        i2.off("Carousel.init", e2.onInit), i2.off("resize", e2.onResize), i2.off("keydown", e2.onKeydown), 
        null === (t2 = i2.carousel) || void 0 === t2 || t2.detachPlugins([ "Thumbs" ]), 
        e2.ref = null;
    }
}

Object.defineProperty(Yt, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Wt
});

const Vt = {
    panLeft: {
        icon: '<svg><path d="M5 12h14M5 12l6 6M5 12l6-6"/></svg>',
        change: {
            panX: -100
        }
    },
    panRight: {
        icon: '<svg><path d="M5 12h14M13 18l6-6M13 6l6 6"/></svg>',
        change: {
            panX: 100
        }
    },
    panUp: {
        icon: '<svg><path d="M12 5v14M18 11l-6-6M6 11l6-6"/></svg>',
        change: {
            panY: -100
        }
    },
    panDown: {
        icon: '<svg><path d="M12 5v14M18 13l-6 6M6 13l6 6"/></svg>',
        change: {
            panY: 100
        }
    },
    zoomIn: {
        icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M11 8v6M8 11h6"/></svg>',
        action: "zoomIn"
    },
    zoomOut: {
        icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>',
        action: "zoomOut"
    },
    toggle1to1: {
        icon: '<svg><path d="M3.51 3.07c5.74.02 11.48-.02 17.22.02 1.37.1 2.34 1.64 2.18 3.13 0 4.08.02 8.16 0 12.23-.1 1.54-1.47 2.64-2.79 2.46-5.61-.01-11.24.02-16.86-.01-1.36-.12-2.33-1.65-2.17-3.14 0-4.07-.02-8.16 0-12.23.1-1.36 1.22-2.48 2.42-2.46Z"/><path d="M5.65 8.54h1.49v6.92m8.94-6.92h1.49v6.92M11.5 9.4v.02m0 5.18v0"/></svg>',
        action: "toggleZoom"
    },
    toggleZoom: {
        icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>',
        action: "toggleZoom"
    },
    iterateZoom: {
        icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>',
        action: "iterateZoom"
    },
    rotateCCW: {
        icon: '<svg><path d="M15 4.55a8 8 0 0 0-6 14.9M9 15v5H4M18.37 7.16v.01M13 19.94v.01M16.84 18.37v.01M19.37 15.1v.01M19.94 11v.01"/></svg>',
        action: "rotateCCW"
    },
    rotateCW: {
        icon: '<svg><path d="M9 4.55a8 8 0 0 1 6 14.9M15 15v5h5M5.63 7.16v.01M4.06 11v.01M4.63 15.1v.01M7.16 18.37v.01M11 19.94v.01"/></svg>',
        action: "rotateCW"
    },
    flipX: {
        icon: '<svg style="stroke-width: 1.3"><path d="M12 3v18M16 7v10h5L16 7M8 7v10H3L8 7"/></svg>',
        action: "flipX"
    },
    flipY: {
        icon: '<svg style="stroke-width: 1.3"><path d="M3 12h18M7 16h10L7 21v-5M7 8h10L7 3v5"/></svg>',
        action: "flipY"
    },
    fitX: {
        icon: '<svg><path d="M4 12V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6M10 18H3M21 18h-7M6 15l-3 3 3 3M18 15l3 3-3 3"/></svg>',
        action: "fitX"
    },
    fitY: {
        icon: '<svg><path d="M12 20H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6M18 14v7M18 3v7M15 18l3 3 3-3M15 6l3-3 3 3"/></svg>',
        action: "fitY"
    },
    reset: {
        icon: '<svg><path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"/></svg>',
        action: "reset"
    },
    toggleFS: {
        icon: '<svg><g><path d="M14.5 9.5 21 3m0 0h-6m6 0v6M3 21l6.5-6.5M3 21v-6m0 6h6"/></g><g><path d="m14 10 7-7m-7 7h6m-6 0V4M3 21l7-7m0 0v6m0-6H4"/></g></svg>',
        action: "toggleFS"
    }
};

var Zt;

!function(t2) {
    t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Disabled = 2] = "Disabled";
}(Zt || (Zt = {}));

const Ut = {
    absolute: "auto",
    display: {
        left: [ "infobar" ],
        middle: [],
        right: [ "iterateZoom", "slideshow", "fullscreen", "thumbs", "close" ]
    },
    enabled: "auto",
    items: {
        infobar: {
            tpl: '<div class="fancybox__infobar" tabindex="-1"><span data-fancybox-current-index></span>/<span data-fancybox-count></span></div>'
        },
        download: {
            tpl: '<a class="f-button" title="{{DOWNLOAD}}" data-fancybox-download href="javasript:;"><svg><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5 5-5M12 4v12"/></svg></a>'
        },
        prev: {
            tpl: '<button class="f-button" title="{{PREV}}" data-fancybox-prev><svg><path d="m15 6-6 6 6 6"/></svg></button>'
        },
        next: {
            tpl: '<button class="f-button" title="{{NEXT}}" data-fancybox-next><svg><path d="m9 6 6 6-6 6"/></svg></button>'
        },
        slideshow: {
            tpl: '<button class="f-button" title="{{TOGGLE_SLIDESHOW}}" data-fancybox-toggle-slideshow><svg><g><path d="M8 4v16l13 -8z"></path></g><g><path d="M8 4v15M17 4v15"/></g></svg></button>'
        },
        fullscreen: {
            tpl: '<button class="f-button" title="{{TOGGLE_FULLSCREEN}}" data-fancybox-toggle-fullscreen><svg><g><path d="M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2M16 4h2a2 2 0 0 1 2 2v2M16 20h2a2 2 0 0 0 2-2v-2"/></g><g><path d="M15 19v-2a2 2 0 0 1 2-2h2M15 5v2a2 2 0 0 0 2 2h2M5 15h2a2 2 0 0 1 2 2v2M5 9h2a2 2 0 0 0 2-2V5"/></g></svg></button>'
        },
        thumbs: {
            tpl: '<button class="f-button" title="{{TOGGLE_THUMBS}}" data-fancybox-toggle-thumbs><svg><circle cx="5.5" cy="5.5" r="1"/><circle cx="12" cy="5.5" r="1"/><circle cx="18.5" cy="5.5" r="1"/><circle cx="5.5" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="18.5" cy="12" r="1"/><circle cx="5.5" cy="18.5" r="1"/><circle cx="12" cy="18.5" r="1"/><circle cx="18.5" cy="18.5" r="1"/></svg></button>'
        },
        close: {
            tpl: '<button class="f-button" title="{{CLOSE}}" data-fancybox-close><svg><path d="m19.5 4.5-15 15M4.5 4.5l15 15"/></svg></button>'
        }
    },
    parentEl: null
}, Gt = {
    tabindex: "-1",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
}, Kt = "has-toolbar", Jt = "fancybox__toolbar";

class Qt extends _ {
    constructor() {
        super(...arguments), Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Zt.Init
        }), Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
    }
    onReady(t2) {
        var e2;
        if (!t2.carousel) return;
        let i2 = this.option("display"), n2 = this.option("absolute"), s2 = this.option("enabled");
        if ("auto" === s2) {
            const t3 = this.instance.carousel;
            let e3 = 0;
            if (t3) for (const i3 of t3.slides) (i3.panzoom || "image" === i3.type) && e3++;
            e3 || (s2 = false);
        }
        s2 || (i2 = void 0);
        let o2 = 0;
        const a2 = {
            left: [],
            middle: [],
            right: []
        };
        if (i2) for (const t3 of [ "left", "middle", "right" ]) for (const n3 of i2[t3]) {
            const i3 = this.createEl(n3);
            i3 && (null === (e2 = a2[t3]) || void 0 === e2 || e2.push(i3), o2++);
        }
        let r2 = null;
        if (o2 && (r2 = this.createContainer()), r2) {
            for (const [t3, e3] of Object.entries(a2)) {
                const i3 = document.createElement("div");
                P(i3, Jt + "__column is-" + t3);
                for (const t4 of e3) i3.appendChild(t4);
                "auto" !== n2 || "middle" !== t3 || e3.length || (n2 = true), r2.appendChild(i3);
            }
            true === n2 && P(r2, "is-absolute"), this.state = Zt.Ready, this.onRefresh();
        } else this.state = Zt.Disabled;
    }
    onClick(t2) {
        var e2, i2;
        const n2 = this.instance, s2 = n2.getSlide(), o2 = null == s2 ? void 0 : s2.panzoom, a2 = t2.target, r2 = a2 && E(a2) ? a2.dataset : null;
        if (!r2) return;
        if (void 0 !== r2.fancyboxToggleThumbs) return t2.preventDefault(), t2.stopPropagation(), 
        void (null === (e2 = n2.plugins.Thumbs) || void 0 === e2 || e2.toggle());
        if (void 0 !== r2.fancyboxToggleFullscreen) return t2.preventDefault(), t2.stopPropagation(), 
        void this.instance.toggleFullscreen();
        if (void 0 !== r2.fancyboxToggleSlideshow) {
            t2.preventDefault(), t2.stopPropagation();
            const e3 = null === (i2 = n2.carousel) || void 0 === i2 ? void 0 : i2.plugins.Autoplay;
            let s3 = e3.isActive;
            return o2 && "mousemove" === o2.panMode && !s3 && o2.reset(), void (s3 ? e3.stop() : e3.start());
        }
        const l2 = r2.panzoomAction, c2 = r2.panzoomChange;
        if ((c2 || l2) && (t2.preventDefault(), t2.stopPropagation()), c2) {
            let t3 = {};
            try {
                t3 = JSON.parse(c2);
            } catch (t4) {}
            o2 && o2.applyChange(t3);
        } else l2 && o2 && o2[l2] && o2[l2]();
    }
    onChange() {
        this.onRefresh();
    }
    onRefresh() {
        if (this.instance.isClosing()) return;
        const t2 = this.container;
        if (!t2) return;
        const e2 = this.instance.getSlide();
        if (!e2 || e2.state !== lt.Ready) return;
        const i2 = e2 && !e2.error && e2.panzoom;
        for (const e3 of t2.querySelectorAll("[data-panzoom-action]")) i2 ? (e3.removeAttribute("disabled"), 
        e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
        let n2 = i2 && i2.canZoomIn(), s2 = i2 && i2.canZoomOut();
        for (const e3 of t2.querySelectorAll('[data-panzoom-action="zoomIn"]')) n2 ? (e3.removeAttribute("disabled"), 
        e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
        for (const e3 of t2.querySelectorAll('[data-panzoom-action="zoomOut"]')) s2 ? (e3.removeAttribute("disabled"), 
        e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
        for (const e3 of t2.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
            s2 || n2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), 
            e3.setAttribute("tabindex", "-1"));
            const t3 = e3.querySelector("g");
            t3 && (t3.style.display = n2 ? "" : "none");
        }
    }
    onDone(t2, e2) {
        var i2;
        null === (i2 = e2.panzoom) || void 0 === i2 || i2.on("afterTransform", (() => {
            this.instance.isCurrentSlide(e2) && this.onRefresh();
        })), this.instance.isCurrentSlide(e2) && this.onRefresh();
    }
    createContainer() {
        const t2 = this.instance.container;
        if (!t2) return null;
        const e2 = this.option("parentEl") || t2;
        let i2 = e2.querySelector("." + Jt);
        return i2 || (i2 = document.createElement("div"), P(i2, Jt), e2.prepend(i2)), i2.addEventListener("click", this.onClick, {
            passive: false,
            capture: true
        }), t2 && P(t2, Kt), this.container = i2, i2;
    }
    createEl(t2) {
        const e2 = this.instance, i2 = e2.carousel;
        if (!i2) return null;
        if ("toggleFS" === t2) return null;
        if ("fullscreen" === t2 && !ot()) return null;
        let s2 = null;
        const o2 = i2.slides.length || 0;
        let a2 = 0, r2 = 0;
        for (const t3 of i2.slides) (t3.panzoom || "image" === t3.type) && a2++, ("image" === t3.type || t3.downloadSrc) && r2++;
        if (o2 < 2 && [ "infobar", "prev", "next" ].includes(t2)) return s2;
        if (void 0 !== Vt[t2] && !a2) return null;
        if ("download" === t2 && !r2) return null;
        if ("thumbs" === t2) {
            const t3 = e2.plugins.Thumbs;
            if (!t3 || !t3.isEnabled) return null;
        }
        if ("slideshow" === t2) if (!i2.plugins.Autoplay || o2 < 2) return null;
        if (void 0 !== Vt[t2]) {
            const e3 = Vt[t2];
            s2 = document.createElement("button"), s2.setAttribute("title", this.instance.localize(`{{${t2.toUpperCase()}}}`)), 
            P(s2, "f-button"), e3.action && (s2.dataset.panzoomAction = e3.action), e3.change && (s2.dataset.panzoomChange = JSON.stringify(e3.change)), 
            s2.appendChild(n(this.instance.localize(e3.icon)));
        } else {
            const e3 = (this.option("items") || [])[t2];
            e3 && (s2 = n(this.instance.localize(e3.tpl)), "function" == typeof e3.click && s2.addEventListener("click", (t3 => {
                t3.preventDefault(), t3.stopPropagation(), "function" == typeof e3.click && e3.click.call(this, this, t3);
            })));
        }
        const l2 = null == s2 ? void 0 : s2.querySelector("svg");
        if (l2) for (const [t3, e3] of Object.entries(Gt)) l2.getAttribute(t3) || l2.setAttribute(t3, String(e3));
        return s2;
    }
    removeContainer() {
        const t2 = this.container;
        t2 && t2.remove(), this.container = null, this.state = Zt.Disabled;
        const e2 = this.instance.container;
        e2 && S(e2, Kt);
    }
    attach() {
        const t2 = this, e2 = t2.instance;
        e2.on("Carousel.initSlides", t2.onReady), e2.on("done", t2.onDone), e2.on([ "reveal", "Carousel.change" ], t2.onChange), 
        t2.onReady(t2.instance);
    }
    detach() {
        const t2 = this, e2 = t2.instance;
        e2.off("Carousel.initSlides", t2.onReady), e2.off("done", t2.onDone), e2.off([ "reveal", "Carousel.change" ], t2.onChange), 
        t2.removeContainer();
    }
}

Object.defineProperty(Qt, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Ut
});

const te = {
    Hash: class extends _ {
        onReady() {
            ht = false;
        }
        onChange(t2) {
            ut && clearTimeout(ut);
            const {hash: e2} = pt(), {hash: i2} = ft(), n2 = t2.isOpeningSlide(t2.getSlide());
            n2 && (ct = i2 === e2 ? "" : i2), e2 && e2 !== i2 && (ut = setTimeout((() => {
                try {
                    if (t2.state === rt.Ready) {
                        let t3 = "replaceState";
                        n2 && !dt && (t3 = "pushState", dt = true), window.history[t3]({}, document.title, window.location.pathname + window.location.search + e2);
                    }
                } catch (t3) {}
            }), 300));
        }
        onClose(t2) {
            if (ut && clearTimeout(ut), !ht && dt) return dt = false, ht = false, void window.history.back();
            if (!ht) try {
                window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (ct || ""));
            } catch (t3) {}
        }
        attach() {
            const t2 = this.instance;
            t2.on("ready", this.onReady), t2.on([ "Carousel.ready", "Carousel.change" ], this.onChange), 
            t2.on("close", this.onClose);
        }
        detach() {
            const t2 = this.instance;
            t2.off("ready", this.onReady), t2.off([ "Carousel.ready", "Carousel.change" ], this.onChange), 
            t2.off("close", this.onClose);
        }
        static parseURL() {
            return ft();
        }
        static startFromUrl() {
            gt();
        }
        static destroy() {
            window.removeEventListener("hashchange", vt, false);
        }
    },
    Html: Lt,
    Images: wt,
    Slideshow: Dt,
    Thumbs: Yt,
    Toolbar: Qt
}, ee = "with-fancybox", ie = "hide-scrollbar", ne = "--fancybox-scrollbar-compensate", se = "--fancybox-body-margin", oe = "aria-hidden", ae = "is-using-tab", re = "is-animated", le = "is-compact", ce = "is-loading", he = "is-opening", de = "has-caption", ue = "disabled", pe = "tabindex", fe = "download", ge = "href", me = "src", ve = t2 => "string" == typeof t2, be = function() {
    var t2 = window.getSelection();
    return !!t2 && "Range" === t2.type;
};

let ye, we = null, xe = null, Ee = 0, Se = 0, Pe = 0, Ce = 0;

const Te =  new Map;

let Me = 0;

class Oe extends g {
    get isIdle() {
        return this.idle;
    }
    get isCompact() {
        return this.option("compact");
    }
    constructor(t2 = [], e2 = {}, i2 = {}) {
        super(e2), Object.defineProperty(this, "userSlides", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        }), Object.defineProperty(this, "userPlugins", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        }), Object.defineProperty(this, "idle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "idleTimer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "clickTimer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "pwt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "ignoreFocusChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "startedFs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        }), Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: rt.Init
        }), Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        }), Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "caption", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "footer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "carousel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "lastFocus", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        }), Object.defineProperty(this, "prevMouseMoveEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }), ye || (ye = ot()), this.id = e2.id || ++Me, Te.set(this.id, this), this.userSlides = t2, 
        this.userPlugins = i2, queueMicrotask((() => {
            this.init();
        }));
    }
    init() {
        if (this.state === rt.Destroy) return;
        this.state = rt.Init, this.attachPlugins(Object.assign(Object.assign({}, Oe.Plugins), this.userPlugins)), 
        this.emit("init"), this.emit("attachPlugins"), true === this.option("hideScrollbar") && (() => {
            if (!et) return;
            const t3 = document, e2 = t3.body, i2 = t3.documentElement;
            if (e2.classList.contains(ie)) return;
            let n2 = window.innerWidth - i2.getBoundingClientRect().width;
            const s2 = parseFloat(window.getComputedStyle(e2).marginRight);
            n2 < 0 && (n2 = 0), i2.style.setProperty(ne, `${n2}px`), s2 && e2.style.setProperty(se, `${s2}px`), 
            e2.classList.add(ie);
        })(), this.initLayout(), this.scale();
        const t2 = () => {
            this.initCarousel(this.userSlides), this.state = rt.Ready, this.attachEvents(), 
            this.emit("ready"), setTimeout((() => {
                this.container && this.container.setAttribute(oe, "false");
            }), 16);
        };
        this.option("Fullscreen.autoStart") && ye && !ye.isFullscreen() ? ye.request().then((() => {
            this.startedFs = true, t2();
        })).catch((() => t2())) : t2();
    }
    initLayout() {
        var t2, e2;
        const i2 = this.option("parentEl") || document.body, s2 = n(this.localize(this.option("tpl.main") || ""));
        if (s2) {
            if (s2.setAttribute("id", `fancybox-${this.id}`), s2.setAttribute("aria-label", this.localize("{{MODAL}}")), 
            s2.classList.toggle(le, this.isCompact), P(s2, this.option("mainClass") || ""), 
            P(s2, he), this.container = s2, this.footer = s2.querySelector(".fancybox__footer"), 
            i2.appendChild(s2), P(document.documentElement, ee), we && xe || (we = document.createElement("span"), 
            P(we, "fancybox-focus-guard"), we.setAttribute(pe, "0"), we.setAttribute(oe, "true"), 
            we.setAttribute("aria-label", "Focus guard"), xe = we.cloneNode(), null === (t2 = s2.parentElement) || void 0 === t2 || t2.insertBefore(we, s2), 
            null === (e2 = s2.parentElement) || void 0 === e2 || e2.append(xe)), s2.addEventListener("mousedown", (t3 => {
                Ee = t3.pageX, Se = t3.pageY, S(s2, ae);
            })), this.option("closeExisting")) for (const t3 of Te.values()) t3.id !== this.id && t3.close(); else this.option("animated") && (P(s2, re), 
            setTimeout((() => {
                this.isClosing() || S(s2, re);
            }), 350));
            this.emit("initLayout");
        }
    }
    initCarousel(t2) {
        const i2 = this.container;
        if (!i2) return;
        const n2 = i2.querySelector(".fancybox__carousel");
        if (!n2) return;
        const s2 = this.carousel = new Q(n2, u({}, {
            slides: t2,
            transition: "fade",
            Panzoom: {
                lockAxis: this.option("dragToClose") ? "xy" : "x",
                infinite: !!this.option("dragToClose") && "y"
            },
            Dots: false,
            Navigation: {
                classes: {
                    container: "fancybox__nav",
                    button: "f-button",
                    isNext: "is-next",
                    isPrev: "is-prev"
                }
            },
            initialPage: this.option("startIndex"),
            l10n: this.option("l10n")
        }, this.option("Carousel") || {}));
        s2.on("*", ((t3, e2, ...i3) => {
            this.emit(`Carousel.${e2}`, t3, ...i3);
        })), s2.on([ "ready", "change" ], (() => {
            this.manageCaption();
        })), this.on("Carousel.removeSlide", ((t3, e2, i3) => {
            this.clearContent(i3), i3.state = void 0;
        })), s2.on("Panzoom.touchStart", (() => {
            var t3, e2;
            this.isCompact || this.endIdle(), (null === (t3 = document.activeElement) || void 0 === t3 ? void 0 : t3.closest(".f-thumbs")) && (null === (e2 = this.container) || void 0 === e2 || e2.focus());
        })), s2.on("settle", (() => {
            this.idleTimer || this.isCompact || !this.option("idle") || this.setIdle(), this.option("autoFocus") && !this.isClosing && this.checkFocus();
        })), this.option("dragToClose") && (s2.on("Panzoom.afterTransform", ((t3, i3) => {
            const n3 = this.getSlide();
            if (n3 && e(n3.el)) return;
            const s3 = this.container;
            if (s3) {
                const t4 = Math.abs(i3.current.f), e2 = t4 < 1 ? "" : Math.max(.5, Math.min(1, 1 - t4 / i3.contentRect.fitHeight * 1.5));
                s3.style.setProperty("--fancybox-ts", e2 ? "0s" : ""), s3.style.setProperty("--fancybox-opacity", e2 + "");
            }
        })), s2.on("Panzoom.touchEnd", ((t3, i3, n3) => {
            var s3;
            const o2 = this.getSlide();
            if (o2 && e(o2.el)) return;
            if (i3.isMobile && document.activeElement && -1 !== [ "TEXTAREA", "INPUT" ].indexOf(null === (s3 = document.activeElement) || void 0 === s3 ? void 0 : s3.nodeName)) return;
            const a2 = Math.abs(i3.dragOffset.y);
            "y" === i3.lockedAxis && (a2 >= 200 || a2 >= 50 && i3.dragOffset.time < 300) && (n3 && n3.cancelable && n3.preventDefault(), 
            this.close(n3, "f-throwOut" + (i3.current.f < 0 ? "Up" : "Down")));
        }))), s2.on("change", (t3 => {
            var e2;
            let i3 = null === (e2 = this.getSlide()) || void 0 === e2 ? void 0 : e2.triggerEl;
            if (i3) {
                const e3 = new CustomEvent("slideTo", {
                    bubbles: true,
                    cancelable: true,
                    detail: t3.page
                });
                i3.dispatchEvent(e3);
            }
        })), s2.on([ "refresh", "change" ], (t3 => {
            const e2 = this.container;
            if (!e2) return;
            for (const i4 of e2.querySelectorAll("[data-fancybox-current-index]")) i4.innerHTML = t3.page + 1;
            for (const i4 of e2.querySelectorAll("[data-fancybox-count]")) i4.innerHTML = t3.pages.length;
            if (!t3.isInfinite) {
                for (const i4 of e2.querySelectorAll("[data-fancybox-next]")) t3.page < t3.pages.length - 1 ? (i4.removeAttribute(ue), 
                i4.removeAttribute(pe)) : (i4.setAttribute(ue, ""), i4.setAttribute(pe, "-1"));
                for (const i4 of e2.querySelectorAll("[data-fancybox-prev]")) t3.page > 0 ? (i4.removeAttribute(ue), 
                i4.removeAttribute(pe)) : (i4.setAttribute(ue, ""), i4.setAttribute(pe, "-1"));
            }
            const i3 = this.getSlide();
            if (!i3) return;
            let n3 = i3.downloadSrc || "";
            n3 || "image" !== i3.type || i3.error || !ve(i3[me]) || (n3 = i3[me]);
            for (const t4 of e2.querySelectorAll("[data-fancybox-download]")) {
                const e3 = i3.downloadFilename;
                n3 ? (t4.removeAttribute(ue), t4.removeAttribute(pe), t4.setAttribute(ge, n3), t4.setAttribute(fe, e3 || n3), 
                t4.setAttribute("target", "_blank")) : (t4.setAttribute(ue, ""), t4.setAttribute(pe, "-1"), 
                t4.removeAttribute(ge), t4.removeAttribute(fe));
            }
        })), this.emit("initCarousel");
    }
    attachEvents() {
        const t2 = this, e2 = t2.container;
        if (!e2) return;
        e2.addEventListener("click", t2.onClick, {
            passive: false,
            capture: false
        }), e2.addEventListener("wheel", t2.onWheel, {
            passive: false,
            capture: false
        }), document.addEventListener("keydown", t2.onKeydown, {
            passive: false,
            capture: true
        }), document.addEventListener("visibilitychange", t2.onVisibilityChange, false), 
        document.addEventListener("mousemove", t2.onMousemove), t2.option("trapFocus") && document.addEventListener("focus", t2.onFocus, true), 
        window.addEventListener("resize", t2.onResize);
        const i2 = window.visualViewport;
        i2 && (i2.addEventListener("scroll", t2.onResize), i2.addEventListener("resize", t2.onResize));
    }
    detachEvents() {
        const t2 = this, e2 = t2.container;
        if (!e2) return;
        document.removeEventListener("keydown", t2.onKeydown, {
            passive: false,
            capture: true
        }), e2.removeEventListener("wheel", t2.onWheel, {
            passive: false,
            capture: false
        }), e2.removeEventListener("click", t2.onClick, {
            passive: false,
            capture: false
        }), document.removeEventListener("mousemove", t2.onMousemove), window.removeEventListener("resize", t2.onResize);
        const i2 = window.visualViewport;
        i2 && (i2.removeEventListener("resize", t2.onResize), i2.removeEventListener("scroll", t2.onResize)), 
        document.removeEventListener("visibilitychange", t2.onVisibilityChange, false), 
        document.removeEventListener("focus", t2.onFocus, true);
    }
    scale() {
        const t2 = this.container;
        if (!t2) return;
        const e2 = window.visualViewport, i2 = Math.max(1, (null == e2 ? void 0 : e2.scale) || 1);
        let n2 = "", s2 = "", o2 = "";
        if (e2 && i2 > 1) {
            let t3 = `${e2.offsetLeft}px`, a2 = `${e2.offsetTop}px`;
            n2 = e2.width * i2 + "px", s2 = e2.height * i2 + "px", o2 = `translate3d(${t3}, ${a2}, 0) scale(${1 / i2})`;
        }
        t2.style.transform = o2, t2.style.width = n2, t2.style.height = s2;
    }
    onClick(t2) {
        var e2;
        const {container: i2, isCompact: n2} = this;
        if (!i2 || this.isClosing()) return;
        !n2 && this.option("idle") && this.resetIdle();
        const s2 = t2.composedPath()[0];
        if (s2.closest(".fancybox-spinner") || s2.closest("[data-fancybox-close]")) return t2.preventDefault(), 
        void this.close(t2);
        if (s2.closest("[data-fancybox-prev]")) return t2.preventDefault(), void this.prev();
        if (s2.closest("[data-fancybox-next]")) return t2.preventDefault(), void this.next();
        if ("click" === t2.type && 0 === t2.detail) return;
        if (Math.abs(t2.pageX - Ee) > 30 || Math.abs(t2.pageY - Se) > 30) return;
        const o2 = document.activeElement;
        if (be() && o2 && i2.contains(o2)) return;
        if (n2 && "image" === (null === (e2 = this.getSlide()) || void 0 === e2 ? void 0 : e2.type)) return void (this.clickTimer ? (clearTimeout(this.clickTimer), 
        this.clickTimer = null) : this.clickTimer = setTimeout((() => {
            this.toggleIdle(), this.clickTimer = null;
        }), 350));
        if (this.emit("click", t2), t2.defaultPrevented) return;
        let a2 = false;
        if (s2.closest(".fancybox__content")) {
            if (o2) {
                if (o2.closest("[contenteditable]")) return;
                s2.matches(nt) || o2.blur();
            }
            if (be()) return;
            a2 = this.option("contentClick");
        } else s2.closest(".fancybox__carousel") && !s2.matches(nt) && (a2 = this.option("backdropClick"));
        "close" === a2 ? (t2.preventDefault(), this.close(t2)) : "next" === a2 ? (t2.preventDefault(), 
        this.next()) : "prev" === a2 && (t2.preventDefault(), this.prev());
    }
    onWheel(t2) {
        const e2 = t2.target;
        let n2 = this.option("wheel", t2);
        e2.closest(".fancybox__thumbs") && (n2 = "slide");
        const s2 = "slide" === n2, o2 = [ -t2.deltaX || 0, -t2.deltaY || 0, -t2.detail || 0 ].reduce((function(t3, e3) {
            return Math.abs(e3) > Math.abs(t3) ? e3 : t3;
        })), a2 = Math.max(-1, Math.min(1, o2)), r2 = Date.now();
        this.pwt && r2 - this.pwt < 300 ? s2 && t2.preventDefault() : (this.pwt = r2, this.emit("wheel", t2, a2), 
        t2.defaultPrevented || ("close" === n2 ? (t2.preventDefault(), this.close(t2)) : "slide" === n2 && (i(e2) || (t2.preventDefault(), 
        this[a2 > 0 ? "prev" : "next"]()))));
    }
    onScroll() {
        window.scrollTo(Pe, Ce);
    }
    onKeydown(t2) {
        if (!this.isTopmost()) return;
        this.isCompact || !this.option("idle") || this.isClosing() || this.resetIdle();
        const e2 = t2.key, i2 = this.option("keyboard");
        if (!i2) return;
        const n2 = t2.composedPath()[0], s2 = document.activeElement && document.activeElement.classList, o2 = s2 && s2.contains("f-button") || n2.dataset.carouselPage || n2.dataset.carouselIndex;
        if ("Escape" !== e2 && !o2 && E(n2)) if (n2.isContentEditable || -1 !== [ "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO" ].indexOf(n2.nodeName)) return;
        if ("Tab" === t2.key ? P(this.container, ae) : S(this.container, ae), t2.ctrlKey || t2.altKey || t2.shiftKey) return;
        this.emit("keydown", e2, t2);
        const a2 = i2[e2];
        a2 && "function" == typeof this[a2] && (t2.preventDefault(), this[a2]());
    }
    onResize() {
        const t2 = this.container;
        if (!t2) return;
        const e2 = this.isCompact;
        t2.classList.toggle(le, e2), this.manageCaption(this.getSlide()), this.isCompact ? this.clearIdle() : this.endIdle(), 
        this.scale(), this.emit("resize");
    }
    onFocus(t2) {
        this.isTopmost() && this.checkFocus(t2);
    }
    onMousemove(t2) {
        this.prevMouseMoveEvent = t2, !this.isCompact && this.option("idle") && this.resetIdle();
    }
    onVisibilityChange() {
        "visible" === document.visibilityState ? this.checkFocus() : this.endIdle();
    }
    manageCloseBtn(t2) {
        const e2 = this.optionFor(t2, "closeButton") || false;
        if ("auto" === e2) {
            const t3 = this.plugins.Toolbar;
            if (t3 && t3.state === Zt.Ready) return;
        }
        if (!e2) return;
        if (!t2.contentEl || t2.closeBtnEl) return;
        const i2 = this.option("tpl.closeButton");
        if (i2) {
            const e3 = n(this.localize(i2));
            t2.closeBtnEl = t2.contentEl.appendChild(e3), t2.el && P(t2.el, "has-close-btn");
        }
    }
    manageCaption(t2 = void 0) {
        var e2, i2;
        const n2 = "fancybox__caption", s2 = this.container;
        if (!s2) return;
        S(s2, de);
        const o2 = this.isCompact || this.option("commonCaption"), a2 = !o2;
        if (this.caption && this.stop(this.caption), a2 && this.caption && (this.caption.remove(), 
        this.caption = null), o2 && !this.caption) for (const t3 of (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.slides) || []) t3.captionEl && (t3.captionEl.remove(), 
        t3.captionEl = void 0, S(t3.el, de), null === (i2 = t3.el) || void 0 === i2 || i2.removeAttribute("aria-labelledby"));
        if (t2 || (t2 = this.getSlide()), !t2 || o2 && !this.isCurrentSlide(t2)) return;
        const r2 = t2.el;
        let l2 = this.optionFor(t2, "caption", "");
        if (!l2) return void (o2 && this.caption && this.animate(this.caption, "f-fadeOut", (() => {
            this.caption && (this.caption.innerHTML = "");
        })));
        let c2 = null;
        if (a2) {
            if (c2 = t2.captionEl || null, r2 && !c2) {
                const e3 = n2 + `_${this.id}_${t2.index}`;
                c2 = document.createElement("div"), P(c2, n2), c2.setAttribute("id", e3), t2.captionEl = r2.appendChild(c2), 
                P(r2, de), r2.setAttribute("aria-labelledby", e3);
            }
        } else {
            if (c2 = this.caption, c2 || (c2 = s2.querySelector("." + n2)), !c2) {
                c2 = document.createElement("div"), c2.dataset.fancyboxCaption = "", P(c2, n2);
                (this.footer || s2).prepend(c2);
            }
            P(s2, de), this.caption = c2;
        }
        c2 && (c2.innerHTML = "", ve(l2) || "number" == typeof l2 ? c2.innerHTML = l2 + "" : l2 instanceof HTMLElement && c2.appendChild(l2));
    }
    checkFocus(t2) {
        this.focus(t2);
    }
    focus(t2) {
        var e2;
        if (this.ignoreFocusChange) return;
        const i2 = document.activeElement || null, n2 = (null == t2 ? void 0 : t2.target) || null, s2 = this.container, o2 = null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.viewport;
        if (!s2 || !o2) return;
        if (!t2 && i2 && s2.contains(i2)) return;
        const a2 = this.getSlide(), r2 = a2 && a2.state === lt.Ready ? a2.el : null;
        if (!r2 || r2.contains(i2) || s2 === i2) return;
        t2 && t2.cancelable && t2.preventDefault(), this.ignoreFocusChange = true;
        const l2 = Array.from(s2.querySelectorAll(nt));
        let c2 = [], h2 = null;
        for (let t3 of l2) {
            const e3 = !t3.offsetParent || !!t3.closest('[aria-hidden="true"]'), i3 = r2 && r2.contains(t3), n3 = !o2.contains(t3);
            if (t3 === s2 || (i3 || n3) && !e3) {
                c2.push(t3);
                const e4 = t3.dataset.origTabindex;
                void 0 !== e4 && e4 && (t3.tabIndex = parseFloat(e4)), t3.removeAttribute("data-orig-tabindex"), 
                !t3.hasAttribute("autoFocus") && h2 || (h2 = t3);
            } else {
                const e4 = void 0 === t3.dataset.origTabindex ? t3.getAttribute("tabindex") || "" : t3.dataset.origTabindex;
                e4 && (t3.dataset.origTabindex = e4), t3.tabIndex = -1;
            }
        }
        let d2 = null;
        t2 ? (!n2 || c2.indexOf(n2) < 0) && (d2 = h2 || s2, c2.length && (i2 === xe ? d2 = c2[0] : this.lastFocus !== s2 && i2 !== we || (d2 = c2[c2.length - 1]))) : d2 = a2 && "image" === a2.type ? s2 : h2 || s2, 
        d2 && st(d2), this.lastFocus = document.activeElement, this.ignoreFocusChange = false;
    }
    next() {
        const t2 = this.carousel;
        t2 && t2.pages.length > 1 && t2.slideNext();
    }
    prev() {
        const t2 = this.carousel;
        t2 && t2.pages.length > 1 && t2.slidePrev();
    }
    jumpTo(...t2) {
        this.carousel && this.carousel.slideTo(...t2);
    }
    isTopmost() {
        var t2;
        return (null === (t2 = Oe.getInstance()) || void 0 === t2 ? void 0 : t2.id) == this.id;
    }
    animate(t2 = null, e2 = "", i2) {
        if (!t2 || !e2) return void (i2 && i2());
        this.stop(t2);
        const n2 = s2 => {
            s2.target === t2 && t2.dataset.animationName && (t2.removeEventListener("animationend", n2), 
            delete t2.dataset.animationName, i2 && i2(), S(t2, e2));
        };
        t2.dataset.animationName = e2, t2.addEventListener("animationend", n2), P(t2, e2);
    }
    stop(t2) {
        t2 && t2.dispatchEvent(new CustomEvent("animationend", {
            bubbles: false,
            cancelable: true,
            currentTarget: t2
        }));
    }
    setContent(t2, e2 = "", i2 = true) {
        if (this.isClosing()) return;
        const s2 = t2.el;
        if (!s2) return;
        let o2 = null;
        if (E(e2) ? o2 = e2 : (o2 = n(e2 + ""), E(o2) || (o2 = document.createElement("div"), 
        o2.innerHTML = e2 + "")), [ "img", "picture", "iframe", "video", "audio" ].includes(o2.nodeName.toLowerCase())) {
            const t3 = document.createElement("div");
            t3.appendChild(o2), o2 = t3;
        }
        E(o2) && t2.filter && !t2.error && (o2 = o2.querySelector(t2.filter)), o2 && E(o2) ? (P(o2, "fancybox__content"), 
        t2.id && o2.setAttribute("id", t2.id), s2.classList.add(`has-${t2.error ? "error" : t2.type || "unknown"}`), 
        s2.prepend(o2), "none" === o2.style.display && (o2.style.display = ""), "none" === getComputedStyle(o2).getPropertyValue("display") && (o2.style.display = t2.display || this.option("defaultDisplay") || "flex"), 
        t2.contentEl = o2, i2 && this.revealContent(t2), this.manageCloseBtn(t2), this.manageCaption(t2)) : this.setError(t2, "{{ELEMENT_NOT_FOUND}}");
    }
    revealContent(t2, e2) {
        const i2 = t2.el, n2 = t2.contentEl;
        i2 && n2 && (this.emit("reveal", t2), this.hideLoading(t2), t2.state = lt.Opening, 
        (e2 = this.isOpeningSlide(t2) ? void 0 === e2 ? this.optionFor(t2, "showClass") : e2 : "f-fadeIn") ? this.animate(n2, e2, (() => {
            this.done(t2);
        })) : this.done(t2));
    }
    done(t2) {
        this.isClosing() || (t2.state = lt.Ready, this.emit("done", t2), P(t2.el, "is-done"), 
        this.isCurrentSlide(t2) && this.option("autoFocus") && queueMicrotask((() => {
            var e2;
            null === (e2 = t2.panzoom) || void 0 === e2 || e2.updateControls(), this.option("autoFocus") && this.focus();
        })), this.isOpeningSlide(t2) && (S(this.container, he), !this.isCompact && this.option("idle") && this.setIdle()));
    }
    isCurrentSlide(t2) {
        const e2 = this.getSlide();
        return !(!t2 || !e2) && e2.index === t2.index;
    }
    isOpeningSlide(t2) {
        var e2, i2;
        return null === (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.prevPage) && t2 && t2.index === (null === (i2 = this.getSlide()) || void 0 === i2 ? void 0 : i2.index);
    }
    showLoading(t2) {
        t2.state = lt.Loading;
        const e2 = t2.el;
        if (!e2) return;
        P(e2, ce), this.emit("loading", t2), t2.spinnerEl || setTimeout((() => {
            if (!this.isClosing() && !t2.spinnerEl && t2.state === lt.Loading) {
                let i2 = n(x);
                P(i2, "fancybox-spinner"), t2.spinnerEl = i2, e2.prepend(i2), this.animate(i2, "f-fadeIn");
            }
        }), 250);
    }
    hideLoading(t2) {
        const e2 = t2.el;
        if (!e2) return;
        const i2 = t2.spinnerEl;
        this.isClosing() ? null == i2 || i2.remove() : (S(e2, ce), i2 && this.animate(i2, "f-fadeOut", (() => {
            i2.remove();
        })), t2.state === lt.Loading && (this.emit("loaded", t2), t2.state = lt.Ready));
    }
    setError(t2, e2) {
        if (this.isClosing()) return;
        const i2 = new Event("error", {
            bubbles: true,
            cancelable: true
        });
        if (this.emit("error", i2, t2), i2.defaultPrevented) return;
        t2.error = e2, this.hideLoading(t2), this.clearContent(t2);
        const n2 = document.createElement("div");
        n2.classList.add("fancybox-error"), n2.innerHTML = this.localize(e2 || "<p>{{ERROR}}</p>"), 
        this.setContent(t2, n2);
    }
    clearContent(t2) {
        if (void 0 === t2.state) return;
        this.emit("clearContent", t2), t2.contentEl && (t2.contentEl.remove(), t2.contentEl = void 0);
        const e2 = t2.el;
        e2 && (S(e2, "has-error"), S(e2, "has-unknown"), S(e2, `has-${t2.type || "unknown"}`)), 
        t2.closeBtnEl && t2.closeBtnEl.remove(), t2.closeBtnEl = void 0, t2.captionEl && t2.captionEl.remove(), 
        t2.captionEl = void 0, t2.spinnerEl && t2.spinnerEl.remove(), t2.spinnerEl = void 0;
    }
    getSlide() {
        var t2;
        const e2 = this.carousel;
        return (null === (t2 = null == e2 ? void 0 : e2.pages[null == e2 ? void 0 : e2.page]) || void 0 === t2 ? void 0 : t2.slides[0]) || void 0;
    }
    close(t2, e2) {
        if (this.isClosing()) return;
        const i2 = new Event("shouldClose", {
            bubbles: true,
            cancelable: true
        });
        if (this.emit("shouldClose", i2, t2), i2.defaultPrevented) return;
        t2 && t2.cancelable && (t2.preventDefault(), t2.stopPropagation());
        const n2 = () => {
            this.proceedClose(t2, e2);
        };
        this.startedFs && ye && ye.isFullscreen() ? Promise.resolve(ye.exit()).then((() => n2())) : n2();
    }
    clearIdle() {
        this.idleTimer && clearTimeout(this.idleTimer), this.idleTimer = null;
    }
    setIdle(t2 = false) {
        const e2 = () => {
            this.clearIdle(), this.idle = true, P(this.container, "is-idle"), this.emit("setIdle");
        };
        if (this.clearIdle(), !this.isClosing()) if (t2) e2(); else {
            const t3 = this.option("idle");
            t3 && (this.idleTimer = setTimeout(e2, t3));
        }
    }
    endIdle() {
        this.clearIdle(), this.idle && !this.isClosing() && (this.idle = false, S(this.container, "is-idle"), 
        this.emit("endIdle"));
    }
    resetIdle() {
        this.endIdle(), this.setIdle();
    }
    toggleIdle() {
        this.idle ? this.endIdle() : this.setIdle(true);
    }
    toggleFullscreen() {
        ye && (ye.isFullscreen() ? ye.exit() : ye.request().then((() => {
            this.startedFs = true;
        })));
    }
    isClosing() {
        return [ rt.Closing, rt.CustomClosing, rt.Destroy ].includes(this.state);
    }
    proceedClose(t2, e2) {
        var i2, n2;
        this.state = rt.Closing, this.clearIdle(), this.detachEvents();
        const s2 = this.container, o2 = this.carousel, a2 = this.getSlide(), r2 = a2 && this.option("placeFocusBack") ? a2.triggerEl || this.option("triggerEl") : null;
        if (r2 && (tt(r2) ? st(r2) : r2.focus()), s2 && (S(s2, he), P(s2, "is-closing"), 
        s2.setAttribute(oe, "true"), this.option("animated") && P(s2, re), s2.style.pointerEvents = "none"), 
        o2) {
            o2.clearTransitions(), null === (i2 = o2.panzoom) || void 0 === i2 || i2.destroy(), 
            null === (n2 = o2.plugins.Navigation) || void 0 === n2 || n2.detach();
            for (const t3 of o2.slides) {
                t3.state = lt.Closing, this.hideLoading(t3);
                const e3 = t3.contentEl;
                e3 && this.stop(e3);
                const i3 = null == t3 ? void 0 : t3.panzoom;
                i3 && (i3.stop(), i3.detachEvents(), i3.detachObserver()), this.isCurrentSlide(t3) || o2.emit("removeSlide", t3);
            }
        }
        Pe = window.scrollX, Ce = window.scrollY, window.addEventListener("scroll", this.onScroll), 
        this.emit("close", t2), this.state !== rt.CustomClosing ? (void 0 === e2 && a2 && (e2 = this.optionFor(a2, "hideClass")), 
        e2 && a2 ? (this.animate(a2.contentEl, e2, (() => {
            o2 && o2.emit("removeSlide", a2);
        })), setTimeout((() => {
            this.destroy();
        }), 500)) : this.destroy()) : setTimeout((() => {
            this.destroy();
        }), 500);
    }
    destroy() {
        var t2;
        if (this.state === rt.Destroy) return;
        window.removeEventListener("scroll", this.onScroll), this.state = rt.Destroy, null === (t2 = this.carousel) || void 0 === t2 || t2.destroy();
        const e2 = this.container;
        e2 && e2.remove(), Te.delete(this.id);
        const i2 = Oe.getInstance();
        i2 ? i2.focus() : (we && (we.remove(), we = null), xe && (xe.remove(), xe = null), 
        S(document.documentElement, ee), (() => {
            if (!et) return;
            const t3 = document, e3 = t3.body;
            e3.classList.remove(ie), e3.style.setProperty(se, ""), t3.documentElement.style.setProperty(ne, "");
        })(), this.emit("destroy"));
    }
    static bind(t2, e2, i2) {
        if (!et) return;
        let n2, s2 = "", o2 = {};
        if (void 0 === t2 ? n2 = document.body : ve(t2) ? (n2 = document.body, s2 = t2, 
        "object" == typeof e2 && (o2 = e2 || {})) : (n2 = t2, ve(e2) && (s2 = e2), "object" == typeof i2 && (o2 = i2 || {})), 
        !n2 || !E(n2)) return;
        s2 = s2 || "[data-fancybox]";
        const a2 = Oe.openers.get(n2) ||  new Map;
        a2.set(s2, o2), Oe.openers.set(n2, a2), 1 === a2.size && n2.addEventListener("click", Oe.fromEvent);
    }
    static unbind(t2, e2) {
        let i2, n2 = "";
        if (ve(t2) ? (i2 = document.body, n2 = t2) : (i2 = t2, ve(e2) && (n2 = e2)), !i2) return;
        const s2 = Oe.openers.get(i2);
        s2 && n2 && s2.delete(n2), n2 && s2 || (Oe.openers.delete(i2), i2.removeEventListener("click", Oe.fromEvent));
    }
    static destroy() {
        let t2;
        for (;t2 = Oe.getInstance(); ) t2.destroy();
        for (const t3 of Oe.openers.keys()) t3.removeEventListener("click", Oe.fromEvent);
        Oe.openers =  new Map;
    }
    static fromEvent(t2) {
        if (t2.defaultPrevented) return;
        if (t2.button && 0 !== t2.button) return;
        if (t2.ctrlKey || t2.metaKey || t2.shiftKey) return;
        let e2 = t2.composedPath()[0];
        const i2 = e2.closest("[data-fancybox-trigger]");
        if (i2) {
            const t3 = i2.dataset.fancyboxTrigger || "", n3 = document.querySelectorAll(`[data-fancybox="${t3}"]`), s3 = parseInt(i2.dataset.fancyboxIndex || "", 10) || 0;
            e2 = n3[s3] || e2;
        }
        if (!(e2 && e2 instanceof Element)) return;
        let n2, s2, o2, a2;
        if ([ ...Oe.openers ].reverse().find((([t3, i3]) => !(!t3.contains(e2) || ![ ...i3 ].reverse().find((([i4, r3]) => {
            let l3 = e2.closest(i4);
            return !!l3 && (n2 = t3, s2 = i4, o2 = l3, a2 = r3, true);
        }))))), !n2 || !s2 || !o2) return;
        a2 = a2 || {}, t2.preventDefault(), e2 = o2;
        let r2 = [], l2 = u({}, at, a2);
        l2.event = t2, l2.triggerEl = e2, l2.delegate = i2;
        const c2 = l2.groupAll, h2 = l2.groupAttr, d2 = h2 && e2 ? e2.getAttribute(`${h2}`) : "";
        if ((!e2 || d2 || c2) && (r2 = [].slice.call(n2.querySelectorAll(s2))), e2 && !c2 && (r2 = d2 ? r2.filter((t3 => t3.getAttribute(`${h2}`) === d2)) : [ e2 ]), 
        !r2.length) return;
        const p2 = Oe.getInstance();
        return p2 && p2.options.triggerEl && r2.indexOf(p2.options.triggerEl) > -1 ? void 0 : (e2 && (l2.startIndex = r2.indexOf(e2)), 
        Oe.fromNodes(r2, l2));
    }
    static fromSelector(t2, e2, i2) {
        let n2 = null, s2 = "", o2 = {};
        if (ve(t2) ? (n2 = document.body, s2 = t2, "object" == typeof e2 && (o2 = e2 || {})) : t2 instanceof HTMLElement && ve(e2) && (n2 = t2, 
        s2 = e2, "object" == typeof i2 && (o2 = i2 || {})), !n2 || !s2) return false;
        const a2 = Oe.openers.get(n2);
        return !!a2 && (o2 = u({}, a2.get(s2) || {}, o2), !!o2 && Oe.fromNodes(Array.from(n2.querySelectorAll(s2)), o2));
    }
    static fromNodes(t2, e2) {
        e2 = u({}, at, e2 || {});
        const i2 = [];
        for (const n2 of t2) {
            const t3 = n2.dataset || {}, s2 = t3[me] || n2.getAttribute(ge) || n2.getAttribute("currentSrc") || n2.getAttribute(me) || void 0;
            let o2;
            const a2 = e2.delegate;
            let r2;
            a2 && i2.length === e2.startIndex && (o2 = a2 instanceof HTMLImageElement ? a2 : a2.querySelector("img:not([aria-hidden])")), 
            o2 || (o2 = n2 instanceof HTMLImageElement ? n2 : n2.querySelector("img:not([aria-hidden])")), 
            o2 && (r2 = o2.currentSrc || o2[me] || void 0, !r2 && o2.dataset && (r2 = o2.dataset.lazySrc || o2.dataset[me] || void 0));
            const l2 = {
                src: s2,
                triggerEl: n2,
                thumbEl: o2,
                thumbElSrc: r2,
                thumbSrc: r2
            };
            for (const e3 in t3) {
                let i3 = t3[e3] + "";
                i3 = "false" !== i3 && ("true" === i3 || i3), l2[e3] = i3;
            }
            i2.push(l2);
        }
        return new Oe(i2, e2);
    }
    static getInstance(t2) {
        if (t2) return Te.get(t2);
        return Array.from(Te.values()).reverse().find((t3 => !t3.isClosing() && t3)) || null;
    }
    static getSlide() {
        var t2;
        return (null === (t2 = Oe.getInstance()) || void 0 === t2 ? void 0 : t2.getSlide()) || null;
    }
    static show(t2 = [], e2 = {}) {
        return new Oe(t2, e2);
    }
    static next() {
        const t2 = Oe.getInstance();
        t2 && t2.next();
    }
    static prev() {
        const t2 = Oe.getInstance();
        t2 && t2.prev();
    }
    static close(t2 = true, ...e2) {
        if (t2) for (const t3 of Te.values()) t3.close(...e2); else {
            const t3 = Oe.getInstance();
            t3 && t3.close(...e2);
        }
    }
}

Object.defineProperty(Oe, "version", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "5.0.36"
}), Object.defineProperty(Oe, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: at
}), Object.defineProperty(Oe, "Plugins", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: te
}), Object.defineProperty(Oe, "openers", {
    enumerable: true,
    configurable: true,
    writable: true,
    value:  new Map
});

function isObject$1(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}

function extend$1(target, src) {
    if (target === void 0) target = {};
    if (src === void 0) src = {};
    Object.keys(src).forEach((key => {
        if (typeof target[key] === "undefined") target[key] = src[key]; else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) extend$1(target[key], src[key]);
    }));
}

const ssrDocument = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null;
    },
    querySelectorAll() {
        return [];
    },
    getElementById() {
        return null;
    },
    createEvent() {
        return {
            initEvent() {}
        };
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return [];
            }
        };
    },
    createElementNS() {
        return {};
    },
    importNode() {
        return null;
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};

function getDocument() {
    const doc = typeof document !== "undefined" ? document : {};
    extend$1(doc, ssrDocument);
    return doc;
}

const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function CustomEvent2() {
        return this;
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return "";
            }
        };
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {};
    },
    requestAnimationFrame(callback) {
        if (typeof setTimeout === "undefined") {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
        if (typeof setTimeout === "undefined") return;
        clearTimeout(id);
    }
};

function getWindow() {
    const win = typeof window !== "undefined" ? window : {};
    extend$1(win, ssrWindow);
    return win;
}

function classesToTokens(classes2) {
    if (classes2 === void 0) classes2 = "";
    return classes2.trim().split(" ").filter((c2 => !!c2.trim()));
}

function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key => {
        try {
            object[key] = null;
        } catch (e2) {}
        try {
            delete object[key];
        } catch (e2) {}
    }));
}

function nextTick(callback, delay) {
    if (delay === void 0) delay = 0;
    return setTimeout(callback, delay);
}

function now() {
    return Date.now();
}

function getComputedStyle$1(el) {
    const window2 = getWindow();
    let style;
    if (window2.getComputedStyle) style = window2.getComputedStyle(el, null);
    if (!style && el.currentStyle) style = el.currentStyle;
    if (!style) style = el.style;
    return style;
}

function getTranslate(el, axis) {
    if (axis === void 0) axis = "x";
    const window2 = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle$1(el);
    if (window2.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a2 => a2.replace(",", "."))).join(", ");
        transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
        matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
    if (axis === "y") if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
    return curTransform || 0;
}

function isObject(o2) {
    return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object";
}

function isNode(node) {
    if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") return node instanceof HTMLElement;
    return node && (node.nodeType === 1 || node.nodeType === 11);
}

function extend() {
    const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
    const noExtend = [ "__proto__", "constructor", "prototype" ];
    for (let i2 = 1; i2 < arguments.length; i2 += 1) {
        const nextSource = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
        if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
            const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
            for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                const nextKey = keysArray[nextIndex];
                const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                if (desc !== void 0 && desc.enumerable) if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else extend(to[nextKey], nextSource[nextKey]); else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                    to[nextKey] = {};
                    if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else extend(to[nextKey], nextSource[nextKey]);
                } else to[nextKey] = nextSource[nextKey];
            }
        }
    }
    return to;
}

function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
}

function animateCSSModeScroll(_ref) {
    let {swiper: swiper, targetPosition: targetPosition, side: side} = _ref;
    const window2 = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = "none";
    window2.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? "next" : "prev";
    const isOutOfBound = (current, target) => dir === "next" && current >= target || dir === "prev" && current <= target;
    const animate = () => {
        time =  (new Date).getTime();
        if (startTime === null) startTime = time;
        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
        if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
        swiper.wrapperEl.scrollTo({
            [side]: currentPosition
        });
        if (isOutOfBound(currentPosition, targetPosition)) {
            swiper.wrapperEl.style.overflow = "hidden";
            swiper.wrapperEl.style.scrollSnapType = "";
            setTimeout((() => {
                swiper.wrapperEl.style.overflow = "";
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
            }));
            window2.cancelAnimationFrame(swiper.cssModeFrameID);
            return;
        }
        swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
    };
    animate();
}

function elementChildren(element, selector) {
    if (selector === void 0) selector = "";
    return [ ...element.children ].filter((el => el.matches(selector)));
}

function showWarning(text) {
    try {
        console.warn(text);
        return;
    } catch (err) {}
}

function createElement(tag, classes2) {
    if (classes2 === void 0) classes2 = [];
    const el = document.createElement(tag);
    el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
    return el;
}

function elementOffset(el) {
    const window2 = getWindow();
    const document2 = getDocument();
    const box = el.getBoundingClientRect();
    const body = document2.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
    const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
    return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
    };
}

function elementPrevAll(el, selector) {
    const prevEls = [];
    while (el.previousElementSibling) {
        const prev = el.previousElementSibling;
        if (selector) {
            if (prev.matches(selector)) prevEls.push(prev);
        } else prevEls.push(prev);
        el = prev;
    }
    return prevEls;
}

function elementNextAll(el, selector) {
    const nextEls = [];
    while (el.nextElementSibling) {
        const next = el.nextElementSibling;
        if (selector) {
            if (next.matches(selector)) nextEls.push(next);
        } else nextEls.push(next);
        el = next;
    }
    return nextEls;
}

function elementStyle(el, prop) {
    const window2 = getWindow();
    return window2.getComputedStyle(el, null).getPropertyValue(prop);
}

function elementIndex(el) {
    let child = el;
    let i2;
    if (child) {
        i2 = 0;
        while ((child = child.previousSibling) !== null) if (child.nodeType === 1) i2 += 1;
        return i2;
    }
    return;
}

function elementParents(el, selector) {
    const parents = [];
    let parent = el.parentElement;
    while (parent) {
        if (selector) {
            if (parent.matches(selector)) parents.push(parent);
        } else parents.push(parent);
        parent = parent.parentElement;
    }
    return parents;
}

function elementTransitionEnd(el, callback) {
    function fireCallBack(e2) {
        if (e2.target !== el) return;
        callback.call(el, e2);
        el.removeEventListener("transitionend", fireCallBack);
    }
    if (callback) el.addEventListener("transitionend", fireCallBack);
}

function elementOuterSize(el, size, includeMargins) {
    const window2 = getWindow();
    return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
}

function makeElementsArray(el) {
    return (Array.isArray(el) ? el : [ el ]).filter((e2 => !!e2));
}

let support;

function calcSupport() {
    const window2 = getWindow();
    const document2 = getDocument();
    return {
        smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
        touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
    };
}

function getSupport() {
    if (!support) support = calcSupport();
    return support;
}

let deviceCached;

function calcDevice(_temp) {
    let {userAgent: userAgent} = _temp === void 0 ? {} : _temp;
    const support2 = getSupport();
    const window2 = getWindow();
    const platform = window2.navigator.platform;
    const ua = userAgent || window2.navigator.userAgent;
    const device = {
        ios: false,
        android: false
    };
    const screenWidth = window2.screen.width;
    const screenHeight = window2.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === "Win32";
    let macos = platform === "MacIntel";
    const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
    if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [ 0, 1, "13_0_0" ];
        macos = false;
    }
    if (android && !windows) {
        device.os = "android";
        device.android = true;
    }
    if (ipad || iphone || ipod) {
        device.os = "ios";
        device.ios = true;
    }
    return device;
}

function getDevice(overrides) {
    if (overrides === void 0) overrides = {};
    if (!deviceCached) deviceCached = calcDevice(overrides);
    return deviceCached;
}

let browser;

function calcBrowser() {
    const window2 = getWindow();
    const device = getDevice();
    let needPerspectiveFix = false;
    function isSafari() {
        const ua = window2.navigator.userAgent.toLowerCase();
        return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    if (isSafari()) {
        const ua = String(window2.navigator.userAgent);
        if (ua.includes("Version/")) {
            const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num => Number(num)));
            needPerspectiveFix = major < 16 || major === 16 && minor < 2;
        }
    }
    const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);
    const isSafariBrowser = isSafari();
    const need3dFix = isSafariBrowser || isWebView && device.ios;
    return {
        isSafari: needPerspectiveFix || isSafariBrowser,
        needPerspectiveFix: needPerspectiveFix,
        need3dFix: need3dFix,
        isWebView: isWebView
    };
}

function getBrowser() {
    if (!browser) browser = calcBrowser();
    return browser;
}

function Resize(_ref) {
    let {swiper: swiper, on: on, emit: emit} = _ref;
    const window2 = getWindow();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit("beforeResize");
        emit("resize");
    };
    const createObserver = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        observer = new ResizeObserver((entries => {
            animationFrame = window2.requestAnimationFrame((() => {
                const {width: width, height: height} = swiper;
                let newWidth = width;
                let newHeight = height;
                entries.forEach((_ref2 => {
                    let {contentBoxSize: contentBoxSize, contentRect: contentRect, target: target} = _ref2;
                    if (target && target !== swiper.el) return;
                    newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                    newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                }));
                if (newWidth !== width || newHeight !== height) resizeHandler();
            }));
        }));
        observer.observe(swiper.el);
    };
    const removeObserver = () => {
        if (animationFrame) window2.cancelAnimationFrame(animationFrame);
        if (observer && observer.unobserve && swiper.el) {
            observer.unobserve(swiper.el);
            observer = null;
        }
    };
    const orientationChangeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit("orientationchange");
    };
    on("init", (() => {
        if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
            createObserver();
            return;
        }
        window2.addEventListener("resize", resizeHandler);
        window2.addEventListener("orientationchange", orientationChangeHandler);
    }));
    on("destroy", (() => {
        removeObserver();
        window2.removeEventListener("resize", resizeHandler);
        window2.removeEventListener("orientationchange", orientationChangeHandler);
    }));
}

function Observer(_ref) {
    let {swiper: swiper, extendParams: extendParams, on: on, emit: emit} = _ref;
    const observers = [];
    const window2 = getWindow();
    const attach = function(target, options) {
        if (options === void 0) options = {};
        const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
        const observer = new ObserverFunc((mutations => {
            if (swiper.__preventObserver__) return;
            if (mutations.length === 1) {
                emit("observerUpdate", mutations[0]);
                return;
            }
            const observerUpdate = function observerUpdate2() {
                emit("observerUpdate", mutations[0]);
            };
            if (window2.requestAnimationFrame) window2.requestAnimationFrame(observerUpdate); else window2.setTimeout(observerUpdate, 0);
        }));
        observer.observe(target, {
            attributes: typeof options.attributes === "undefined" ? true : options.attributes,
            childList: swiper.isElement || (typeof options.childList === "undefined" ? true : options).childList,
            characterData: typeof options.characterData === "undefined" ? true : options.characterData
        });
        observers.push(observer);
    };
    const init = () => {
        if (!swiper.params.observer) return;
        if (swiper.params.observeParents) {
            const containerParents = elementParents(swiper.hostEl);
            for (let i2 = 0; i2 < containerParents.length; i2 += 1) attach(containerParents[i2]);
        }
        attach(swiper.hostEl, {
            childList: swiper.params.observeSlideChildren
        });
        attach(swiper.wrapperEl, {
            attributes: false
        });
    };
    const destroy = () => {
        observers.forEach((observer => {
            observer.disconnect();
        }));
        observers.splice(0, observers.length);
    };
    extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
    });
    on("init", init);
    on("destroy", destroy);
}

var eventsEmitter = {
    on(events2, handler, priority) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (typeof handler !== "function") return self2;
        const method = priority ? "unshift" : "push";
        events2.split(" ").forEach((event => {
            if (!self2.eventsListeners[event]) self2.eventsListeners[event] = [];
            self2.eventsListeners[event][method](handler);
        }));
        return self2;
    },
    once(events2, handler, priority) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (typeof handler !== "function") return self2;
        function onceHandler() {
            self2.off(events2, onceHandler);
            if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            handler.apply(self2, args);
        }
        onceHandler.__emitterProxy = handler;
        return self2.on(events2, onceHandler, priority);
    },
    onAny(handler, priority) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (typeof handler !== "function") return self2;
        const method = priority ? "unshift" : "push";
        if (self2.eventsAnyListeners.indexOf(handler) < 0) self2.eventsAnyListeners[method](handler);
        return self2;
    },
    offAny(handler) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (!self2.eventsAnyListeners) return self2;
        const index = self2.eventsAnyListeners.indexOf(handler);
        if (index >= 0) self2.eventsAnyListeners.splice(index, 1);
        return self2;
    },
    off(events2, handler) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (!self2.eventsListeners) return self2;
        events2.split(" ").forEach((event => {
            if (typeof handler === "undefined") self2.eventsListeners[event] = []; else if (self2.eventsListeners[event]) self2.eventsListeners[event].forEach(((eventHandler, index) => {
                if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self2.eventsListeners[event].splice(index, 1);
            }));
        }));
        return self2;
    },
    emit() {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (!self2.eventsListeners) return self2;
        let events2;
        let data;
        let context;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
            events2 = args[0];
            data = args.slice(1, args.length);
            context = self2;
        } else {
            events2 = args[0].events;
            data = args[0].data;
            context = args[0].context || self2;
        }
        data.unshift(context);
        const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
        eventsArray.forEach((event => {
            if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) self2.eventsAnyListeners.forEach((eventHandler => {
                eventHandler.apply(context, [ event, ...data ]);
            }));
            if (self2.eventsListeners && self2.eventsListeners[event]) self2.eventsListeners[event].forEach((eventHandler => {
                eventHandler.apply(context, data);
            }));
        }));
        return self2;
    }
};

function updateSize() {
    const swiper = this;
    let width;
    let height;
    const el = swiper.el;
    if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) width = swiper.params.width; else width = el.clientWidth;
    if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) height = swiper.params.height; else height = el.clientHeight;
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;
    width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
    height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    Object.assign(swiper, {
        width: width,
        height: height,
        size: swiper.isHorizontal() ? width : height
    });
}

function updateSlides() {
    const swiper = this;
    function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
    }
    const params = swiper.params;
    const {wrapperEl: wrapperEl, slidesEl: slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL: wrongRTL} = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") offsetBefore = params.slidesOffsetBefore.call(swiper);
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") offsetAfter = params.slidesOffsetAfter.call(swiper);
    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;
    if (typeof swiperSize === "undefined") return;
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
    swiper.virtualSize = -spaceBetween;
    slides.forEach((slideEl => {
        if (rtl) slideEl.style.marginLeft = ""; else slideEl.style.marginRight = "";
        slideEl.style.marginBottom = "";
        slideEl.style.marginTop = "";
    }));
    if (params.centeredSlides && params.cssMode) {
        setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
        setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
    if (gridEnabled) swiper.grid.initSlides(slides); else if (swiper.grid) swiper.grid.unsetSlides();
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key => typeof params.breakpoints[key].slidesPerView !== "undefined")).length > 0;
    for (let i2 = 0; i2 < slidesLength; i2 += 1) {
        slideSize = 0;
        let slide2;
        if (slides[i2]) slide2 = slides[i2];
        if (gridEnabled) swiper.grid.updateSlide(i2, slide2, slides);
        if (slides[i2] && elementStyle(slide2, "display") === "none") continue;
        if (params.slidesPerView === "auto") {
            if (shouldResetSlideSize) slides[i2].style[swiper.getDirectionLabel("width")] = ``;
            const slideStyles = getComputedStyle(slide2);
            const currentTransform = slide2.style.transform;
            const currentWebKitTransform = slide2.style.webkitTransform;
            if (currentTransform) slide2.style.transform = "none";
            if (currentWebKitTransform) slide2.style.webkitTransform = "none";
            if (params.roundLengths) slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, "width") : elementOuterSize(slide2, "height"); else {
                const width = getDirectionPropertyValue(slideStyles, "width");
                const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                const boxSizing = slideStyles.getPropertyValue("box-sizing");
                if (boxSizing && boxSizing === "border-box") slideSize = width + marginLeft + marginRight; else {
                    const {clientWidth: clientWidth, offsetWidth: offsetWidth} = slide2;
                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                }
            }
            if (currentTransform) slide2.style.transform = currentTransform;
            if (currentWebKitTransform) slide2.style.webkitTransform = currentWebKitTransform;
            if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
            if (params.roundLengths) slideSize = Math.floor(slideSize);
            if (slides[i2]) slides[i2].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
        }
        if (slides[i2]) slides[i2].swiperSlideSize = slideSize;
        slidesSizesGrid.push(slideSize);
        if (params.centeredSlides) {
            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
            if (prevSlideSize === 0 && i2 !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (i2 === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
        } else {
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
            slidePosition = slidePosition + slideSize + spaceBetween;
        }
        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
    if (params.setWrapperSize) wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
    if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid);
    if (!params.centeredSlides) {
        const newSlidesGrid = [];
        for (let i2 = 0; i2 < snapGrid.length; i2 += 1) {
            let slidesGridItem = snapGrid[i2];
            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[i2] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
        }
        snapGrid = newSlidesGrid;
        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
    }
    if (isVirtual && params.loop) {
        const size = slidesSizesGrid[0] + spaceBetween;
        if (params.slidesPerGroup > 1) {
            const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
            const groupSize = size * params.slidesPerGroup;
            for (let i2 = 0; i2 < groups; i2 += 1) snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
        }
        for (let i2 = 0; i2 < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i2 += 1) {
            if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);
            slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
            swiper.virtualSize += size;
        }
    }
    if (snapGrid.length === 0) snapGrid = [ 0 ];
    if (spaceBetween !== 0) {
        const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
        slides.filter(((_2, slideIndex) => {
            if (!params.cssMode || params.loop) return true;
            if (slideIndex === slides.length - 1) return false;
            return true;
        })).forEach((slideEl => {
            slideEl.style[key] = `${spaceBetween}px`;
        }));
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue => {
            allSlidesSize += slideSizeValue + (spaceBetween || 0);
        }));
        allSlidesSize -= spaceBetween;
        const maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map((snap => {
            if (snap <= 0) return -offsetBefore;
            if (snap > maxSnap) return maxSnap + offsetAfter;
            return snap;
        }));
    }
    if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue => {
            allSlidesSize += slideSizeValue + (spaceBetween || 0);
        }));
        allSlidesSize -= spaceBetween;
        const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
        if (allSlidesSize + offsetSize < swiperSize) {
            const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
            snapGrid.forEach(((snap, snapIndex) => {
                snapGrid[snapIndex] = snap - allSlidesOffset;
            }));
            slidesGrid.forEach(((snap, snapIndex) => {
                slidesGrid[snapIndex] = snap + allSlidesOffset;
            }));
        }
    }
    Object.assign(swiper, {
        slides: slides,
        snapGrid: snapGrid,
        slidesGrid: slidesGrid,
        slidesSizesGrid: slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
        setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
        const addToSnapGrid = -swiper.snapGrid[0];
        const addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map((v2 => v2 + addToSnapGrid));
        swiper.slidesGrid = swiper.slidesGrid.map((v2 => v2 + addToSlidesGrid));
    }
    if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
    if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
    if (params.watchSlidesProgress) swiper.updateSlidesOffset();
    swiper.emit("slidesUpdated");
    if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
        const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
        if (slidesLength <= params.maxBackfaceHiddenSlides) {
            if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
        } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);
    }
}

function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i2;
    if (typeof speed === "number") swiper.setTransition(speed); else if (speed === true) swiper.setTransition(swiper.params.speed);
    const getSlideByIndex = index => {
        if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];
        return swiper.slides[index];
    };
    if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide2 => {
        activeSlides.push(slide2);
    })); else for (i2 = 0; i2 < Math.ceil(swiper.params.slidesPerView); i2 += 1) {
        const index = swiper.activeIndex + i2;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
    } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
    for (i2 = 0; i2 < activeSlides.length; i2 += 1) if (typeof activeSlides[i2] !== "undefined") {
        const height = activeSlides[i2].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
    }
    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}

function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;
    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
    for (let i2 = 0; i2 < slides.length; i2 += 1) slides[i2].swiperSlideOffset = (swiper.isHorizontal() ? slides[i2].offsetLeft : slides[i2].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
}

const toggleSlideClasses$1 = (slideEl, condition, className) => {
    if (condition && !slideEl.classList.contains(className)) slideEl.classList.add(className); else if (!condition && slideEl.classList.contains(className)) slideEl.classList.remove(className);
};

function updateSlidesProgress(translate2) {
    if (translate2 === void 0) translate2 = this && this.translate || 0;
    const swiper = this;
    const params = swiper.params;
    const {slides: slides, rtlTranslate: rtl, snapGrid: snapGrid} = swiper;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
    let offsetCenter = -translate2;
    if (rtl) offsetCenter = translate2;
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    let spaceBetween = params.spaceBetween;
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
    for (let i2 = 0; i2 < slides.length; i2 += 1) {
        const slide2 = slides[i2];
        let slideOffset = slide2.swiperSlideOffset;
        if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i2];
        const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i2];
        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
        if (isVisible) {
            swiper.visibleSlides.push(slide2);
            swiper.visibleSlidesIndexes.push(i2);
        }
        toggleSlideClasses$1(slide2, isVisible, params.slideVisibleClass);
        toggleSlideClasses$1(slide2, isFullyVisible, params.slideFullyVisibleClass);
        slide2.progress = rtl ? -slideProgress : slideProgress;
        slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
}

function updateProgress(translate2) {
    const swiper = this;
    if (typeof translate2 === "undefined") {
        const multiplier = swiper.rtlTranslate ? -1 : 1;
        translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let {progress: progress, isBeginning: isBeginning, isEnd: isEnd, progressLoop: progressLoop} = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
    } else {
        progress = (translate2 - swiper.minTranslate()) / translatesDiff;
        const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
        const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
        isBeginning = isBeginningRounded || progress <= 0;
        isEnd = isEndRounded || progress >= 1;
        if (isBeginningRounded) progress = 0;
        if (isEndRounded) progress = 1;
    }
    if (params.loop) {
        const firstSlideIndex = swiper.getSlideIndexByData(0);
        const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
        const translateAbs = Math.abs(translate2);
        if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax; else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
        if (progressLoop > 1) progressLoop -= 1;
    }
    Object.assign(swiper, {
        progress: progress,
        progressLoop: progressLoop,
        isBeginning: isBeginning,
        isEnd: isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate2);
    if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
    if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
    swiper.emit("progress", progress);
}

const toggleSlideClasses = (slideEl, condition, className) => {
    if (condition && !slideEl.classList.contains(className)) slideEl.classList.add(className); else if (!condition && slideEl.classList.contains(className)) slideEl.classList.remove(className);
};

function updateSlidesClasses() {
    const swiper = this;
    const {slides: slides, params: params, slidesEl: slidesEl, activeIndex: activeIndex} = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const getFilteredSlide = selector => elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
    let activeSlide;
    let prevSlide;
    let nextSlide;
    if (isVirtual) if (params.loop) {
        let slideIndex = activeIndex - swiper.virtual.slidesBefore;
        if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
        if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`); else if (gridEnabled) {
        activeSlide = slides.filter((slideEl => slideEl.column === activeIndex))[0];
        nextSlide = slides.filter((slideEl => slideEl.column === activeIndex + 1))[0];
        prevSlide = slides.filter((slideEl => slideEl.column === activeIndex - 1))[0];
    } else activeSlide = slides[activeIndex];
    if (activeSlide) if (!gridEnabled) {
        nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !nextSlide) nextSlide = slides[0];
        prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !prevSlide === 0) prevSlide = slides[slides.length - 1];
    }
    slides.forEach((slideEl => {
        toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
        toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
        toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
    }));
    swiper.emitSlidesClasses();
}

const processLazyPreloader = (swiper, imageEl) => {
    if (!swiper || swiper.destroyed || !swiper.params) return;
    const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    const slideEl = imageEl.closest(slideSelector());
    if (slideEl) {
        let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
        if (!lazyEl && swiper.isElement) if (slideEl.shadowRoot) lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`); else requestAnimationFrame((() => {
            if (slideEl.shadowRoot) {
                lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                if (lazyEl) lazyEl.remove();
            }
        }));
        if (lazyEl) lazyEl.remove();
    }
};

const unlazy = (swiper, index) => {
    if (!swiper.slides[index]) return;
    const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
    if (imageEl) imageEl.removeAttribute("loading");
};

const preload = swiper => {
    if (!swiper || swiper.destroyed || !swiper.params) return;
    let amount = swiper.params.lazyPreloadPrevNext;
    const len = swiper.slides.length;
    if (!len || !amount || amount < 0) return;
    amount = Math.min(amount, len);
    const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
    const activeIndex = swiper.activeIndex;
    if (swiper.params.grid && swiper.params.grid.rows > 1) {
        const activeColumn = activeIndex;
        const preloadColumns = [ activeColumn - amount ];
        preloadColumns.push(...Array.from({
            length: amount
        }).map(((_2, i2) => activeColumn + slidesPerView + i2)));
        swiper.slides.forEach(((slideEl, i2) => {
            if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i2);
        }));
        return;
    }
    const slideIndexLastInView = activeIndex + slidesPerView - 1;
    if (swiper.params.rewind || swiper.params.loop) for (let i2 = activeIndex - amount; i2 <= slideIndexLastInView + amount; i2 += 1) {
        const realIndex = (i2 % len + len) % len;
        if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
    } else for (let i2 = Math.max(activeIndex - amount, 0); i2 <= Math.min(slideIndexLastInView + amount, len - 1); i2 += 1) if (i2 !== activeIndex && (i2 > slideIndexLastInView || i2 < activeIndex)) unlazy(swiper, i2);
};

function getActiveIndexByTranslate(swiper) {
    const {slidesGrid: slidesGrid, params: params} = swiper;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    let activeIndex;
    for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) if (typeof slidesGrid[i2 + 1] !== "undefined") {
        if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1] - (slidesGrid[i2 + 1] - slidesGrid[i2]) / 2) activeIndex = i2; else if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1]) activeIndex = i2 + 1;
    } else if (translate2 >= slidesGrid[i2]) activeIndex = i2;
    if (params.normalizeSlideIndex) if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
    return activeIndex;
}

function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {snapGrid: snapGrid, params: params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    const getVirtualRealIndex = aIndex => {
        let realIndex2 = aIndex - swiper.virtual.slidesBefore;
        if (realIndex2 < 0) realIndex2 = swiper.virtual.slides.length + realIndex2;
        if (realIndex2 >= swiper.virtual.slides.length) realIndex2 -= swiper.virtual.slides.length;
        return realIndex2;
    };
    if (typeof activeIndex === "undefined") activeIndex = getActiveIndexByTranslate(swiper);
    if (snapGrid.indexOf(translate2) >= 0) snapIndex = snapGrid.indexOf(translate2); else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex && !swiper.params.loop) {
        if (snapIndex !== previousSnapIndex) {
            swiper.snapIndex = snapIndex;
            swiper.emit("snapIndexChange");
        }
        return;
    }
    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
        swiper.realIndex = getVirtualRealIndex(activeIndex);
        return;
    }
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    let realIndex;
    if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex); else if (gridEnabled) {
        const firstSlideInColumn = swiper.slides.filter((slideEl => slideEl.column === activeIndex))[0];
        let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
        if (Number.isNaN(activeSlideIndex)) activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
        realIndex = Math.floor(activeSlideIndex / params.grid.rows);
    } else if (swiper.slides[activeIndex]) {
        const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
        if (slideIndex) realIndex = parseInt(slideIndex, 10); else realIndex = activeIndex;
    } else realIndex = activeIndex;
    Object.assign(swiper, {
        previousSnapIndex: previousSnapIndex,
        snapIndex: snapIndex,
        previousRealIndex: previousRealIndex,
        realIndex: realIndex,
        previousIndex: previousIndex,
        activeIndex: activeIndex
    });
    if (swiper.initialized) preload(swiper);
    swiper.emit("activeIndexChange");
    swiper.emit("snapIndexChange");
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
        swiper.emit("slideChange");
    }
}

function updateClickedSlide(el, path) {
    const swiper = this;
    const params = swiper.params;
    let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);
    if (!slide2 && swiper.isElement && path && path.length > 1 && path.includes(el)) [ ...path.slice(path.indexOf(el) + 1, path.length) ].forEach((pathEl => {
        if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) slide2 = pathEl;
    }));
    let slideFound = false;
    let slideIndex;
    if (slide2) for (let i2 = 0; i2 < swiper.slides.length; i2 += 1) if (swiper.slides[i2] === slide2) {
        slideFound = true;
        slideIndex = i2;
        break;
    }
    if (slide2 && slideFound) {
        swiper.clickedSlide = slide2;
        if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
    } else {
        swiper.clickedSlide = void 0;
        swiper.clickedIndex = void 0;
        return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
}

var update = {
    updateSize: updateSize,
    updateSlides: updateSlides,
    updateAutoHeight: updateAutoHeight,
    updateSlidesOffset: updateSlidesOffset,
    updateSlidesProgress: updateSlidesProgress,
    updateProgress: updateProgress,
    updateSlidesClasses: updateSlidesClasses,
    updateActiveIndex: updateActiveIndex,
    updateClickedSlide: updateClickedSlide
};

function getSwiperTranslate(axis) {
    if (axis === void 0) axis = this.isHorizontal() ? "x" : "y";
    const swiper = this;
    const {params: params, rtlTranslate: rtl, translate: translate2, wrapperEl: wrapperEl} = swiper;
    if (params.virtualTranslate) return rtl ? -translate2 : translate2;
    if (params.cssMode) return translate2;
    let currentTranslate = getTranslate(wrapperEl, axis);
    currentTranslate += swiper.cssOverflowAdjustment();
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
}

function setTranslate(translate2, byController) {
    const swiper = this;
    const {rtlTranslate: rtl, params: params, wrapperEl: wrapperEl, progress: progress} = swiper;
    let x2 = 0;
    let y2 = 0;
    const z2 = 0;
    if (swiper.isHorizontal()) x2 = rtl ? -translate2 : translate2; else y2 = translate2;
    if (params.roundLengths) {
        x2 = Math.floor(x2);
        y2 = Math.floor(y2);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x2 : y2;
    if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x2 : -y2; else if (!params.virtualTranslate) {
        if (swiper.isHorizontal()) x2 -= swiper.cssOverflowAdjustment(); else y2 -= swiper.cssOverflowAdjustment();
        wrapperEl.style.transform = `translate3d(${x2}px, ${y2}px, ${z2}px)`;
    }
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) newProgress = 0; else newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
    if (newProgress !== progress) swiper.updateProgress(translate2);
    swiper.emit("setTranslate", swiper.translate, byController);
}

function minTranslate() {
    return -this.snapGrid[0];
}

function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
}

function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
    if (translate2 === void 0) translate2 = 0;
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    if (translateBounds === void 0) translateBounds = true;
    const swiper = this;
    const {params: params, wrapperEl: wrapperEl} = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) return false;
    const minTranslate2 = swiper.minTranslate();
    const maxTranslate2 = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate2 > minTranslate2) newTranslate = minTranslate2; else if (translateBounds && translate2 < maxTranslate2) newTranslate = maxTranslate2; else newTranslate = translate2;
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
        const isH = swiper.isHorizontal();
        if (speed === 0) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
            if (!swiper.support.smoothScroll) {
                animateCSSModeScroll({
                    swiper: swiper,
                    targetPosition: -newTranslate,
                    side: isH ? "left" : "top"
                });
                return true;
            }
            wrapperEl.scrollTo({
                [isH ? "left" : "top"]: -newTranslate,
                behavior: "smooth"
            });
        }
        return true;
    }
    if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionEnd");
        }
    } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionStart");
        }
        if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e2) {
                if (!swiper || swiper.destroyed) return;
                if (e2.target !== this) return;
                swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                swiper.onTranslateToWrapperTransitionEnd = null;
                delete swiper.onTranslateToWrapperTransitionEnd;
                swiper.animating = false;
                if (runCallbacks) swiper.emit("transitionEnd");
            };
            swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
        }
    }
    return true;
}

var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate: setTranslate,
    minTranslate: minTranslate,
    maxTranslate: maxTranslate,
    translateTo: translateTo
};

function setTransition(duration, byController) {
    const swiper = this;
    if (!swiper.params.cssMode) {
        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
        swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
    }
    swiper.emit("setTransition", duration, byController);
}

function transitionEmit(_ref) {
    let {swiper: swiper, runCallbacks: runCallbacks, direction: direction, step: step} = _ref;
    const {activeIndex: activeIndex, previousIndex: previousIndex} = swiper;
    let dir = direction;
    if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
    swiper.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === "reset") {
            swiper.emit(`slideResetTransition${step}`);
            return;
        }
        swiper.emit(`slideChangeTransition${step}`);
        if (dir === "next") swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
    }
}

function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) runCallbacks = true;
    const swiper = this;
    const {params: params} = swiper;
    if (params.cssMode) return;
    if (params.autoHeight) swiper.updateAutoHeight();
    transitionEmit({
        swiper: swiper,
        runCallbacks: runCallbacks,
        direction: direction,
        step: "Start"
    });
}

function transitionEnd(runCallbacks, direction) {
    if (runCallbacks === void 0) runCallbacks = true;
    const swiper = this;
    const {params: params} = swiper;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    transitionEmit({
        swiper: swiper,
        runCallbacks: runCallbacks,
        direction: direction,
        step: "End"
    });
}

var transition = {
    setTransition: setTransition,
    transitionStart: transitionStart,
    transitionEnd: transitionEnd
};

function slideTo(index, speed, runCallbacks, internal, initial) {
    if (index === void 0) index = 0;
    if (runCallbacks === void 0) runCallbacks = true;
    if (typeof index === "string") index = parseInt(index, 10);
    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0) slideIndex = 0;
    const {params: params, snapGrid: snapGrid, slidesGrid: slidesGrid, previousIndex: previousIndex, activeIndex: activeIndex, rtlTranslate: rtl, wrapperEl: wrapperEl, enabled: enabled} = swiper;
    if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) return false;
    if (typeof speed === "undefined") speed = swiper.params.speed;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    const translate2 = -snapGrid[snapIndex];
    if (params.normalizeSlideIndex) for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
        const normalizedTranslate = -Math.floor(translate2 * 100);
        const normalizedGrid = Math.floor(slidesGrid[i2] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i2 + 1] * 100);
        if (typeof slidesGrid[i2 + 1] !== "undefined") {
            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i2; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i2 + 1;
        } else if (normalizedTranslate >= normalizedGrid) slideIndex = i2;
    }
    if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) return false;
        if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
    swiper.updateProgress(translate2);
    let direction;
    if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
    if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {
        swiper.updateActiveIndex(slideIndex);
        if (params.autoHeight) swiper.updateAutoHeight();
        swiper.updateSlidesClasses();
        if (params.effect !== "slide") swiper.setTranslate(translate2);
        if (direction !== "reset") {
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
        }
        return false;
    }
    if (params.cssMode) {
        const isH = swiper.isHorizontal();
        const t2 = rtl ? translate2 : -translate2;
        if (speed === 0) {
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            if (isVirtual) {
                swiper.wrapperEl.style.scrollSnapType = "none";
                swiper._immediateVirtual = true;
            }
            if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                swiper._cssModeVirtualInitialSet = true;
                requestAnimationFrame((() => {
                    wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
                }));
            } else wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
            if (isVirtual) requestAnimationFrame((() => {
                swiper.wrapperEl.style.scrollSnapType = "";
                swiper._immediateVirtual = false;
            }));
        } else {
            if (!swiper.support.smoothScroll) {
                animateCSSModeScroll({
                    swiper: swiper,
                    targetPosition: t2,
                    side: isH ? "left" : "top"
                });
                return true;
            }
            wrapperEl.scrollTo({
                [isH ? "left" : "top"]: t2,
                behavior: "smooth"
            });
        }
        return true;
    }
    swiper.setTransition(speed);
    swiper.setTranslate(translate2);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit("beforeTransitionStart", speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (speed === 0) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e2) {
            if (!swiper || swiper.destroyed) return;
            if (e2.target !== this) return;
            swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
        };
        swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
    }
    return true;
}

function slideToLoop(index, speed, runCallbacks, internal) {
    if (index === void 0) index = 0;
    if (runCallbacks === void 0) runCallbacks = true;
    if (typeof index === "string") {
        const indexAsNumber = parseInt(index, 10);
        index = indexAsNumber;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === "undefined") speed = swiper.params.speed;
    const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
    let newIndex = index;
    if (swiper.params.loop) if (swiper.virtual && swiper.params.virtual.enabled) newIndex += swiper.virtual.slidesBefore; else {
        let targetSlideIndex;
        if (gridEnabled) {
            const slideIndex = newIndex * swiper.params.grid.rows;
            targetSlideIndex = swiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex))[0].column;
        } else targetSlideIndex = swiper.getSlideIndexByData(newIndex);
        const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
        const {centeredSlides: centeredSlides} = swiper.params;
        let slidesPerView = swiper.params.slidesPerView;
        if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
            slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
            if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
        }
        let needLoopFix = cols - targetSlideIndex < slidesPerView;
        if (centeredSlides) needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
        if (internal && centeredSlides && swiper.params.slidesPerView !== "auto" && !gridEnabled) needLoopFix = false;
        if (needLoopFix) {
            const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
            swiper.loopFix({
                direction: direction,
                slideTo: true,
                activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
                slideRealIndex: direction === "next" ? swiper.realIndex : void 0
            });
        }
        if (gridEnabled) {
            const slideIndex = newIndex * swiper.params.grid.rows;
            newIndex = swiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex))[0].column;
        } else newIndex = swiper.getSlideIndexByData(newIndex);
    }
    requestAnimationFrame((() => {
        swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }));
    return swiper;
}

function slideNext(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) runCallbacks = true;
    const swiper = this;
    const {enabled: enabled, params: params, animating: animating} = swiper;
    if (!enabled || swiper.destroyed) return swiper;
    if (typeof speed === "undefined") speed = swiper.params.speed;
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
        if (animating && !isVirtual && params.loopPreventsSliding) return false;
        swiper.loopFix({
            direction: "next"
        });
        swiper._clientLeft = swiper.wrapperEl.clientLeft;
        if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
            requestAnimationFrame((() => {
                swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
            }));
            return true;
        }
    }
    if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

function slidePrev(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) runCallbacks = true;
    const swiper = this;
    const {params: params, snapGrid: snapGrid, slidesGrid: slidesGrid, rtlTranslate: rtlTranslate, enabled: enabled, animating: animating} = swiper;
    if (!enabled || swiper.destroyed) return swiper;
    if (typeof speed === "undefined") speed = swiper.params.speed;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
        if (animating && !isVirtual && params.loopPreventsSliding) return false;
        swiper.loopFix({
            direction: "prev"
        });
        swiper._clientLeft = swiper.wrapperEl.clientLeft;
    }
    const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
    }
    const normalizedTranslate = normalize(translate2);
    const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
        let prevSnapIndex;
        snapGrid.forEach(((snap, snapIndex) => {
            if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
        }));
        if (typeof prevSnapIndex !== "undefined") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
    let prevIndex = 0;
    if (typeof prevSnap !== "undefined") {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
        if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
            prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
            prevIndex = Math.max(prevIndex, 0);
        }
    }
    if (params.rewind && swiper.isBeginning) {
        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
        requestAnimationFrame((() => {
            swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }));
        return true;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

function slideReset(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) runCallbacks = true;
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === "undefined") speed = swiper.params.speed;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (runCallbacks === void 0) runCallbacks = true;
    if (threshold === void 0) threshold = .5;
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === "undefined") speed = swiper.params.speed;
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate2 >= swiper.snapGrid[snapIndex]) {
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];
        if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
    } else {
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];
        if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
    }
    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide() {
    const swiper = this;
    if (swiper.destroyed) return;
    const {params: params, slidesEl: slidesEl} = swiper;
    const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
    if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
        if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
            nextTick((() => {
                swiper.slideTo(slideToIndex);
            }));
        } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
            swiper.loopFix();
            slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
            nextTick((() => {
                swiper.slideTo(slideToIndex);
            }));
        } else swiper.slideTo(slideToIndex);
    } else swiper.slideTo(slideToIndex);
}

var slide = {
    slideTo: slideTo,
    slideToLoop: slideToLoop,
    slideNext: slideNext,
    slidePrev: slidePrev,
    slideReset: slideReset,
    slideToClosest: slideToClosest,
    slideToClickedSlide: slideToClickedSlide
};

function loopCreate(slideRealIndex) {
    const swiper = this;
    const {params: params, slidesEl: slidesEl} = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
    const initSlides = () => {
        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
        slides.forEach(((el, index) => {
            el.setAttribute("data-swiper-slide-index", index);
        }));
    };
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
    const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
    const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
    const addBlankSlides = amountOfSlides => {
        for (let i2 = 0; i2 < amountOfSlides; i2 += 1) {
            const slideEl = swiper.isElement ? createElement("swiper-slide", [ params.slideBlankClass ]) : createElement("div", [ params.slideClass, params.slideBlankClass ]);
            swiper.slidesEl.append(slideEl);
        }
    };
    if (shouldFillGroup) {
        if (params.loopAddBlankSlides) {
            const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
            addBlankSlides(slidesToAdd);
            swiper.recalcSlides();
            swiper.updateSlides();
        } else showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        initSlides();
    } else if (shouldFillGrid) {
        if (params.loopAddBlankSlides) {
            const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
            addBlankSlides(slidesToAdd);
            swiper.recalcSlides();
            swiper.updateSlides();
        } else showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        initSlides();
    } else initSlides();
    swiper.loopFix({
        slideRealIndex: slideRealIndex,
        direction: params.centeredSlides ? void 0 : "next"
    });
}

function loopFix(_temp) {
    let {slideRealIndex: slideRealIndex, slideTo: slideTo2 = true, direction: direction, setTranslate: setTranslate2, activeSlideIndex: activeSlideIndex, byController: byController, byMousewheel: byMousewheel} = _temp === void 0 ? {} : _temp;
    const swiper = this;
    if (!swiper.params.loop) return;
    swiper.emit("beforeLoopFix");
    const {slides: slides, allowSlidePrev: allowSlidePrev, allowSlideNext: allowSlideNext, slidesEl: slidesEl, params: params} = swiper;
    const {centeredSlides: centeredSlides} = params;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    if (swiper.virtual && params.virtual.enabled) {
        if (slideTo2) if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true); else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true); else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        swiper.emit("loopFix");
        return;
    }
    let slidesPerView = params.slidesPerView;
    if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
        slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
    }
    const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
    let loopedSlides = slidesPerGroup;
    if (loopedSlides % slidesPerGroup !== 0) loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
    loopedSlides += params.loopAdditionalSlides;
    swiper.loopedSlides = loopedSlides;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    if (slides.length < slidesPerView + loopedSlides) showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters"); else if (gridEnabled && params.grid.fill === "row") showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    const prependSlidesIndexes = [];
    const appendSlidesIndexes = [];
    let activeIndex = swiper.activeIndex;
    if (typeof activeSlideIndex === "undefined") activeSlideIndex = swiper.getSlideIndex(slides.filter((el => el.classList.contains(params.slideActiveClass)))[0]); else activeIndex = activeSlideIndex;
    const isNext = direction === "next" || !direction;
    const isPrev = direction === "prev" || !direction;
    let slidesPrepended = 0;
    let slidesAppended = 0;
    const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
    const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
    const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate2 === "undefined" ? -slidesPerView / 2 + .5 : 0);
    if (activeColIndexWithShift < loopedSlides) {
        slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
        for (let i2 = 0; i2 < loopedSlides - activeColIndexWithShift; i2 += 1) {
            const index = i2 - Math.floor(i2 / cols) * cols;
            if (gridEnabled) {
                const colIndexToPrepend = cols - index - 1;
                for (let i3 = slides.length - 1; i3 >= 0; i3 -= 1) if (slides[i3].column === colIndexToPrepend) prependSlidesIndexes.push(i3);
            } else prependSlidesIndexes.push(cols - index - 1);
        }
    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
        slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
        for (let i2 = 0; i2 < slidesAppended; i2 += 1) {
            const index = i2 - Math.floor(i2 / cols) * cols;
            if (gridEnabled) slides.forEach(((slide2, slideIndex) => {
                if (slide2.column === index) appendSlidesIndexes.push(slideIndex);
            })); else appendSlidesIndexes.push(index);
        }
    }
    swiper.__preventObserver__ = true;
    requestAnimationFrame((() => {
        swiper.__preventObserver__ = false;
    }));
    if (isPrev) prependSlidesIndexes.forEach((index => {
        slides[index].swiperLoopMoveDOM = true;
        slidesEl.prepend(slides[index]);
        slides[index].swiperLoopMoveDOM = false;
    }));
    if (isNext) appendSlidesIndexes.forEach((index => {
        slides[index].swiperLoopMoveDOM = true;
        slidesEl.append(slides[index]);
        slides[index].swiperLoopMoveDOM = false;
    }));
    swiper.recalcSlides();
    if (params.slidesPerView === "auto") swiper.updateSlides(); else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) swiper.slides.forEach(((slide2, slideIndex) => {
        swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);
    }));
    if (params.watchSlidesProgress) swiper.updateSlidesOffset();
    if (slideTo2) if (prependSlidesIndexes.length > 0 && isPrev) {
        if (typeof slideRealIndex === "undefined") {
            const currentSlideTranslate = swiper.slidesGrid[activeIndex];
            const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
            const diff = newSlideTranslate - currentSlideTranslate;
            if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
                if (setTranslate2) {
                    swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                    swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                }
            }
        } else if (setTranslate2) {
            const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
            swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
            swiper.touchEventsData.currentTranslate = swiper.translate;
        }
    } else if (appendSlidesIndexes.length > 0 && isNext) if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
            swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
            if (setTranslate2) {
                swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
            }
        }
    } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.controller && swiper.controller.control && !byController) {
        const loopParams = {
            slideRealIndex: slideRealIndex,
            direction: direction,
            setTranslate: setTranslate2,
            activeSlideIndex: activeSlideIndex,
            byController: true
        };
        if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c2 => {
            if (!c2.destroyed && c2.params.loop) c2.loopFix({
                ...loopParams,
                slideTo: c2.params.slidesPerView === params.slidesPerView ? slideTo2 : false
            });
        })); else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix({
            ...loopParams,
            slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
        });
    }
    swiper.emit("loopFix");
}

function loopDestroy() {
    const swiper = this;
    const {params: params, slidesEl: slidesEl} = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
    swiper.recalcSlides();
    const newSlidesOrder = [];
    swiper.slides.forEach((slideEl => {
        const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
        newSlidesOrder[index] = slideEl;
    }));
    swiper.slides.forEach((slideEl => {
        slideEl.removeAttribute("data-swiper-slide-index");
    }));
    newSlidesOrder.forEach((slideEl => {
        slidesEl.append(slideEl);
    }));
    swiper.recalcSlides();
    swiper.slideTo(swiper.realIndex, 0);
}

var loop = {
    loopCreate: loopCreate,
    loopFix: loopFix,
    loopDestroy: loopDestroy
};

function setGrabCursor(moving) {
    const swiper = this;
    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
    if (swiper.isElement) swiper.__preventObserver__ = true;
    el.style.cursor = "move";
    el.style.cursor = moving ? "grabbing" : "grab";
    if (swiper.isElement) requestAnimationFrame((() => {
        swiper.__preventObserver__ = false;
    }));
}

function unsetGrabCursor() {
    const swiper = this;
    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    if (swiper.isElement) swiper.__preventObserver__ = true;
    swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
    if (swiper.isElement) requestAnimationFrame((() => {
        swiper.__preventObserver__ = false;
    }));
}

var grabCursor = {
    setGrabCursor: setGrabCursor,
    unsetGrabCursor: unsetGrabCursor
};

function closestElement(selector, base) {
    if (base === void 0) base = this;
    function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        const found = el.closest(selector);
        if (!found && !el.getRootNode) return null;
        return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
}

function preventEdgeSwipe(swiper, event, startX) {
    const window2 = getWindow();
    const {params: params} = swiper;
    const edgeSwipeDetection = params.edgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === "prevent") {
            event.preventDefault();
            return true;
        }
        return false;
    }
    return true;
}

function onTouchStart(event) {
    const swiper = this;
    const document2 = getDocument();
    let e2 = event;
    if (e2.originalEvent) e2 = e2.originalEvent;
    const data = swiper.touchEventsData;
    if (e2.type === "pointerdown") {
        if (data.pointerId !== null && data.pointerId !== e2.pointerId) return;
        data.pointerId = e2.pointerId;
    } else if (e2.type === "touchstart" && e2.targetTouches.length === 1) data.touchId = e2.targetTouches[0].identifier;
    if (e2.type === "touchstart") {
        preventEdgeSwipe(swiper, e2, e2.targetTouches[0].pageX);
        return;
    }
    const {params: params, touches: touches, enabled: enabled} = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && e2.pointerType === "mouse") return;
    if (swiper.animating && params.preventInteractionOnTransition) return;
    if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
    let targetEl = e2.target;
    if (params.touchEventsTarget === "wrapper") if (!swiper.wrapperEl.contains(targetEl)) return;
    if ("which" in e2 && e2.which === 3) return;
    if ("button" in e2 && e2.button > 0) return;
    if (data.isTouched && data.isMoved) return;
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    const eventPath = e2.composedPath ? e2.composedPath() : e2.path;
    if (swipingClassHasValue && e2.target && e2.target.shadowRoot && eventPath) targetEl = eventPath[0];
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e2.target && e2.target.shadowRoot);
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
        swiper.allowClick = true;
        return;
    }
    if (params.swipeHandler) if (!targetEl.closest(params.swipeHandler)) return;
    touches.currentX = e2.pageX;
    touches.currentY = e2.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    if (!preventEdgeSwipe(swiper, e2, startX)) return;
    Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: void 0,
        startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = void 0;
    if (params.threshold > 0) data.allowThresholdMove = false;
    let preventDefault = true;
    if (targetEl.matches(data.focusableElements)) {
        preventDefault = false;
        if (targetEl.nodeName === "SELECT") data.isTouched = false;
    }
    if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl) document2.activeElement.blur();
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e2.preventDefault();
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
    swiper.emit("touchStart", e2);
}

function onTouchMove(event) {
    const document2 = getDocument();
    const swiper = this;
    const data = swiper.touchEventsData;
    const {params: params, touches: touches, rtlTranslate: rtl, enabled: enabled} = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && event.pointerType === "mouse") return;
    let e2 = event;
    if (e2.originalEvent) e2 = e2.originalEvent;
    if (e2.type === "pointermove") {
        if (data.touchId !== null) return;
        const id = e2.pointerId;
        if (id !== data.pointerId) return;
    }
    let targetTouch;
    if (e2.type === "touchmove") {
        targetTouch = [ ...e2.changedTouches ].filter((t2 => t2.identifier === data.touchId))[0];
        if (!targetTouch || targetTouch.identifier !== data.touchId) return;
    } else targetTouch = e2;
    if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e2);
        return;
    }
    const pageX = targetTouch.pageX;
    const pageY = targetTouch.pageY;
    if (e2.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
    }
    if (!swiper.allowTouchMove) {
        if (!e2.target.matches(data.focusableElements)) swiper.allowClick = false;
        if (data.isTouched) {
            Object.assign(touches, {
                startX: pageX,
                startY: pageY,
                currentX: pageX,
                currentY: pageY
            });
            data.touchStartTime = now();
        }
        return;
    }
    if (params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
        }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
    if (document2.activeElement) if (e2.target === document2.activeElement && e2.target.matches(data.focusableElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
    }
    if (data.allowTouchCallbacks) swiper.emit("touchMove", e2);
    touches.previousX = touches.currentX;
    touches.previousY = touches.currentY;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
    if (typeof data.isScrolling === "undefined") {
        let touchAngle;
        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
    }
    if (data.isScrolling) swiper.emit("touchMoveOpposite", e2);
    if (typeof data.startMoving === "undefined") if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
    if (data.isScrolling || e2.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
        data.isTouched = false;
        return;
    }
    if (!data.startMoving) return;
    swiper.allowClick = false;
    if (!params.cssMode && e2.cancelable) e2.preventDefault();
    if (params.touchMoveStopPropagation && !params.nested) e2.stopPropagation();
    let diff = swiper.isHorizontal() ? diffX : diffY;
    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
    if (params.oneWayMovement) {
        diff = Math.abs(diff) * (rtl ? 1 : -1);
        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
    }
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) {
        diff = -diff;
        touchesDiff = -touchesDiff;
    }
    const prevTouchesDirection = swiper.touchesDirection;
    swiper.swipeDirection = diff > 0 ? "prev" : "next";
    swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
    const isLoop = swiper.params.loop && !params.cssMode;
    const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
    if (!data.isMoved) {
        if (isLoop && allowLoopFix) swiper.loopFix({
            direction: swiper.swipeDirection
        });
        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);
        if (swiper.animating) {
            const evt = new window.CustomEvent("transitionend", {
                bubbles: true,
                cancelable: true,
                detail: {
                    bySwiperTouchMove: true
                }
            });
            swiper.wrapperEl.dispatchEvent(evt);
        }
        data.allowMomentumBounce = false;
        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);
        swiper.emit("sliderFirstMove", e2);
    }
    let loopFixed;
     (new Date).getTime();
    if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
        Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY,
            startTranslate: data.currentTranslate
        });
        data.loopSwapReset = true;
        data.startTranslate = data.currentTranslate;
        return;
    }
    swiper.emit("sliderMove", e2);
    data.isMoved = true;
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) resistanceRatio = 0;
    if (diff > 0) {
        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) swiper.loopFix({
            direction: "prev",
            setTranslate: true,
            activeSlideIndex: 0
        });
        if (data.currentTranslate > swiper.minTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
        }
    } else if (diff < 0) {
        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) swiper.loopFix({
            direction: "next",
            setTranslate: true,
            activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
        });
        if (data.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
        }
    }
    if (disableParentSwiper) e2.preventedByNestedSwiper = true;
    if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
    if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
    if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
        }
    } else {
        data.currentTranslate = data.startTranslate;
        return;
    }
    if (!params.followFinger || params.cssMode) return;
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
    swiper.updateProgress(data.currentTranslate);
    swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd(event) {
    const swiper = this;
    const data = swiper.touchEventsData;
    let e2 = event;
    if (e2.originalEvent) e2 = e2.originalEvent;
    let targetTouch;
    const isTouchEvent = e2.type === "touchend" || e2.type === "touchcancel";
    if (!isTouchEvent) {
        if (data.touchId !== null) return;
        if (e2.pointerId !== data.pointerId) return;
        targetTouch = e2;
    } else {
        targetTouch = [ ...e2.changedTouches ].filter((t2 => t2.identifier === data.touchId))[0];
        if (!targetTouch || targetTouch.identifier !== data.touchId) return;
    }
    if ([ "pointercancel", "pointerout", "pointerleave", "contextmenu" ].includes(e2.type)) {
        const proceed = [ "pointercancel", "contextmenu" ].includes(e2.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
        if (!proceed) return;
    }
    data.pointerId = null;
    data.touchId = null;
    const {params: params, touches: touches, rtlTranslate: rtl, slidesGrid: slidesGrid, enabled: enabled} = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && e2.pointerType === "mouse") return;
    if (data.allowTouchCallbacks) swiper.emit("touchEnd", e2);
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);
    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (swiper.allowClick) {
        const pathTree = e2.path || e2.composedPath && e2.composedPath();
        swiper.updateClickedSlide(pathTree && pathTree[0] || e2.target, pathTree);
        swiper.emit("tap click", e2);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e2);
    }
    data.lastClickTime = now();
    nextTick((() => {
        if (!swiper.destroyed) swiper.allowClick = true;
    }));
    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;
    if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
    if (params.cssMode) return;
    if (params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({
            currentPos: currentPos
        });
        return;
    }
    const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for (let i2 = 0; i2 < slidesGrid.length; i2 += i2 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        const increment2 = i2 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i2 + increment2] !== "undefined") {
            if (swipeToLast || currentPos >= slidesGrid[i2] && currentPos < slidesGrid[i2 + increment2]) {
                stopIndex = i2;
                groupSize = slidesGrid[i2 + increment2] - slidesGrid[i2];
            }
        } else if (swipeToLast || currentPos >= slidesGrid[i2]) {
            stopIndex = i2;
            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) if (swiper.isBeginning) rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
        if (!params.longSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        if (swiper.swipeDirection === "next") if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
        if (swiper.swipeDirection === "prev") if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
    } else {
        if (!params.shortSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        const isNavButtonTarget = swiper.navigation && (e2.target === swiper.navigation.nextEl || e2.target === swiper.navigation.prevEl);
        if (!isNavButtonTarget) {
            if (swiper.swipeDirection === "next") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
            if (swiper.swipeDirection === "prev") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        } else if (e2.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
    }
}

function onResize() {
    const swiper = this;
    const {params: params, el: el} = swiper;
    if (el && el.offsetWidth === 0) return;
    if (params.breakpoints) swiper.setBreakpoint();
    const {allowSlideNext: allowSlideNext, allowSlidePrev: allowSlidePrev, snapGrid: snapGrid} = swiper;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    const isVirtualLoop = isVirtual && params.loop;
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        clearTimeout(swiper.autoplay.resizeTimeout);
        swiper.autoplay.resizeTimeout = setTimeout((() => {
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();
        }), 500);
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
}

function onClick(e2) {
    const swiper = this;
    if (!swiper.enabled) return;
    if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e2.preventDefault();
        if (swiper.params.preventClicksPropagation && swiper.animating) {
            e2.stopPropagation();
            e2.stopImmediatePropagation();
        }
    }
}

function onScroll() {
    const swiper = this;
    const {wrapperEl: wrapperEl, rtlTranslate: rtlTranslate, enabled: enabled} = swiper;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
    if (swiper.translate === 0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    swiper.emit("setTranslate", swiper.translate, false);
}

function onLoad(e2) {
    const swiper = this;
    processLazyPreloader(swiper, e2.target);
    if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) return;
    swiper.update();
}

function onDocumentTouchStart() {
    const swiper = this;
    if (swiper.documentTouchHandlerProceeded) return;
    swiper.documentTouchHandlerProceeded = true;
    if (swiper.params.touchReleaseOnEdges) swiper.el.style.touchAction = "auto";
}

const events = (swiper, method) => {
    const document2 = getDocument();
    const {params: params, el: el, wrapperEl: wrapperEl, device: device} = swiper;
    const capture = !!params.nested;
    const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
    const swiperMethod = method;
    if (!el || typeof el === "string") return;
    document2[domMethod]("touchstart", swiper.onDocumentTouchStart, {
        passive: false,
        capture: capture
    });
    el[domMethod]("touchstart", swiper.onTouchStart, {
        passive: false
    });
    el[domMethod]("pointerdown", swiper.onTouchStart, {
        passive: false
    });
    document2[domMethod]("touchmove", swiper.onTouchMove, {
        passive: false,
        capture: capture
    });
    document2[domMethod]("pointermove", swiper.onTouchMove, {
        passive: false,
        capture: capture
    });
    document2[domMethod]("touchend", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("pointerup", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("pointercancel", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("touchcancel", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("pointerout", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("pointerleave", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("contextmenu", swiper.onTouchEnd, {
        passive: true
    });
    if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
    if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
    if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
    el[domMethod]("load", swiper.onLoad, {
        capture: true
    });
};

function attachEvents() {
    const swiper = this;
    const {params: params} = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
    if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
    swiper.onClick = onClick.bind(swiper);
    swiper.onLoad = onLoad.bind(swiper);
    events(swiper, "on");
}

function detachEvents() {
    const swiper = this;
    events(swiper, "off");
}

var events$1 = {
    attachEvents: attachEvents,
    detachEvents: detachEvents
};

const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;

function setBreakpoint() {
    const swiper = this;
    const {realIndex: realIndex, initialized: initialized, params: params, el: el} = swiper;
    const breakpoints2 = params.breakpoints;
    if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0) return;
    const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasGrabCursor = swiper.params.grabCursor;
    const isGrabCursor = breakpointParams.grabCursor;
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
        swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
        el.classList.add(`${params.containerModifierClass}grid`);
        if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") el.classList.add(`${params.containerModifierClass}grid-column`);
        swiper.emitContainerClasses();
    }
    if (wasGrabCursor && !isGrabCursor) swiper.unsetGrabCursor(); else if (!wasGrabCursor && isGrabCursor) swiper.setGrabCursor();
    [ "navigation", "pagination", "scrollbar" ].forEach((prop => {
        if (typeof breakpointParams[prop] === "undefined") return;
        const wasModuleEnabled = params[prop] && params[prop].enabled;
        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
        if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
        if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
    }));
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    const wasLoop = params.loop;
    if (directionChanged && initialized) swiper.changeDirection();
    extend(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    const hasLoop = swiper.params.loop;
    Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (initialized) if (needsReLoop) {
        swiper.loopDestroy();
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
    } else if (!wasLoop && hasLoop) {
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
    } else if (wasLoop && !hasLoop) swiper.loopDestroy();
    swiper.emit("breakpoint", breakpointParams);
}

function getBreakpoint(breakpoints2, base, containerEl) {
    if (base === void 0) base = "window";
    if (!breakpoints2 || base === "container" && !containerEl) return;
    let breakpoint = false;
    const window2 = getWindow();
    const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints2).map((point => {
        if (typeof point === "string" && point.indexOf("@") === 0) {
            const minRatio = parseFloat(point.substr(1));
            const value = currentHeight * minRatio;
            return {
                value: value,
                point: point
            };
        }
        return {
            value: point,
            point: point
        };
    }));
    points.sort(((a2, b2) => parseInt(a2.value, 10) - parseInt(b2.value, 10)));
    for (let i2 = 0; i2 < points.length; i2 += 1) {
        const {point: point, value: value} = points[i2];
        if (base === "window") {
            if (window2.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
        } else if (value <= containerEl.clientWidth) breakpoint = point;
    }
    return breakpoint || "max";
}

var breakpoints = {
    setBreakpoint: setBreakpoint,
    getBreakpoint: getBreakpoint
};

function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach((item => {
        if (typeof item === "object") Object.keys(item).forEach((classNames => {
            if (item[classNames]) resultClasses.push(prefix + classNames);
        })); else if (typeof item === "string") resultClasses.push(prefix + item);
    }));
    return resultClasses;
}

function addClasses() {
    const swiper = this;
    const {classNames: classNames, params: params, rtl: rtl, el: el, device: device} = swiper;
    const suffixes = prepareClasses([ "initialized", params.direction, {
        "free-mode": swiper.params.freeMode && params.freeMode.enabled
    }, {
        autoheight: params.autoHeight
    }, {
        rtl: rtl
    }, {
        grid: params.grid && params.grid.rows > 1
    }, {
        "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
    }, {
        android: device.android
    }, {
        ios: device.ios
    }, {
        "css-mode": params.cssMode
    }, {
        centered: params.cssMode && params.centeredSlides
    }, {
        "watch-progress": params.watchSlidesProgress
    } ], params.containerModifierClass);
    classNames.push(...suffixes);
    el.classList.add(...classNames);
    swiper.emitContainerClasses();
}

function removeClasses() {
    const swiper = this;
    const {el: el, classNames: classNames} = swiper;
    if (!el || typeof el === "string") return;
    el.classList.remove(...classNames);
    swiper.emitContainerClasses();
}

var classes = {
    addClasses: addClasses,
    removeClasses: removeClasses
};

function checkOverflow() {
    const swiper = this;
    const {isLocked: wasLocked, params: params} = swiper;
    const {slidesOffsetBefore: slidesOffsetBefore} = params;
    if (slidesOffsetBefore) {
        const lastSlideIndex = swiper.slides.length - 1;
        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else swiper.isLocked = swiper.snapGrid.length === 1;
    if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;
    if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;
    if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
    if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
}

var checkOverflow$1 = {
    checkOverflow: checkOverflow
};

var defaults = {
    init: true,
    direction: "horizontal",
    oneWayMovement: false,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    eventsPrefix: "swiper",
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 5,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: .85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // loop
    loop: false,
    loopAddBlankSlides: true,
    loopAdditionalSlides: 0,
    loopPreventsSliding: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
};

function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj) {
        if (obj === void 0) obj = {};
        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];
        if (typeof moduleParams !== "object" || moduleParams === null) {
            extend(allModulesParams, obj);
            return;
        }
        if (params[moduleParamName] === true) params[moduleParamName] = {
            enabled: true
        };
        if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) params[moduleParamName].auto = true;
        if ([ "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) params[moduleParamName].auto = true;
        if (!(moduleParamName in params && "enabled" in moduleParams)) {
            extend(allModulesParams, obj);
            return;
        }
        if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
        if (!params[moduleParamName]) params[moduleParamName] = {
            enabled: false
        };
        extend(allModulesParams, obj);
    };
}

const prototypes = {
    eventsEmitter: eventsEmitter,
    update: update,
    translate: translate,
    transition: transition,
    slide: slide,
    loop: loop,
    grabCursor: grabCursor,
    events: events$1,
    breakpoints: breakpoints,
    checkOverflow: checkOverflow$1,
    classes: classes
};

const extendedDefaults = {};

class Swiper {
    constructor() {
        let el;
        let params;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") params = args[0]; else [el, params] = args;
        if (!params) params = {};
        params = extend({}, params);
        if (el && !params.el) params.el = el;
        const document2 = getDocument();
        if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
            const swipers = [];
            document2.querySelectorAll(params.el).forEach((containerEl => {
                const newParams = extend({}, params, {
                    el: containerEl
                });
                swipers.push(new Swiper(newParams));
            }));
            return swipers;
        }
        const swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
            userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = [ ...swiper.__modules__ ];
        if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
        const allModulesParams = {};
        swiper.modules.forEach((mod => {
            mod({
                params: params,
                swiper: swiper,
                extendParams: moduleExtendParams(params, allModulesParams),
                on: swiper.on.bind(swiper),
                once: swiper.once.bind(swiper),
                off: swiper.off.bind(swiper),
                emit: swiper.emit.bind(swiper)
            });
        }));
        const swiperParams = extend({}, defaults, allModulesParams);
        swiper.params = extend({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend({}, swiper.params);
        swiper.passedParams = extend({}, params);
        if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
            swiper.on(eventName, swiper.params.on[eventName]);
        }));
        if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
        Object.assign(swiper, {
            enabled: swiper.params.enabled,
            el: el,
            // Classes
            classNames: [],
            // Slides
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            // isDirection
            isHorizontal() {
                return swiper.params.direction === "horizontal";
            },
            isVertical() {
                return swiper.params.direction === "vertical";
            },
            // Indexes
            activeIndex: 0,
            realIndex: 0,
            isBeginning: true,
            isEnd: false,
            // Props
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: false,
            cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
            },
            // Locks
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev,
            // Touch Events
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                // Form elements to match
                focusableElements: swiper.params.focusableElements,
                // Last click time
                lastClickTime: 0,
                clickTimeout: void 0,
                // Velocities
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            // Clicks
            allowClick: true,
            // Touches
            allowTouchMove: swiper.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            // Images
            imagesToLoad: [],
            imagesLoaded: 0
        });
        swiper.emit("_swiper");
        if (swiper.params.init) swiper.init();
        return swiper;
    }
    getDirectionLabel(property) {
        if (this.isHorizontal()) return property;
        return {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[property];
    }
    getSlideIndex(slideEl) {
        const {slidesEl: slidesEl, params: params} = this;
        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
        const firstSlideIndex = elementIndex(slides[0]);
        return elementIndex(slideEl) - firstSlideIndex;
    }
    getSlideIndexByData(index) {
        return this.getSlideIndex(this.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === index))[0]);
    }
    recalcSlides() {
        const swiper = this;
        const {slidesEl: slidesEl, params: params} = swiper;
        swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    }
    enable() {
        const swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;
        if (swiper.params.grabCursor) swiper.setGrabCursor();
        swiper.emit("enable");
    }
    disable() {
        const swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;
        if (swiper.params.grabCursor) swiper.unsetGrabCursor();
        swiper.emit("disable");
    }
    setProgress(progress, speed) {
        const swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper.minTranslate();
        const max = swiper.maxTranslate();
        const current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    emitContainerClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const cls = swiper.el.className.split(" ").filter((className => className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0));
        swiper.emit("_containerClasses", cls.join(" "));
    }
    getSlideClasses(slideEl) {
        const swiper = this;
        if (swiper.destroyed) return "";
        return slideEl.className.split(" ").filter((className => className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0)).join(" ");
    }
    emitSlidesClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const updates = [];
        swiper.slides.forEach((slideEl => {
            const classNames = swiper.getSlideClasses(slideEl);
            updates.push({
                slideEl: slideEl,
                classNames: classNames
            });
            swiper.emit("_slideClass", slideEl, classNames);
        }));
        swiper.emit("_slideClasses", updates);
    }
    slidesPerViewDynamic(view, exact) {
        if (view === void 0) view = "current";
        if (exact === void 0) exact = false;
        const swiper = this;
        const {params: params, slides: slides, slidesGrid: slidesGrid, slidesSizesGrid: slidesSizesGrid, size: swiperSize, activeIndex: activeIndex} = swiper;
        let spv = 1;
        if (typeof params.slidesPerView === "number") return params.slidesPerView;
        if (params.centeredSlides) {
            let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
            let breakLoop;
            for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) if (slides[i2] && !breakLoop) {
                slideSize += Math.ceil(slides[i2].swiperSlideSize);
                spv += 1;
                if (slideSize > swiperSize) breakLoop = true;
            }
            for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) if (slides[i2] && !breakLoop) {
                slideSize += slides[i2].swiperSlideSize;
                spv += 1;
                if (slideSize > swiperSize) breakLoop = true;
            }
        } else if (view === "current") for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
            const slideInView = exact ? slidesGrid[i2] + slidesSizesGrid[i2] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i2] - slidesGrid[activeIndex] < swiperSize;
            if (slideInView) spv += 1;
        } else for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i2] < swiperSize;
            if (slideInView) spv += 1;
        }
        return spv;
    }
    update() {
        const swiper = this;
        if (!swiper || swiper.destroyed) return;
        const {snapGrid: snapGrid, params: params} = swiper;
        if (params.breakpoints) swiper.setBreakpoint();
        [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
            if (imageEl.complete) processLazyPreloader(swiper, imageEl);
        }));
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();
        function setTranslate2() {
            const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
            const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        let translated;
        if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
            setTranslate2();
            if (params.autoHeight) swiper.updateAutoHeight();
        } else {
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                translated = swiper.slideTo(slides.length - 1, 0, false, true);
            } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (!translated) setTranslate2();
        }
        if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        swiper.emit("update");
    }
    changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) needUpdate = true;
        const swiper = this;
        const currentDirection = swiper.params.direction;
        if (!newDirection) newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
        if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") return swiper;
        swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
        swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.forEach((slideEl => {
            if (newDirection === "vertical") slideEl.style.width = ""; else slideEl.style.height = "";
        }));
        swiper.emit("changeDirection");
        if (needUpdate) swiper.update();
        return swiper;
    }
    changeLanguageDirection(direction) {
        const swiper = this;
        if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
        swiper.rtl = direction === "rtl";
        swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
        if (swiper.rtl) {
            swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
            swiper.el.dir = "rtl";
        } else {
            swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
            swiper.el.dir = "ltr";
        }
        swiper.update();
    }
    mount(element) {
        const swiper = this;
        if (swiper.mounted) return true;
        let el = element || swiper.params.el;
        if (typeof el === "string") el = document.querySelector(el);
        if (!el) return false;
        el.swiper = swiper;
        if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) swiper.isElement = true;
        const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
        const getWrapper = () => {
            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                const res = el.shadowRoot.querySelector(getWrapperSelector());
                return res;
            }
            return elementChildren(el, getWrapperSelector())[0];
        };
        let wrapperEl = getWrapper();
        if (!wrapperEl && swiper.params.createElements) {
            wrapperEl = createElement("div", swiper.params.wrapperClass);
            el.append(wrapperEl);
            elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl => {
                wrapperEl.append(slideEl);
            }));
        }
        Object.assign(swiper, {
            el: el,
            wrapperEl: wrapperEl,
            slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
            hostEl: swiper.isElement ? el.parentNode.host : el,
            mounted: true,
            // RTL
            rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
            rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
            wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
        });
        return true;
    }
    init(el) {
        const swiper = this;
        if (swiper.initialized) return swiper;
        const mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit("beforeInit");
        if (swiper.params.breakpoints) swiper.setBreakpoint();
        swiper.addClasses();
        swiper.updateSize();
        swiper.updateSlides();
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        if (swiper.params.loop) swiper.loopCreate();
        swiper.attachEvents();
        const lazyElements = [ ...swiper.el.querySelectorAll('[loading="lazy"]') ];
        if (swiper.isElement) lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
        lazyElements.forEach((imageEl => {
            if (imageEl.complete) processLazyPreloader(swiper, imageEl); else imageEl.addEventListener("load", (e2 => {
                processLazyPreloader(swiper, e2.target);
            }));
        }));
        preload(swiper);
        swiper.initialized = true;
        preload(swiper);
        swiper.emit("init");
        swiper.emit("afterInit");
        return swiper;
    }
    destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) deleteInstance = true;
        if (cleanStyles === void 0) cleanStyles = true;
        const swiper = this;
        const {params: params, el: el, wrapperEl: wrapperEl, slides: slides} = swiper;
        if (typeof swiper.params === "undefined" || swiper.destroyed) return null;
        swiper.emit("beforeDestroy");
        swiper.initialized = false;
        swiper.detachEvents();
        if (params.loop) swiper.loopDestroy();
        if (cleanStyles) {
            swiper.removeClasses();
            if (el && typeof el !== "string") el.removeAttribute("style");
            if (wrapperEl) wrapperEl.removeAttribute("style");
            if (slides && slides.length) slides.forEach((slideEl => {
                slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                slideEl.removeAttribute("style");
                slideEl.removeAttribute("data-swiper-slide-index");
            }));
        }
        swiper.emit("destroy");
        Object.keys(swiper.eventsListeners).forEach((eventName => {
            swiper.off(eventName);
        }));
        if (deleteInstance !== false) {
            if (swiper.el && typeof swiper.el !== "string") swiper.el.swiper = null;
            deleteProps(swiper);
        }
        swiper.destroyed = true;
        return null;
    }
    static extendDefaults(newDefaults) {
        extend(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
        return extendedDefaults;
    }
    static get defaults() {
        return defaults;
    }
    static installModule(mod) {
        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
        const modules = Swiper.prototype.__modules__;
        if (typeof mod === "function" && modules.indexOf(mod) < 0) modules.push(mod);
    }
    static use(module) {
        if (Array.isArray(module)) {
            module.forEach((m2 => Swiper.installModule(m2)));
            return Swiper;
        }
        Swiper.installModule(module);
        return Swiper;
    }
}

Object.keys(prototypes).forEach((prototypeGroup => {
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    }));
}));

Swiper.use([ Resize, Observer ]);

function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
    if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {
        if (!params[key] && params.auto === true) {
            let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
            if (!element) {
                element = createElement("div", checkProps[key]);
                element.className = checkProps[key];
                swiper.el.append(element);
            }
            params[key] = element;
            originalParams[key] = element;
        }
    }));
    return params;
}

function Navigation(_ref) {
    let {swiper: swiper, extendParams: extendParams, on: on, emit: emit} = _ref;
    extendParams({
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: false,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled"
        }
    });
    swiper.navigation = {
        nextEl: null,
        prevEl: null
    };
    function getEl(el) {
        let res;
        if (el && typeof el === "string" && swiper.isElement) {
            res = swiper.el.querySelector(el);
            if (res) return res;
        }
        if (el) {
            if (typeof el === "string") res = [ ...document.querySelectorAll(el) ];
            if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) res = swiper.el.querySelector(el); else if (res && res.length === 1) res = res[0];
        }
        if (el && !res) return el;
        return res;
    }
    function toggleEl(el, disabled) {
        const params = swiper.params.navigation;
        el = makeElementsArray(el);
        el.forEach((subEl => {
            if (subEl) {
                subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
                if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
                if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
            }
        }));
    }
    function update2() {
        const {nextEl: nextEl, prevEl: prevEl} = swiper.navigation;
        if (swiper.params.loop) {
            toggleEl(prevEl, false);
            toggleEl(nextEl, false);
            return;
        }
        toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
        toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
    }
    function onPrevClick(e2) {
        e2.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slidePrev();
        emit("navigationPrev");
    }
    function onNextClick(e2) {
        e2.preventDefault();
        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slideNext();
        emit("navigationNext");
    }
    function init() {
        const params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
            nextEl: "swiper-button-next",
            prevEl: "swiper-button-prev"
        });
        if (!(params.nextEl || params.prevEl)) return;
        let nextEl = getEl(params.nextEl);
        let prevEl = getEl(params.prevEl);
        Object.assign(swiper.navigation, {
            nextEl: nextEl,
            prevEl: prevEl
        });
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        const initButton = (el, dir) => {
            if (el) el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
            if (!swiper.enabled && el) el.classList.add(...params.lockClass.split(" "));
        };
        nextEl.forEach((el => initButton(el, "next")));
        prevEl.forEach((el => initButton(el, "prev")));
    }
    function destroy() {
        let {nextEl: nextEl, prevEl: prevEl} = swiper.navigation;
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        const destroyButton = (el, dir) => {
            el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
            el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
        };
        nextEl.forEach((el => destroyButton(el, "next")));
        prevEl.forEach((el => destroyButton(el, "prev")));
    }
    on("init", (() => {
        if (swiper.params.navigation.enabled === false) disable(); else {
            init();
            update2();
        }
    }));
    on("toEdge fromEdge lock unlock", (() => {
        update2();
    }));
    on("destroy", (() => {
        destroy();
    }));
    on("enable disable", (() => {
        let {nextEl: nextEl, prevEl: prevEl} = swiper.navigation;
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        if (swiper.enabled) {
            update2();
            return;
        }
        [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.add(swiper.params.navigation.lockClass)));
    }));
    on("click", ((_s, e2) => {
        let {nextEl: nextEl, prevEl: prevEl} = swiper.navigation;
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        const targetEl = e2.target;
        let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
        if (swiper.isElement && !targetIsButton) {
            const path = e2.path || e2.composedPath && e2.composedPath();
            if (path) targetIsButton = path.find((pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl)));
        }
        if (swiper.params.navigation.hideOnClick && !targetIsButton) {
            if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
            let isHidden;
            if (nextEl.length) isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass); else if (prevEl.length) isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
            if (isHidden === true) emit("navigationShow"); else emit("navigationHide");
            [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.toggle(swiper.params.navigation.hiddenClass)));
        }
    }));
    const enable = () => {
        swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
        init();
        update2();
    };
    const disable = () => {
        swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
        destroy();
    };
    Object.assign(swiper.navigation, {
        enable: enable,
        disable: disable,
        update: update2,
        init: init,
        destroy: destroy
    });
}

function classesToSelector(classes2) {
    if (classes2 === void 0) classes2 = "";
    return `.${classes2.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
}

function Pagination(_ref) {
    let {swiper: swiper, extendParams: extendParams, on: on, emit: emit} = _ref;
    const pfx = "swiper-pagination";
    extendParams({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: false,
            hideOnClick: false,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: false,
            type: "bullets",
            // 'bullets' or 'progressbar' or 'fraction' or 'custom'
            dynamicBullets: false,
            dynamicMainBullets: 1,
            formatFractionCurrent: number => number,
            formatFractionTotal: number => number,
            bulletClass: `${pfx}-bullet`,
            bulletActiveClass: `${pfx}-bullet-active`,
            modifierClass: `${pfx}-`,
            currentClass: `${pfx}-current`,
            totalClass: `${pfx}-total`,
            hiddenClass: `${pfx}-hidden`,
            progressbarFillClass: `${pfx}-progressbar-fill`,
            progressbarOppositeClass: `${pfx}-progressbar-opposite`,
            clickableClass: `${pfx}-clickable`,
            lockClass: `${pfx}-lock`,
            horizontalClass: `${pfx}-horizontal`,
            verticalClass: `${pfx}-vertical`,
            paginationDisabledClass: `${pfx}-disabled`
        }
    });
    swiper.pagination = {
        el: null,
        bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;
    function isPaginationDisabled() {
        return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
    }
    function setSideBullets(bulletEl, position) {
        const {bulletActiveClass: bulletActiveClass} = swiper.params.pagination;
        if (!bulletEl) return;
        bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
        if (bulletEl) {
            bulletEl.classList.add(`${bulletActiveClass}-${position}`);
            bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
            if (bulletEl) bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
        }
    }
    function onBulletClick(e2) {
        const bulletEl = e2.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
        if (!bulletEl) return;
        e2.preventDefault();
        const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
        if (swiper.params.loop) {
            if (swiper.realIndex === index) return;
            swiper.slideToLoop(index);
        } else swiper.slideTo(index);
    }
    function update2() {
        const rtl = swiper.rtl;
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        let el = swiper.pagination.el;
        el = makeElementsArray(el);
        let current;
        let previousIndex;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.loop) {
            previousIndex = swiper.previousRealIndex || 0;
            current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
        } else if (typeof swiper.snapIndex !== "undefined") {
            current = swiper.snapIndex;
            previousIndex = swiper.previousSnapIndex;
        } else {
            previousIndex = swiper.previousIndex || 0;
            current = swiper.activeIndex || 0;
        }
        if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
            const bullets = swiper.pagination.bullets;
            let firstIndex;
            let lastIndex;
            let midIndex;
            if (params.dynamicBullets) {
                bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height");
                el.forEach((subEl => {
                    subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
                }));
                if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
                    dynamicBulletIndex += current - (previousIndex || 0);
                    if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1; else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;
                }
                firstIndex = Math.max(current - dynamicBulletIndex, 0);
                lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                midIndex = (lastIndex + firstIndex) / 2;
            }
            bullets.forEach((bulletEl => {
                const classesToRemove = [ ...[ "", "-next", "-next-next", "-prev", "-prev-prev", "-main" ].map((suffix => `${params.bulletActiveClass}${suffix}`)) ].map((s2 => typeof s2 === "string" && s2.includes(" ") ? s2.split(" ") : s2)).flat();
                bulletEl.classList.remove(...classesToRemove);
            }));
            if (el.length > 1) bullets.forEach((bullet => {
                const bulletIndex = elementIndex(bullet);
                if (bulletIndex === current) bullet.classList.add(...params.bulletActiveClass.split(" ")); else if (swiper.isElement) bullet.setAttribute("part", "bullet");
                if (params.dynamicBullets) {
                    if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                    if (bulletIndex === firstIndex) setSideBullets(bullet, "prev");
                    if (bulletIndex === lastIndex) setSideBullets(bullet, "next");
                }
            })); else {
                const bullet = bullets[current];
                if (bullet) bullet.classList.add(...params.bulletActiveClass.split(" "));
                if (swiper.isElement) bullets.forEach(((bulletEl, bulletIndex) => {
                    bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
                }));
                if (params.dynamicBullets) {
                    const firstDisplayedBullet = bullets[firstIndex];
                    const lastDisplayedBullet = bullets[lastIndex];
                    for (let i2 = firstIndex; i2 <= lastIndex; i2 += 1) if (bullets[i2]) bullets[i2].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                    setSideBullets(firstDisplayedBullet, "prev");
                    setSideBullets(lastDisplayedBullet, "next");
                }
            }
            if (params.dynamicBullets) {
                const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                const offsetProp = rtl ? "right" : "left";
                bullets.forEach((bullet => {
                    bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
                }));
            }
        }
        el.forEach(((subEl, subElIndex) => {
            if (params.type === "fraction") {
                subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl => {
                    fractionEl.textContent = params.formatFractionCurrent(current + 1);
                }));
                subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl => {
                    totalEl.textContent = params.formatFractionTotal(total);
                }));
            }
            if (params.type === "progressbar") {
                let progressbarDirection;
                if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal"; else progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
                const scale = (current + 1) / total;
                let scaleX = 1;
                let scaleY = 1;
                if (progressbarDirection === "horizontal") scaleX = scale; else scaleY = scale;
                subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl => {
                    progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                    progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
                }));
            }
            if (params.type === "custom" && params.renderCustom) {
                subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
                if (subElIndex === 0) emit("paginationRender", subEl);
            } else {
                if (subElIndex === 0) emit("paginationRender", subEl);
                emit("paginationUpdate", subEl);
            }
            if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
        }));
    }
    function render() {
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
        let el = swiper.pagination.el;
        el = makeElementsArray(el);
        let paginationHTML = "";
        if (params.type === "bullets") {
            let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) numberOfBullets = slidesLength;
            for (let i2 = 0; i2 < numberOfBullets; i2 += 1) if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i2, params.bulletClass); else paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
        if (params.type === "fraction") if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass); else paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
        if (params.type === "progressbar") if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass); else paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        swiper.pagination.bullets = [];
        el.forEach((subEl => {
            if (params.type !== "custom") subEl.innerHTML = paginationHTML || "";
            if (params.type === "bullets") swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
        }));
        if (params.type !== "custom") emit("paginationRender", el[0]);
    }
    function init() {
        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
            el: "swiper-pagination"
        });
        const params = swiper.params.pagination;
        if (!params.el) return;
        let el;
        if (typeof params.el === "string" && swiper.isElement) el = swiper.el.querySelector(params.el);
        if (!el && typeof params.el === "string") el = [ ...document.querySelectorAll(params.el) ];
        if (!el) el = params.el;
        if (!el || el.length === 0) return;
        if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
            el = [ ...swiper.el.querySelectorAll(params.el) ];
            if (el.length > 1) el = el.filter((subEl => {
                if (elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
                return true;
            }))[0];
        }
        if (Array.isArray(el) && el.length === 1) el = el[0];
        Object.assign(swiper.pagination, {
            el: el
        });
        el = makeElementsArray(el);
        el.forEach((subEl => {
            if (params.type === "bullets" && params.clickable) subEl.classList.add(...(params.clickableClass || "").split(" "));
            subEl.classList.add(params.modifierClass + params.type);
            subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            if (params.type === "bullets" && params.dynamicBullets) {
                subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
                dynamicBulletIndex = 0;
                if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;
            }
            if (params.type === "progressbar" && params.progressbarOpposite) subEl.classList.add(params.progressbarOppositeClass);
            if (params.clickable) subEl.addEventListener("click", onBulletClick);
            if (!swiper.enabled) subEl.classList.add(params.lockClass);
        }));
    }
    function destroy() {
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        let el = swiper.pagination.el;
        if (el) {
            el = makeElementsArray(el);
            el.forEach((subEl => {
                subEl.classList.remove(params.hiddenClass);
                subEl.classList.remove(params.modifierClass + params.type);
                subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                if (params.clickable) {
                    subEl.classList.remove(...(params.clickableClass || "").split(" "));
                    subEl.removeEventListener("click", onBulletClick);
                }
            }));
        }
        if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl => subEl.classList.remove(...params.bulletActiveClass.split(" "))));
    }
    on("changeDirection", (() => {
        if (!swiper.pagination || !swiper.pagination.el) return;
        const params = swiper.params.pagination;
        let {el: el} = swiper.pagination;
        el = makeElementsArray(el);
        el.forEach((subEl => {
            subEl.classList.remove(params.horizontalClass, params.verticalClass);
            subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        }));
    }));
    on("init", (() => {
        if (swiper.params.pagination.enabled === false) disable(); else {
            init();
            render();
            update2();
        }
    }));
    on("activeIndexChange", (() => {
        if (typeof swiper.snapIndex === "undefined") update2();
    }));
    on("snapIndexChange", (() => {
        update2();
    }));
    on("snapGridLengthChange", (() => {
        render();
        update2();
    }));
    on("destroy", (() => {
        destroy();
    }));
    on("enable disable", (() => {
        let {el: el} = swiper.pagination;
        if (el) {
            el = makeElementsArray(el);
            el.forEach((subEl => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass)));
        }
    }));
    on("lock unlock", (() => {
        update2();
    }));
    on("click", ((_s, e2) => {
        const targetEl = e2.target;
        const el = makeElementsArray(swiper.pagination.el);
        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
            if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
            const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
            if (isHidden === true) emit("paginationShow"); else emit("paginationHide");
            el.forEach((subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass)));
        }
    }));
    const enable = () => {
        swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
        let {el: el} = swiper.pagination;
        if (el) {
            el = makeElementsArray(el);
            el.forEach((subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass)));
        }
        init();
        render();
        update2();
    };
    const disable = () => {
        swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
        let {el: el} = swiper.pagination;
        if (el) {
            el = makeElementsArray(el);
            el.forEach((subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass)));
        }
        destroy();
    };
    Object.assign(swiper.pagination, {
        enable: enable,
        disable: disable,
        render: render,
        update: update2,
        init: init,
        destroy: destroy
    });
}

function Scrollbar(_ref) {
    let {swiper: swiper, extendParams: extendParams, on: on, emit: emit} = _ref;
    const document2 = getDocument();
    let isTouched = false;
    let timeout = null;
    let dragTimeout = null;
    let dragStartPos;
    let dragSize;
    let trackSize;
    let divider;
    extendParams({
        scrollbar: {
            el: null,
            dragSize: "auto",
            hide: false,
            draggable: false,
            snapOnRelease: true,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
            scrollbarDisabledClass: "swiper-scrollbar-disabled",
            horizontalClass: `swiper-scrollbar-horizontal`,
            verticalClass: `swiper-scrollbar-vertical`
        }
    });
    swiper.scrollbar = {
        el: null,
        dragEl: null
    };
    function setTranslate2() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {scrollbar: scrollbar, rtlTranslate: rtl} = swiper;
        const {dragEl: dragEl, el: el} = scrollbar;
        const params = swiper.params.scrollbar;
        const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
        let newSize = dragSize;
        let newPos = (trackSize - dragSize) * progress;
        if (rtl) {
            newPos = -newPos;
            if (newPos > 0) {
                newSize = dragSize - newPos;
                newPos = 0;
            } else if (-newPos + dragSize > trackSize) newSize = trackSize + newPos;
        } else if (newPos < 0) {
            newSize = dragSize + newPos;
            newPos = 0;
        } else if (newPos + dragSize > trackSize) newSize = trackSize - newPos;
        if (swiper.isHorizontal()) {
            dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
            dragEl.style.width = `${newSize}px`;
        } else {
            dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
            dragEl.style.height = `${newSize}px`;
        }
        if (params.hide) {
            clearTimeout(timeout);
            el.style.opacity = 1;
            timeout = setTimeout((() => {
                el.style.opacity = 0;
                el.style.transitionDuration = "400ms";
            }), 1e3);
        }
    }
    function setTransition2(duration) {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
    }
    function updateSize2() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {scrollbar: scrollbar} = swiper;
        const {dragEl: dragEl, el: el} = scrollbar;
        dragEl.style.width = "";
        dragEl.style.height = "";
        trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
        if (swiper.params.scrollbar.dragSize === "auto") dragSize = trackSize * divider; else dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        if (swiper.isHorizontal()) dragEl.style.width = `${dragSize}px`; else dragEl.style.height = `${dragSize}px`;
        if (divider >= 1) el.style.display = "none"; else el.style.display = "";
        if (swiper.params.scrollbar.hide) el.style.opacity = 0;
        if (swiper.params.watchOverflow && swiper.enabled) scrollbar.el.classList[swiper.isLocked ? "add" : "remove"](swiper.params.scrollbar.lockClass);
    }
    function getPointerPosition(e2) {
        return swiper.isHorizontal() ? e2.clientX : e2.clientY;
    }
    function setDragPosition(e2) {
        const {scrollbar: scrollbar, rtlTranslate: rtl} = swiper;
        const {el: el} = scrollbar;
        let positionRatio;
        positionRatio = (getPointerPosition(e2) - elementOffset(el)[swiper.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);
        if (rtl) positionRatio = 1 - positionRatio;
        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    function onDragStart(e2) {
        const params = swiper.params.scrollbar;
        const {scrollbar: scrollbar, wrapperEl: wrapperEl} = swiper;
        const {el: el, dragEl: dragEl} = scrollbar;
        isTouched = true;
        dragStartPos = e2.target === dragEl ? getPointerPosition(e2) - e2.target.getBoundingClientRect()[swiper.isHorizontal() ? "left" : "top"] : null;
        e2.preventDefault();
        e2.stopPropagation();
        wrapperEl.style.transitionDuration = "100ms";
        dragEl.style.transitionDuration = "100ms";
        setDragPosition(e2);
        clearTimeout(dragTimeout);
        el.style.transitionDuration = "0ms";
        if (params.hide) el.style.opacity = 1;
        if (swiper.params.cssMode) swiper.wrapperEl.style["scroll-snap-type"] = "none";
        emit("scrollbarDragStart", e2);
    }
    function onDragMove(e2) {
        const {scrollbar: scrollbar, wrapperEl: wrapperEl} = swiper;
        const {el: el, dragEl: dragEl} = scrollbar;
        if (!isTouched) return;
        if (e2.preventDefault && e2.cancelable) e2.preventDefault(); else e2.returnValue = false;
        setDragPosition(e2);
        wrapperEl.style.transitionDuration = "0ms";
        el.style.transitionDuration = "0ms";
        dragEl.style.transitionDuration = "0ms";
        emit("scrollbarDragMove", e2);
    }
    function onDragEnd(e2) {
        const params = swiper.params.scrollbar;
        const {scrollbar: scrollbar, wrapperEl: wrapperEl} = swiper;
        const {el: el} = scrollbar;
        if (!isTouched) return;
        isTouched = false;
        if (swiper.params.cssMode) {
            swiper.wrapperEl.style["scroll-snap-type"] = "";
            wrapperEl.style.transitionDuration = "";
        }
        if (params.hide) {
            clearTimeout(dragTimeout);
            dragTimeout = nextTick((() => {
                el.style.opacity = 0;
                el.style.transitionDuration = "400ms";
            }), 1e3);
        }
        emit("scrollbarDragEnd", e2);
        if (params.snapOnRelease) swiper.slideToClosest();
    }
    function events2(method) {
        const {scrollbar: scrollbar, params: params} = swiper;
        const el = scrollbar.el;
        if (!el) return;
        const target = el;
        const activeListener = params.passiveListeners ? {
            passive: false,
            capture: false
        } : false;
        const passiveListener = params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        if (!target) return;
        const eventMethod = method === "on" ? "addEventListener" : "removeEventListener";
        target[eventMethod]("pointerdown", onDragStart, activeListener);
        document2[eventMethod]("pointermove", onDragMove, activeListener);
        document2[eventMethod]("pointerup", onDragEnd, passiveListener);
    }
    function enableDraggable() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        events2("on");
    }
    function disableDraggable() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        events2("off");
    }
    function init() {
        const {scrollbar: scrollbar, el: swiperEl} = swiper;
        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
            el: "swiper-scrollbar"
        });
        const params = swiper.params.scrollbar;
        if (!params.el) return;
        let el;
        if (typeof params.el === "string" && swiper.isElement) el = swiper.el.querySelector(params.el);
        if (!el && typeof params.el === "string") {
            el = document2.querySelectorAll(params.el);
            if (!el.length) return;
        } else if (!el) el = params.el;
        if (swiper.params.uniqueNavElements && typeof params.el === "string" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) el = swiperEl.querySelector(params.el);
        if (el.length > 0) el = el[0];
        el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        let dragEl;
        if (el) {
            dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));
            if (!dragEl) {
                dragEl = createElement("div", swiper.params.scrollbar.dragClass);
                el.append(dragEl);
            }
        }
        Object.assign(scrollbar, {
            el: el,
            dragEl: dragEl
        });
        if (params.draggable) enableDraggable();
        if (el) el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass));
    }
    function destroy() {
        const params = swiper.params.scrollbar;
        const el = swiper.scrollbar.el;
        if (el) el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));
        disableDraggable();
    }
    on("changeDirection", (() => {
        if (!swiper.scrollbar || !swiper.scrollbar.el) return;
        const params = swiper.params.scrollbar;
        let {el: el} = swiper.scrollbar;
        el = makeElementsArray(el);
        el.forEach((subEl => {
            subEl.classList.remove(params.horizontalClass, params.verticalClass);
            subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        }));
    }));
    on("init", (() => {
        if (swiper.params.scrollbar.enabled === false) disable(); else {
            init();
            updateSize2();
            setTranslate2();
        }
    }));
    on("update resize observerUpdate lock unlock changeDirection", (() => {
        updateSize2();
    }));
    on("setTranslate", (() => {
        setTranslate2();
    }));
    on("setTransition", ((_s, duration) => {
        setTransition2(duration);
    }));
    on("enable disable", (() => {
        const {el: el} = swiper.scrollbar;
        if (el) el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass));
    }));
    on("destroy", (() => {
        destroy();
    }));
    const enable = () => {
        swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
        if (swiper.scrollbar.el) swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
        init();
        updateSize2();
        setTranslate2();
    };
    const disable = () => {
        swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
        if (swiper.scrollbar.el) swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
        destroy();
    };
    Object.assign(swiper.scrollbar, {
        enable: enable,
        disable: disable,
        updateSize: updateSize2,
        setTranslate: setTranslate2,
        init: init,
        destroy: destroy
    });
}

function Autoplay(_ref) {
    let {swiper: swiper, extendParams: extendParams, on: on, emit: emit, params: params} = _ref;
    swiper.autoplay = {
        running: false,
        paused: false,
        timeLeft: 0
    };
    extendParams({
        autoplay: {
            enabled: false,
            delay: 3e3,
            waitForTransition: true,
            disableOnInteraction: false,
            stopOnLastSlide: false,
            reverseDirection: false,
            pauseOnMouseEnter: false
        }
    });
    let timeout;
    let raf;
    let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
    let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
    let autoplayTimeLeft;
    let autoplayStartTime =  (new Date).getTime();
    let wasPaused;
    let isTouched;
    let pausedByTouch;
    let touchStartTimeout;
    let slideChanged;
    let pausedByInteraction;
    let pausedByPointerEnter;
    function onTransitionEnd(e2) {
        if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
        if (e2.target !== swiper.wrapperEl) return;
        swiper.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
        if (pausedByPointerEnter || e2.detail && e2.detail.bySwiperTouchMove) return;
        resume();
    }
    const calcTimeLeft = () => {
        if (swiper.destroyed || !swiper.autoplay.running) return;
        if (swiper.autoplay.paused) wasPaused = true; else if (wasPaused) {
            autoplayDelayCurrent = autoplayTimeLeft;
            wasPaused = false;
        }
        const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent -  (new Date).getTime();
        swiper.autoplay.timeLeft = timeLeft;
        emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
        raf = requestAnimationFrame((() => {
            calcTimeLeft();
        }));
    };
    const getSlideDelay = () => {
        let activeSlideEl;
        if (swiper.virtual && swiper.params.virtual.enabled) activeSlideEl = swiper.slides.filter((slideEl => slideEl.classList.contains("swiper-slide-active")))[0]; else activeSlideEl = swiper.slides[swiper.activeIndex];
        if (!activeSlideEl) return;
        const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
        return currentSlideDelay;
    };
    const run = delayForce => {
        if (swiper.destroyed || !swiper.autoplay.running) return;
        cancelAnimationFrame(raf);
        calcTimeLeft();
        let delay = typeof delayForce === "undefined" ? swiper.params.autoplay.delay : delayForce;
        autoplayDelayTotal = swiper.params.autoplay.delay;
        autoplayDelayCurrent = swiper.params.autoplay.delay;
        const currentSlideDelay = getSlideDelay();
        if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
            delay = currentSlideDelay;
            autoplayDelayTotal = currentSlideDelay;
            autoplayDelayCurrent = currentSlideDelay;
        }
        autoplayTimeLeft = delay;
        const speed = swiper.params.speed;
        const proceed = () => {
            if (!swiper || swiper.destroyed) return;
            if (swiper.params.autoplay.reverseDirection) {
                if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
                    swiper.slidePrev(speed, true, true);
                    emit("autoplay");
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    swiper.slideTo(swiper.slides.length - 1, speed, true, true);
                    emit("autoplay");
                }
            } else if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
                swiper.slideNext(speed, true, true);
                emit("autoplay");
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
                swiper.slideTo(0, speed, true, true);
                emit("autoplay");
            }
            if (swiper.params.cssMode) {
                autoplayStartTime =  (new Date).getTime();
                requestAnimationFrame((() => {
                    run();
                }));
            }
        };
        if (delay > 0) {
            clearTimeout(timeout);
            timeout = setTimeout((() => {
                proceed();
            }), delay);
        } else requestAnimationFrame((() => {
            proceed();
        }));
        return delay;
    };
    const start = () => {
        autoplayStartTime =  (new Date).getTime();
        swiper.autoplay.running = true;
        run();
        emit("autoplayStart");
    };
    const stop = () => {
        swiper.autoplay.running = false;
        clearTimeout(timeout);
        cancelAnimationFrame(raf);
        emit("autoplayStop");
    };
    const pause = (internal, reset) => {
        if (swiper.destroyed || !swiper.autoplay.running) return;
        clearTimeout(timeout);
        if (!internal) pausedByInteraction = true;
        const proceed = () => {
            emit("autoplayPause");
            if (swiper.params.autoplay.waitForTransition) swiper.wrapperEl.addEventListener("transitionend", onTransitionEnd); else resume();
        };
        swiper.autoplay.paused = true;
        if (reset) {
            if (slideChanged) autoplayTimeLeft = swiper.params.autoplay.delay;
            slideChanged = false;
            proceed();
            return;
        }
        const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
        autoplayTimeLeft = delay - ( (new Date).getTime() - autoplayStartTime);
        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
        if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
        proceed();
    };
    const resume = () => {
        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
        autoplayStartTime =  (new Date).getTime();
        if (pausedByInteraction) {
            pausedByInteraction = false;
            run(autoplayTimeLeft);
        } else run();
        swiper.autoplay.paused = false;
        emit("autoplayResume");
    };
    const onVisibilityChange = () => {
        if (swiper.destroyed || !swiper.autoplay.running) return;
        const document2 = getDocument();
        if (document2.visibilityState === "hidden") {
            pausedByInteraction = true;
            pause(true);
        }
        if (document2.visibilityState === "visible") resume();
    };
    const onPointerEnter = e2 => {
        if (e2.pointerType !== "mouse") return;
        pausedByInteraction = true;
        pausedByPointerEnter = true;
        if (swiper.animating || swiper.autoplay.paused) return;
        pause(true);
    };
    const onPointerLeave = e2 => {
        if (e2.pointerType !== "mouse") return;
        pausedByPointerEnter = false;
        if (swiper.autoplay.paused) resume();
    };
    const attachMouseEvents = () => {
        if (swiper.params.autoplay.pauseOnMouseEnter) {
            swiper.el.addEventListener("pointerenter", onPointerEnter);
            swiper.el.addEventListener("pointerleave", onPointerLeave);
        }
    };
    const detachMouseEvents = () => {
        if (swiper.el && typeof swiper.el !== "string") {
            swiper.el.removeEventListener("pointerenter", onPointerEnter);
            swiper.el.removeEventListener("pointerleave", onPointerLeave);
        }
    };
    const attachDocumentEvents = () => {
        const document2 = getDocument();
        document2.addEventListener("visibilitychange", onVisibilityChange);
    };
    const detachDocumentEvents = () => {
        const document2 = getDocument();
        document2.removeEventListener("visibilitychange", onVisibilityChange);
    };
    on("init", (() => {
        if (swiper.params.autoplay.enabled) {
            attachMouseEvents();
            attachDocumentEvents();
            start();
        }
    }));
    on("destroy", (() => {
        detachMouseEvents();
        detachDocumentEvents();
        if (swiper.autoplay.running) stop();
    }));
    on("_freeModeStaticRelease", (() => {
        if (pausedByTouch || pausedByInteraction) resume();
    }));
    on("_freeModeNoMomentumRelease", (() => {
        if (!swiper.params.autoplay.disableOnInteraction) pause(true, true); else stop();
    }));
    on("beforeTransitionStart", ((_s, speed, internal) => {
        if (swiper.destroyed || !swiper.autoplay.running) return;
        if (internal || !swiper.params.autoplay.disableOnInteraction) pause(true, true); else stop();
    }));
    on("sliderFirstMove", (() => {
        if (swiper.destroyed || !swiper.autoplay.running) return;
        if (swiper.params.autoplay.disableOnInteraction) {
            stop();
            return;
        }
        isTouched = true;
        pausedByTouch = false;
        pausedByInteraction = false;
        touchStartTimeout = setTimeout((() => {
            pausedByInteraction = true;
            pausedByTouch = true;
            pause(true);
        }), 200);
    }));
    on("touchEnd", (() => {
        if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
        clearTimeout(touchStartTimeout);
        clearTimeout(timeout);
        if (swiper.params.autoplay.disableOnInteraction) {
            pausedByTouch = false;
            isTouched = false;
            return;
        }
        if (pausedByTouch && swiper.params.cssMode) resume();
        pausedByTouch = false;
        isTouched = false;
    }));
    on("slideChange", (() => {
        if (swiper.destroyed || !swiper.autoplay.running) return;
        slideChanged = true;
    }));
    Object.assign(swiper.autoplay, {
        start: start,
        stop: stop,
        pause: pause,
        resume: resume
    });
}

function Thumb(_ref) {
    let {swiper: swiper, extendParams: extendParams, on: on} = _ref;
    extendParams({
        thumbs: {
            swiper: null,
            multipleActiveThumbs: true,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-thumbs"
        }
    });
    let initialized = false;
    let swiperCreated = false;
    swiper.thumbs = {
        swiper: null
    };
    function onThumbClick() {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        const clickedIndex = thumbsSwiper.clickedIndex;
        const clickedSlide = thumbsSwiper.clickedSlide;
        if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
        if (typeof clickedIndex === "undefined" || clickedIndex === null) return;
        let slideToIndex;
        if (thumbsSwiper.params.loop) slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10); else slideToIndex = clickedIndex;
        if (swiper.params.loop) swiper.slideToLoop(slideToIndex); else swiper.slideTo(slideToIndex);
    }
    function init() {
        const {thumbs: thumbsParams} = swiper.params;
        if (initialized) return false;
        initialized = true;
        const SwiperClass = swiper.constructor;
        if (thumbsParams.swiper instanceof SwiperClass) {
            swiper.thumbs.swiper = thumbsParams.swiper;
            Object.assign(swiper.thumbs.swiper.originalParams, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
            Object.assign(swiper.thumbs.swiper.params, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
            swiper.thumbs.swiper.update();
        } else if (isObject(thumbsParams.swiper)) {
            const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
            Object.assign(thumbsSwiperParams, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
            swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
            swiperCreated = true;
        }
        swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
        swiper.thumbs.swiper.on("tap", onThumbClick);
        return true;
    }
    function update2(initial) {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
        let thumbsToActivate = 1;
        const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) thumbsToActivate = swiper.params.slidesPerView;
        if (!swiper.params.thumbs.multipleActiveThumbs) thumbsToActivate = 1;
        thumbsToActivate = Math.floor(thumbsToActivate);
        thumbsSwiper.slides.forEach((slideEl => slideEl.classList.remove(thumbActiveClass)));
        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) for (let i2 = 0; i2 < thumbsToActivate; i2 += 1) elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i2}"]`).forEach((slideEl => {
            slideEl.classList.add(thumbActiveClass);
        })); else for (let i2 = 0; i2 < thumbsToActivate; i2 += 1) if (thumbsSwiper.slides[swiper.realIndex + i2]) thumbsSwiper.slides[swiper.realIndex + i2].classList.add(thumbActiveClass);
        const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
        const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
            const currentThumbsIndex = thumbsSwiper.activeIndex;
            let newThumbsIndex;
            let direction;
            if (thumbsSwiper.params.loop) {
                const newThumbsSlide = thumbsSwiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") === `${swiper.realIndex}`))[0];
                newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
                direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
            } else {
                newThumbsIndex = swiper.realIndex;
                direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
            }
            if (useOffset) newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
            if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                if (thumbsSwiper.params.centeredSlides) if (newThumbsIndex > currentThumbsIndex) newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1; else newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1; else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
                thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
            }
        }
    }
    on("beforeInit", (() => {
        const {thumbs: thumbs} = swiper.params;
        if (!thumbs || !thumbs.swiper) return;
        if (typeof thumbs.swiper === "string" || thumbs.swiper instanceof HTMLElement) {
            const document2 = getDocument();
            const getThumbsElementAndInit = () => {
                const thumbsElement = typeof thumbs.swiper === "string" ? document2.querySelector(thumbs.swiper) : thumbs.swiper;
                if (thumbsElement && thumbsElement.swiper) {
                    thumbs.swiper = thumbsElement.swiper;
                    init();
                    update2(true);
                } else if (thumbsElement) {
                    const onThumbsSwiper = e2 => {
                        thumbs.swiper = e2.detail[0];
                        thumbsElement.removeEventListener("init", onThumbsSwiper);
                        init();
                        update2(true);
                        thumbs.swiper.update();
                        swiper.update();
                    };
                    thumbsElement.addEventListener("init", onThumbsSwiper);
                }
                return thumbsElement;
            };
            const watchForThumbsToAppear = () => {
                if (swiper.destroyed) return;
                const thumbsElement = getThumbsElementAndInit();
                if (!thumbsElement) requestAnimationFrame(watchForThumbsToAppear);
            };
            requestAnimationFrame(watchForThumbsToAppear);
        } else {
            init();
            update2(true);
        }
    }));
    on("slideChange update resize observerUpdate", (() => {
        update2();
    }));
    on("setTransition", ((_s, duration) => {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        thumbsSwiper.setTransition(duration);
    }));
    on("beforeDestroy", (() => {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        if (swiperCreated) thumbsSwiper.destroy();
    }));
    Object.assign(swiper.thumbs, {
        init: init,
        update: update2
    });
}

function freeMode(_ref) {
    let {swiper: swiper, extendParams: extendParams, emit: emit, once: once} = _ref;
    extendParams({
        freeMode: {
            enabled: false,
            momentum: true,
            momentumRatio: 1,
            momentumBounce: true,
            momentumBounceRatio: 1,
            momentumVelocityRatio: 1,
            sticky: false,
            minimumVelocity: .02
        }
    });
    function onTouchStart2() {
        if (swiper.params.cssMode) return;
        const translate2 = swiper.getTranslate();
        swiper.setTranslate(translate2);
        swiper.setTransition(0);
        swiper.touchEventsData.velocities.length = 0;
        swiper.freeMode.onTouchEnd({
            currentPos: swiper.rtl ? swiper.translate : -swiper.translate
        });
    }
    function onTouchMove2() {
        if (swiper.params.cssMode) return;
        const {touchEventsData: data, touches: touches} = swiper;
        if (data.velocities.length === 0) data.velocities.push({
            position: touches[swiper.isHorizontal() ? "startX" : "startY"],
            time: data.touchStartTime
        });
        data.velocities.push({
            position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
            time: now()
        });
    }
    function onTouchEnd2(_ref2) {
        let {currentPos: currentPos} = _ref2;
        if (swiper.params.cssMode) return;
        const {params: params, wrapperEl: wrapperEl, rtlTranslate: rtl, snapGrid: snapGrid, touchEventsData: data} = swiper;
        const touchEndTime = now();
        const timeDiff = touchEndTime - data.touchStartTime;
        if (currentPos < -swiper.minTranslate()) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        if (currentPos > -swiper.maxTranslate()) {
            if (swiper.slides.length < snapGrid.length) swiper.slideTo(snapGrid.length - 1); else swiper.slideTo(swiper.slides.length - 1);
            return;
        }
        if (params.freeMode.momentum) {
            if (data.velocities.length > 1) {
                const lastMoveEvent = data.velocities.pop();
                const velocityEvent = data.velocities.pop();
                const distance = lastMoveEvent.position - velocityEvent.position;
                const time = lastMoveEvent.time - velocityEvent.time;
                swiper.velocity = distance / time;
                swiper.velocity /= 2;
                if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) swiper.velocity = 0;
                if (time > 150 || now() - lastMoveEvent.time > 300) swiper.velocity = 0;
            } else swiper.velocity = 0;
            swiper.velocity *= params.freeMode.momentumVelocityRatio;
            data.velocities.length = 0;
            let momentumDuration = 1e3 * params.freeMode.momentumRatio;
            const momentumDistance = swiper.velocity * momentumDuration;
            let newPosition = swiper.translate + momentumDistance;
            if (rtl) newPosition = -newPosition;
            let doBounce = false;
            let afterBouncePosition;
            const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
            let needsLoopFix;
            if (newPosition < swiper.maxTranslate()) {
                if (params.freeMode.momentumBounce) {
                    if (newPosition + swiper.maxTranslate() < -bounceAmount) newPosition = swiper.maxTranslate() - bounceAmount;
                    afterBouncePosition = swiper.maxTranslate();
                    doBounce = true;
                    data.allowMomentumBounce = true;
                } else newPosition = swiper.maxTranslate();
                if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (newPosition > swiper.minTranslate()) {
                if (params.freeMode.momentumBounce) {
                    if (newPosition - swiper.minTranslate() > bounceAmount) newPosition = swiper.minTranslate() + bounceAmount;
                    afterBouncePosition = swiper.minTranslate();
                    doBounce = true;
                    data.allowMomentumBounce = true;
                } else newPosition = swiper.minTranslate();
                if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (params.freeMode.sticky) {
                let nextSlide;
                for (let j2 = 0; j2 < snapGrid.length; j2 += 1) if (snapGrid[j2] > -newPosition) {
                    nextSlide = j2;
                    break;
                }
                if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") newPosition = snapGrid[nextSlide]; else newPosition = snapGrid[nextSlide - 1];
                newPosition = -newPosition;
            }
            if (needsLoopFix) once("transitionEnd", (() => {
                swiper.loopFix();
            }));
            if (swiper.velocity !== 0) {
                if (rtl) momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity); else momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                if (params.freeMode.sticky) {
                    const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                    const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                    if (moveDistance < currentSlideSize) momentumDuration = params.speed; else if (moveDistance < 2 * currentSlideSize) momentumDuration = params.speed * 1.5; else momentumDuration = params.speed * 2.5;
                }
            } else if (params.freeMode.sticky) {
                swiper.slideToClosest();
                return;
            }
            if (params.freeMode.momentumBounce && doBounce) {
                swiper.updateProgress(afterBouncePosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                swiper.animating = true;
                elementTransitionEnd(wrapperEl, (() => {
                    if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                    emit("momentumBounce");
                    swiper.setTransition(params.speed);
                    setTimeout((() => {
                        swiper.setTranslate(afterBouncePosition);
                        elementTransitionEnd(wrapperEl, (() => {
                            if (!swiper || swiper.destroyed) return;
                            swiper.transitionEnd();
                        }));
                    }), 0);
                }));
            } else if (swiper.velocity) {
                emit("_freeModeNoMomentumRelease");
                swiper.updateProgress(newPosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                if (!swiper.animating) {
                    swiper.animating = true;
                    elementTransitionEnd(wrapperEl, (() => {
                        if (!swiper || swiper.destroyed) return;
                        swiper.transitionEnd();
                    }));
                }
            } else swiper.updateProgress(newPosition);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        } else if (params.freeMode.sticky) {
            swiper.slideToClosest();
            return;
        } else if (params.freeMode) emit("_freeModeNoMomentumRelease");
        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
            emit("_freeModeStaticRelease");
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
    }
    Object.assign(swiper, {
        freeMode: {
            onTouchStart: onTouchStart2,
            onTouchMove: onTouchMove2,
            onTouchEnd: onTouchEnd2
        }
    });
}

export { Autoplay as A, Inputmask as I, Navigation as N, Oe as O, Pagination as P, Swiper as S, Thumb as T, _default as _, Scrollbar as a, freeMode as f };
